// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CRCLSTATUS_HXX
#define CRCLSTATUS_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class CommandStateEnumType;
class CommandStatusType;
class CRCLStatusType;
class GripperStatusType;
class JointStatusesType;
class JointStatusType;
class JointLimitType;
class ParallelGripperStatusType;
class PoseStatusType;
class SettingsStatusType;
class ThreeFingerGripperStatusType;
class VacuumGripperStatusType;
class MapType;
class MapItemType;
class ModelsStatusType;
class SensorStatusesType;
class GuardsStatusesType;
class SensorStatusType;
class OnOffSensorStatusType;
class ForceTorqueSensorStatusType;
class ScalarSensorStatusType;
class CountSensorStatusType;
class map;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "DataPrimitives.hxx"

class CommandStateEnumType: public ::xml_schema::string
{
  public:
  enum value
  {
    CRCL_Done,
    CRCL_Error,
    CRCL_Working,
    CRCL_Ready
  };

  CommandStateEnumType (value v);

  CommandStateEnumType (const char* v);

  CommandStateEnumType (const ::std::string& v);

  CommandStateEnumType (const ::xml_schema::string& v);

  CommandStateEnumType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  CommandStateEnumType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  CommandStateEnumType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  CommandStateEnumType (const CommandStateEnumType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual CommandStateEnumType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CommandStateEnumType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_CommandStateEnumType_convert ();
  }

  protected:
  value
  _xsd_CommandStateEnumType_convert () const;

  public:
  static const char* const _xsd_CommandStateEnumType_literals_[4];
  static const value _xsd_CommandStateEnumType_indexes_[4];
};

class CommandStatusType: public ::DataThingType
{
  public:
  // CommandID
  //
  typedef ::xml_schema::long_ CommandID_type;
  typedef ::xsd::cxx::tree::traits< CommandID_type, char > CommandID_traits;

  const CommandID_type&
  CommandID () const;

  CommandID_type&
  CommandID ();

  void
  CommandID (const CommandID_type& x);

  // StatusID
  //
  typedef ::xml_schema::long_ StatusID_type;
  typedef ::xsd::cxx::tree::traits< StatusID_type, char > StatusID_traits;

  const StatusID_type&
  StatusID () const;

  StatusID_type&
  StatusID ();

  void
  StatusID (const StatusID_type& x);

  // CommandState
  //
  typedef ::CommandStateEnumType CommandState_type;
  typedef ::xsd::cxx::tree::traits< CommandState_type, char > CommandState_traits;

  const CommandState_type&
  CommandState () const;

  CommandState_type&
  CommandState ();

  void
  CommandState (const CommandState_type& x);

  void
  CommandState (::std::auto_ptr< CommandState_type > p);

  // StateDescription
  //
  typedef ::xml_schema::string StateDescription_type;
  typedef ::xsd::cxx::tree::optional< StateDescription_type > StateDescription_optional;
  typedef ::xsd::cxx::tree::traits< StateDescription_type, char > StateDescription_traits;

  const StateDescription_optional&
  StateDescription () const;

  StateDescription_optional&
  StateDescription ();

  void
  StateDescription (const StateDescription_type& x);

  void
  StateDescription (const StateDescription_optional& x);

  void
  StateDescription (::std::auto_ptr< StateDescription_type > p);

  // ProgramFile
  //
  typedef ::xml_schema::string ProgramFile_type;
  typedef ::xsd::cxx::tree::optional< ProgramFile_type > ProgramFile_optional;
  typedef ::xsd::cxx::tree::traits< ProgramFile_type, char > ProgramFile_traits;

  const ProgramFile_optional&
  ProgramFile () const;

  ProgramFile_optional&
  ProgramFile ();

  void
  ProgramFile (const ProgramFile_type& x);

  void
  ProgramFile (const ProgramFile_optional& x);

  void
  ProgramFile (::std::auto_ptr< ProgramFile_type > p);

  // ProgramIndex
  //
  typedef ::xml_schema::int_ ProgramIndex_type;
  typedef ::xsd::cxx::tree::optional< ProgramIndex_type > ProgramIndex_optional;
  typedef ::xsd::cxx::tree::traits< ProgramIndex_type, char > ProgramIndex_traits;

  const ProgramIndex_optional&
  ProgramIndex () const;

  ProgramIndex_optional&
  ProgramIndex ();

  void
  ProgramIndex (const ProgramIndex_type& x);

  void
  ProgramIndex (const ProgramIndex_optional& x);

  // ProgramLength
  //
  typedef ::xml_schema::int_ ProgramLength_type;
  typedef ::xsd::cxx::tree::optional< ProgramLength_type > ProgramLength_optional;
  typedef ::xsd::cxx::tree::traits< ProgramLength_type, char > ProgramLength_traits;

  const ProgramLength_optional&
  ProgramLength () const;

  ProgramLength_optional&
  ProgramLength ();

  void
  ProgramLength (const ProgramLength_type& x);

  void
  ProgramLength (const ProgramLength_optional& x);

  // OverridePercent
  //
  typedef ::xml_schema::int_ OverridePercent_type;
  typedef ::xsd::cxx::tree::optional< OverridePercent_type > OverridePercent_optional;
  typedef ::xsd::cxx::tree::traits< OverridePercent_type, char > OverridePercent_traits;

  const OverridePercent_optional&
  OverridePercent () const;

  OverridePercent_optional&
  OverridePercent ();

  void
  OverridePercent (const OverridePercent_type& x);

  void
  OverridePercent (const OverridePercent_optional& x);

  // Constructors.
  //
  CommandStatusType (const CommandID_type&,
                     const StatusID_type&,
                     const CommandState_type&);

  CommandStatusType (const CommandID_type&,
                     const StatusID_type&,
                     ::std::auto_ptr< CommandState_type >);

  CommandStatusType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  CommandStatusType (const CommandStatusType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual CommandStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CommandStatusType&
  operator= (const CommandStatusType& x);

  virtual 
  ~CommandStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< CommandID_type > CommandID_;
  ::xsd::cxx::tree::one< StatusID_type > StatusID_;
  ::xsd::cxx::tree::one< CommandState_type > CommandState_;
  StateDescription_optional StateDescription_;
  ProgramFile_optional ProgramFile_;
  ProgramIndex_optional ProgramIndex_;
  ProgramLength_optional ProgramLength_;
  OverridePercent_optional OverridePercent_;
};

class CRCLStatusType: public ::DataThingType
{
  public:
  // CommandStatus
  //
  typedef ::CommandStatusType CommandStatus_type;
  typedef ::xsd::cxx::tree::traits< CommandStatus_type, char > CommandStatus_traits;

  const CommandStatus_type&
  CommandStatus () const;

  CommandStatus_type&
  CommandStatus ();

  void
  CommandStatus (const CommandStatus_type& x);

  void
  CommandStatus (::std::auto_ptr< CommandStatus_type > p);

  // JointStatuses
  //
  typedef ::JointStatusesType JointStatuses_type;
  typedef ::xsd::cxx::tree::optional< JointStatuses_type > JointStatuses_optional;
  typedef ::xsd::cxx::tree::traits< JointStatuses_type, char > JointStatuses_traits;

  const JointStatuses_optional&
  JointStatuses () const;

  JointStatuses_optional&
  JointStatuses ();

  void
  JointStatuses (const JointStatuses_type& x);

  void
  JointStatuses (const JointStatuses_optional& x);

  void
  JointStatuses (::std::auto_ptr< JointStatuses_type > p);

  // PoseStatus
  //
  typedef ::PoseStatusType PoseStatus_type;
  typedef ::xsd::cxx::tree::optional< PoseStatus_type > PoseStatus_optional;
  typedef ::xsd::cxx::tree::traits< PoseStatus_type, char > PoseStatus_traits;

  const PoseStatus_optional&
  PoseStatus () const;

  PoseStatus_optional&
  PoseStatus ();

  void
  PoseStatus (const PoseStatus_type& x);

  void
  PoseStatus (const PoseStatus_optional& x);

  void
  PoseStatus (::std::auto_ptr< PoseStatus_type > p);

  // GripperStatus
  //
  typedef ::GripperStatusType GripperStatus_type;
  typedef ::xsd::cxx::tree::optional< GripperStatus_type > GripperStatus_optional;
  typedef ::xsd::cxx::tree::traits< GripperStatus_type, char > GripperStatus_traits;

  const GripperStatus_optional&
  GripperStatus () const;

  GripperStatus_optional&
  GripperStatus ();

  void
  GripperStatus (const GripperStatus_type& x);

  void
  GripperStatus (const GripperStatus_optional& x);

  void
  GripperStatus (::std::auto_ptr< GripperStatus_type > p);

  // SettingsStatus
  //
  typedef ::SettingsStatusType SettingsStatus_type;
  typedef ::xsd::cxx::tree::optional< SettingsStatus_type > SettingsStatus_optional;
  typedef ::xsd::cxx::tree::traits< SettingsStatus_type, char > SettingsStatus_traits;

  const SettingsStatus_optional&
  SettingsStatus () const;

  SettingsStatus_optional&
  SettingsStatus ();

  void
  SettingsStatus (const SettingsStatus_type& x);

  void
  SettingsStatus (const SettingsStatus_optional& x);

  void
  SettingsStatus (::std::auto_ptr< SettingsStatus_type > p);

  // SensorStatuses
  //
  typedef ::SensorStatusesType SensorStatuses_type;
  typedef ::xsd::cxx::tree::optional< SensorStatuses_type > SensorStatuses_optional;
  typedef ::xsd::cxx::tree::traits< SensorStatuses_type, char > SensorStatuses_traits;

  const SensorStatuses_optional&
  SensorStatuses () const;

  SensorStatuses_optional&
  SensorStatuses ();

  void
  SensorStatuses (const SensorStatuses_type& x);

  void
  SensorStatuses (const SensorStatuses_optional& x);

  void
  SensorStatuses (::std::auto_ptr< SensorStatuses_type > p);

  // GuardsStatuses
  //
  typedef ::GuardsStatusesType GuardsStatuses_type;
  typedef ::xsd::cxx::tree::optional< GuardsStatuses_type > GuardsStatuses_optional;
  typedef ::xsd::cxx::tree::traits< GuardsStatuses_type, char > GuardsStatuses_traits;

  const GuardsStatuses_optional&
  GuardsStatuses () const;

  GuardsStatuses_optional&
  GuardsStatuses ();

  void
  GuardsStatuses (const GuardsStatuses_type& x);

  void
  GuardsStatuses (const GuardsStatuses_optional& x);

  void
  GuardsStatuses (::std::auto_ptr< GuardsStatuses_type > p);

  // ModelStatus
  //
  typedef ::ModelsStatusType ModelStatus_type;
  typedef ::xsd::cxx::tree::sequence< ModelStatus_type > ModelStatus_sequence;
  typedef ModelStatus_sequence::iterator ModelStatus_iterator;
  typedef ModelStatus_sequence::const_iterator ModelStatus_const_iterator;
  typedef ::xsd::cxx::tree::traits< ModelStatus_type, char > ModelStatus_traits;

  const ModelStatus_sequence&
  ModelStatus () const;

  ModelStatus_sequence&
  ModelStatus ();

  void
  ModelStatus (const ModelStatus_sequence& s);

  // Constructors.
  //
  CRCLStatusType (const CommandStatus_type&);

  CRCLStatusType (::std::auto_ptr< CommandStatus_type >);

  CRCLStatusType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  CRCLStatusType (const CRCLStatusType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual CRCLStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CRCLStatusType&
  operator= (const CRCLStatusType& x);

  virtual 
  ~CRCLStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< CommandStatus_type > CommandStatus_;
  JointStatuses_optional JointStatuses_;
  PoseStatus_optional PoseStatus_;
  GripperStatus_optional GripperStatus_;
  SettingsStatus_optional SettingsStatus_;
  SensorStatuses_optional SensorStatuses_;
  GuardsStatuses_optional GuardsStatuses_;
  ModelStatus_sequence ModelStatus_;
};

class GripperStatusType: public ::DataThingType
{
  public:
  // GripperName
  //
  typedef ::xml_schema::nmtoken GripperName_type;
  typedef ::xsd::cxx::tree::traits< GripperName_type, char > GripperName_traits;

  const GripperName_type&
  GripperName () const;

  GripperName_type&
  GripperName ();

  void
  GripperName (const GripperName_type& x);

  void
  GripperName (::std::auto_ptr< GripperName_type > p);

  // GripperOption
  //
  typedef ::ParameterSettingType GripperOption_type;
  typedef ::xsd::cxx::tree::sequence< GripperOption_type > GripperOption_sequence;
  typedef GripperOption_sequence::iterator GripperOption_iterator;
  typedef GripperOption_sequence::const_iterator GripperOption_const_iterator;
  typedef ::xsd::cxx::tree::traits< GripperOption_type, char > GripperOption_traits;

  const GripperOption_sequence&
  GripperOption () const;

  GripperOption_sequence&
  GripperOption ();

  void
  GripperOption (const GripperOption_sequence& s);

  // HoldingObject
  //
  typedef ::xml_schema::boolean HoldingObject_type;
  typedef ::xsd::cxx::tree::optional< HoldingObject_type > HoldingObject_optional;
  typedef ::xsd::cxx::tree::traits< HoldingObject_type, char > HoldingObject_traits;

  const HoldingObject_optional&
  HoldingObject () const;

  HoldingObject_optional&
  HoldingObject ();

  void
  HoldingObject (const HoldingObject_type& x);

  void
  HoldingObject (const HoldingObject_optional& x);

  // Constructors.
  //
  GripperStatusType (const GripperName_type&);

  GripperStatusType (::std::auto_ptr< GripperName_type >);

  GripperStatusType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  GripperStatusType (const GripperStatusType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual GripperStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  GripperStatusType&
  operator= (const GripperStatusType& x);

  virtual 
  ~GripperStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< GripperName_type > GripperName_;
  GripperOption_sequence GripperOption_;
  HoldingObject_optional HoldingObject_;
};

class JointStatusesType: public ::DataThingType
{
  public:
  // JointStatus
  //
  typedef ::JointStatusType JointStatus_type;
  typedef ::xsd::cxx::tree::sequence< JointStatus_type > JointStatus_sequence;
  typedef JointStatus_sequence::iterator JointStatus_iterator;
  typedef JointStatus_sequence::const_iterator JointStatus_const_iterator;
  typedef ::xsd::cxx::tree::traits< JointStatus_type, char > JointStatus_traits;

  const JointStatus_sequence&
  JointStatus () const;

  JointStatus_sequence&
  JointStatus ();

  void
  JointStatus (const JointStatus_sequence& s);

  // Constructors.
  //
  JointStatusesType ();

  JointStatusesType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  JointStatusesType (const JointStatusesType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual JointStatusesType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  JointStatusesType&
  operator= (const JointStatusesType& x);

  virtual 
  ~JointStatusesType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  JointStatus_sequence JointStatus_;
};

class JointStatusType: public ::DataThingType
{
  public:
  // JointNumber
  //
  typedef ::xml_schema::int_ JointNumber_type;
  typedef ::xsd::cxx::tree::traits< JointNumber_type, char > JointNumber_traits;

  const JointNumber_type&
  JointNumber () const;

  JointNumber_type&
  JointNumber ();

  void
  JointNumber (const JointNumber_type& x);

  // JointPosition
  //
  typedef ::xml_schema::double_ JointPosition_type;
  typedef ::xsd::cxx::tree::optional< JointPosition_type > JointPosition_optional;
  typedef ::xsd::cxx::tree::traits< JointPosition_type, char, ::xsd::cxx::tree::schema_type::double_ > JointPosition_traits;

  const JointPosition_optional&
  JointPosition () const;

  JointPosition_optional&
  JointPosition ();

  void
  JointPosition (const JointPosition_type& x);

  void
  JointPosition (const JointPosition_optional& x);

  // JointTorqueOrForce
  //
  typedef ::xml_schema::double_ JointTorqueOrForce_type;
  typedef ::xsd::cxx::tree::optional< JointTorqueOrForce_type > JointTorqueOrForce_optional;
  typedef ::xsd::cxx::tree::traits< JointTorqueOrForce_type, char, ::xsd::cxx::tree::schema_type::double_ > JointTorqueOrForce_traits;

  const JointTorqueOrForce_optional&
  JointTorqueOrForce () const;

  JointTorqueOrForce_optional&
  JointTorqueOrForce ();

  void
  JointTorqueOrForce (const JointTorqueOrForce_type& x);

  void
  JointTorqueOrForce (const JointTorqueOrForce_optional& x);

  // JointVelocity
  //
  typedef ::xml_schema::double_ JointVelocity_type;
  typedef ::xsd::cxx::tree::optional< JointVelocity_type > JointVelocity_optional;
  typedef ::xsd::cxx::tree::traits< JointVelocity_type, char, ::xsd::cxx::tree::schema_type::double_ > JointVelocity_traits;

  const JointVelocity_optional&
  JointVelocity () const;

  JointVelocity_optional&
  JointVelocity ();

  void
  JointVelocity (const JointVelocity_type& x);

  void
  JointVelocity (const JointVelocity_optional& x);

  // Constructors.
  //
  JointStatusType (const JointNumber_type&);

  JointStatusType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  JointStatusType (const JointStatusType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual JointStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  JointStatusType&
  operator= (const JointStatusType& x);

  virtual 
  ~JointStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< JointNumber_type > JointNumber_;
  JointPosition_optional JointPosition_;
  JointTorqueOrForce_optional JointTorqueOrForce_;
  JointVelocity_optional JointVelocity_;
};

class JointLimitType: public ::DataThingType
{
  public:
  // JointNumber
  //
  typedef ::xml_schema::int_ JointNumber_type;
  typedef ::xsd::cxx::tree::traits< JointNumber_type, char > JointNumber_traits;

  const JointNumber_type&
  JointNumber () const;

  JointNumber_type&
  JointNumber ();

  void
  JointNumber (const JointNumber_type& x);

  // JointMinPosition
  //
  typedef ::xml_schema::double_ JointMinPosition_type;
  typedef ::xsd::cxx::tree::optional< JointMinPosition_type > JointMinPosition_optional;
  typedef ::xsd::cxx::tree::traits< JointMinPosition_type, char, ::xsd::cxx::tree::schema_type::double_ > JointMinPosition_traits;

  const JointMinPosition_optional&
  JointMinPosition () const;

  JointMinPosition_optional&
  JointMinPosition ();

  void
  JointMinPosition (const JointMinPosition_type& x);

  void
  JointMinPosition (const JointMinPosition_optional& x);

  // JointMaxPosition
  //
  typedef ::xml_schema::double_ JointMaxPosition_type;
  typedef ::xsd::cxx::tree::optional< JointMaxPosition_type > JointMaxPosition_optional;
  typedef ::xsd::cxx::tree::traits< JointMaxPosition_type, char, ::xsd::cxx::tree::schema_type::double_ > JointMaxPosition_traits;

  const JointMaxPosition_optional&
  JointMaxPosition () const;

  JointMaxPosition_optional&
  JointMaxPosition ();

  void
  JointMaxPosition (const JointMaxPosition_type& x);

  void
  JointMaxPosition (const JointMaxPosition_optional& x);

  // JointMaxTorqueOrForce
  //
  typedef ::xml_schema::double_ JointMaxTorqueOrForce_type;
  typedef ::xsd::cxx::tree::optional< JointMaxTorqueOrForce_type > JointMaxTorqueOrForce_optional;
  typedef ::xsd::cxx::tree::traits< JointMaxTorqueOrForce_type, char, ::xsd::cxx::tree::schema_type::double_ > JointMaxTorqueOrForce_traits;

  const JointMaxTorqueOrForce_optional&
  JointMaxTorqueOrForce () const;

  JointMaxTorqueOrForce_optional&
  JointMaxTorqueOrForce ();

  void
  JointMaxTorqueOrForce (const JointMaxTorqueOrForce_type& x);

  void
  JointMaxTorqueOrForce (const JointMaxTorqueOrForce_optional& x);

  // JointMaxVelocity
  //
  typedef ::xml_schema::double_ JointMaxVelocity_type;
  typedef ::xsd::cxx::tree::optional< JointMaxVelocity_type > JointMaxVelocity_optional;
  typedef ::xsd::cxx::tree::traits< JointMaxVelocity_type, char, ::xsd::cxx::tree::schema_type::double_ > JointMaxVelocity_traits;

  const JointMaxVelocity_optional&
  JointMaxVelocity () const;

  JointMaxVelocity_optional&
  JointMaxVelocity ();

  void
  JointMaxVelocity (const JointMaxVelocity_type& x);

  void
  JointMaxVelocity (const JointMaxVelocity_optional& x);

  // Constructors.
  //
  JointLimitType (const JointNumber_type&);

  JointLimitType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  JointLimitType (const JointLimitType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual JointLimitType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  JointLimitType&
  operator= (const JointLimitType& x);

  virtual 
  ~JointLimitType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< JointNumber_type > JointNumber_;
  JointMinPosition_optional JointMinPosition_;
  JointMaxPosition_optional JointMaxPosition_;
  JointMaxTorqueOrForce_optional JointMaxTorqueOrForce_;
  JointMaxVelocity_optional JointMaxVelocity_;
};

class ParallelGripperStatusType: public ::GripperStatusType
{
  public:
  // Separation
  //
  typedef ::xml_schema::double_ Separation_type;
  typedef ::xsd::cxx::tree::traits< Separation_type, char, ::xsd::cxx::tree::schema_type::double_ > Separation_traits;

  const Separation_type&
  Separation () const;

  Separation_type&
  Separation ();

  void
  Separation (const Separation_type& x);

  // Constructors.
  //
  ParallelGripperStatusType (const ::GripperStatusType&,
                             const Separation_type&);

  ParallelGripperStatusType (const GripperName_type&,
                             const Separation_type&);

  ParallelGripperStatusType (::std::auto_ptr< GripperName_type >,
                             const Separation_type&);

  ParallelGripperStatusType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  ParallelGripperStatusType (const ParallelGripperStatusType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  virtual ParallelGripperStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ParallelGripperStatusType&
  operator= (const ParallelGripperStatusType& x);

  virtual 
  ~ParallelGripperStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Separation_type > Separation_;
};

class PoseStatusType: public ::DataThingType
{
  public:
  // Pose
  //
  typedef ::PoseType Pose_type;
  typedef ::xsd::cxx::tree::traits< Pose_type, char > Pose_traits;

  const Pose_type&
  Pose () const;

  Pose_type&
  Pose ();

  void
  Pose (const Pose_type& x);

  void
  Pose (::std::auto_ptr< Pose_type > p);

  // Twist
  //
  typedef ::TwistType Twist_type;
  typedef ::xsd::cxx::tree::optional< Twist_type > Twist_optional;
  typedef ::xsd::cxx::tree::traits< Twist_type, char > Twist_traits;

  const Twist_optional&
  Twist () const;

  Twist_optional&
  Twist ();

  void
  Twist (const Twist_type& x);

  void
  Twist (const Twist_optional& x);

  void
  Twist (::std::auto_ptr< Twist_type > p);

  // Wrench
  //
  typedef ::WrenchType Wrench_type;
  typedef ::xsd::cxx::tree::optional< Wrench_type > Wrench_optional;
  typedef ::xsd::cxx::tree::traits< Wrench_type, char > Wrench_traits;

  const Wrench_optional&
  Wrench () const;

  Wrench_optional&
  Wrench ();

  void
  Wrench (const Wrench_type& x);

  void
  Wrench (const Wrench_optional& x);

  void
  Wrench (::std::auto_ptr< Wrench_type > p);

  // Configuration
  //
  typedef ::xml_schema::string Configuration_type;
  typedef ::xsd::cxx::tree::optional< Configuration_type > Configuration_optional;
  typedef ::xsd::cxx::tree::traits< Configuration_type, char > Configuration_traits;

  const Configuration_optional&
  Configuration () const;

  Configuration_optional&
  Configuration ();

  void
  Configuration (const Configuration_type& x);

  void
  Configuration (const Configuration_optional& x);

  void
  Configuration (::std::auto_ptr< Configuration_type > p);

  // Constructors.
  //
  PoseStatusType (const Pose_type&);

  PoseStatusType (::std::auto_ptr< Pose_type >);

  PoseStatusType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  PoseStatusType (const PoseStatusType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual PoseStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  PoseStatusType&
  operator= (const PoseStatusType& x);

  virtual 
  ~PoseStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Pose_type > Pose_;
  Twist_optional Twist_;
  Wrench_optional Wrench_;
  Configuration_optional Configuration_;
};

class SettingsStatusType: public ::DataThingType
{
  public:
  // AngleUnitName
  //
  typedef ::AngleUnitEnumType AngleUnitName_type;
  typedef ::xsd::cxx::tree::optional< AngleUnitName_type > AngleUnitName_optional;
  typedef ::xsd::cxx::tree::traits< AngleUnitName_type, char > AngleUnitName_traits;

  const AngleUnitName_optional&
  AngleUnitName () const;

  AngleUnitName_optional&
  AngleUnitName ();

  void
  AngleUnitName (const AngleUnitName_type& x);

  void
  AngleUnitName (const AngleUnitName_optional& x);

  void
  AngleUnitName (::std::auto_ptr< AngleUnitName_type > p);

  // EndEffectorParameterSetting
  //
  typedef ::ParameterSettingType EndEffectorParameterSetting_type;
  typedef ::xsd::cxx::tree::sequence< EndEffectorParameterSetting_type > EndEffectorParameterSetting_sequence;
  typedef EndEffectorParameterSetting_sequence::iterator EndEffectorParameterSetting_iterator;
  typedef EndEffectorParameterSetting_sequence::const_iterator EndEffectorParameterSetting_const_iterator;
  typedef ::xsd::cxx::tree::traits< EndEffectorParameterSetting_type, char > EndEffectorParameterSetting_traits;

  const EndEffectorParameterSetting_sequence&
  EndEffectorParameterSetting () const;

  EndEffectorParameterSetting_sequence&
  EndEffectorParameterSetting ();

  void
  EndEffectorParameterSetting (const EndEffectorParameterSetting_sequence& s);

  // EndEffectorSetting
  //
  typedef ::FractionType EndEffectorSetting_type;
  typedef ::xsd::cxx::tree::optional< EndEffectorSetting_type > EndEffectorSetting_optional;
  typedef ::xsd::cxx::tree::traits< EndEffectorSetting_type, char > EndEffectorSetting_traits;

  const EndEffectorSetting_optional&
  EndEffectorSetting () const;

  EndEffectorSetting_optional&
  EndEffectorSetting ();

  void
  EndEffectorSetting (const EndEffectorSetting_type& x);

  void
  EndEffectorSetting (const EndEffectorSetting_optional& x);

  void
  EndEffectorSetting (::std::auto_ptr< EndEffectorSetting_type > p);

  // ForceUnitName
  //
  typedef ::ForceUnitEnumType ForceUnitName_type;
  typedef ::xsd::cxx::tree::optional< ForceUnitName_type > ForceUnitName_optional;
  typedef ::xsd::cxx::tree::traits< ForceUnitName_type, char > ForceUnitName_traits;

  const ForceUnitName_optional&
  ForceUnitName () const;

  ForceUnitName_optional&
  ForceUnitName ();

  void
  ForceUnitName (const ForceUnitName_type& x);

  void
  ForceUnitName (const ForceUnitName_optional& x);

  void
  ForceUnitName (::std::auto_ptr< ForceUnitName_type > p);

  // JointLimits
  //
  typedef ::JointLimitType JointLimits_type;
  typedef ::xsd::cxx::tree::sequence< JointLimits_type > JointLimits_sequence;
  typedef JointLimits_sequence::iterator JointLimits_iterator;
  typedef JointLimits_sequence::const_iterator JointLimits_const_iterator;
  typedef ::xsd::cxx::tree::traits< JointLimits_type, char > JointLimits_traits;

  const JointLimits_sequence&
  JointLimits () const;

  JointLimits_sequence&
  JointLimits ();

  void
  JointLimits (const JointLimits_sequence& s);

  // IntermediatePoseTolerance
  //
  typedef ::PoseToleranceType IntermediatePoseTolerance_type;
  typedef ::xsd::cxx::tree::optional< IntermediatePoseTolerance_type > IntermediatePoseTolerance_optional;
  typedef ::xsd::cxx::tree::traits< IntermediatePoseTolerance_type, char > IntermediatePoseTolerance_traits;

  const IntermediatePoseTolerance_optional&
  IntermediatePoseTolerance () const;

  IntermediatePoseTolerance_optional&
  IntermediatePoseTolerance ();

  void
  IntermediatePoseTolerance (const IntermediatePoseTolerance_type& x);

  void
  IntermediatePoseTolerance (const IntermediatePoseTolerance_optional& x);

  void
  IntermediatePoseTolerance (::std::auto_ptr< IntermediatePoseTolerance_type > p);

  // LengthUnitName
  //
  typedef ::LengthUnitEnumType LengthUnitName_type;
  typedef ::xsd::cxx::tree::optional< LengthUnitName_type > LengthUnitName_optional;
  typedef ::xsd::cxx::tree::traits< LengthUnitName_type, char > LengthUnitName_traits;

  const LengthUnitName_optional&
  LengthUnitName () const;

  LengthUnitName_optional&
  LengthUnitName ();

  void
  LengthUnitName (const LengthUnitName_type& x);

  void
  LengthUnitName (const LengthUnitName_optional& x);

  void
  LengthUnitName (::std::auto_ptr< LengthUnitName_type > p);

  // MaxCartesianLimit
  //
  typedef ::PointType MaxCartesianLimit_type;
  typedef ::xsd::cxx::tree::optional< MaxCartesianLimit_type > MaxCartesianLimit_optional;
  typedef ::xsd::cxx::tree::traits< MaxCartesianLimit_type, char > MaxCartesianLimit_traits;

  const MaxCartesianLimit_optional&
  MaxCartesianLimit () const;

  MaxCartesianLimit_optional&
  MaxCartesianLimit ();

  void
  MaxCartesianLimit (const MaxCartesianLimit_type& x);

  void
  MaxCartesianLimit (const MaxCartesianLimit_optional& x);

  void
  MaxCartesianLimit (::std::auto_ptr< MaxCartesianLimit_type > p);

  // MinCartesianLimit
  //
  typedef ::PointType MinCartesianLimit_type;
  typedef ::xsd::cxx::tree::optional< MinCartesianLimit_type > MinCartesianLimit_optional;
  typedef ::xsd::cxx::tree::traits< MinCartesianLimit_type, char > MinCartesianLimit_traits;

  const MinCartesianLimit_optional&
  MinCartesianLimit () const;

  MinCartesianLimit_optional&
  MinCartesianLimit ();

  void
  MinCartesianLimit (const MinCartesianLimit_type& x);

  void
  MinCartesianLimit (const MinCartesianLimit_optional& x);

  void
  MinCartesianLimit (::std::auto_ptr< MinCartesianLimit_type > p);

  // MotionCoordinated
  //
  typedef ::xml_schema::boolean MotionCoordinated_type;
  typedef ::xsd::cxx::tree::optional< MotionCoordinated_type > MotionCoordinated_optional;
  typedef ::xsd::cxx::tree::traits< MotionCoordinated_type, char > MotionCoordinated_traits;

  const MotionCoordinated_optional&
  MotionCoordinated () const;

  MotionCoordinated_optional&
  MotionCoordinated ();

  void
  MotionCoordinated (const MotionCoordinated_type& x);

  void
  MotionCoordinated (const MotionCoordinated_optional& x);

  // EndPoseTolerance
  //
  typedef ::PoseToleranceType EndPoseTolerance_type;
  typedef ::xsd::cxx::tree::optional< EndPoseTolerance_type > EndPoseTolerance_optional;
  typedef ::xsd::cxx::tree::traits< EndPoseTolerance_type, char > EndPoseTolerance_traits;

  const EndPoseTolerance_optional&
  EndPoseTolerance () const;

  EndPoseTolerance_optional&
  EndPoseTolerance ();

  void
  EndPoseTolerance (const EndPoseTolerance_type& x);

  void
  EndPoseTolerance (const EndPoseTolerance_optional& x);

  void
  EndPoseTolerance (::std::auto_ptr< EndPoseTolerance_type > p);

  // RobotParameterSetting
  //
  typedef ::ParameterSettingType RobotParameterSetting_type;
  typedef ::xsd::cxx::tree::sequence< RobotParameterSetting_type > RobotParameterSetting_sequence;
  typedef RobotParameterSetting_sequence::iterator RobotParameterSetting_iterator;
  typedef RobotParameterSetting_sequence::const_iterator RobotParameterSetting_const_iterator;
  typedef ::xsd::cxx::tree::traits< RobotParameterSetting_type, char > RobotParameterSetting_traits;

  const RobotParameterSetting_sequence&
  RobotParameterSetting () const;

  RobotParameterSetting_sequence&
  RobotParameterSetting ();

  void
  RobotParameterSetting (const RobotParameterSetting_sequence& s);

  // RotAccelAbsolute
  //
  typedef ::RotAccelAbsoluteType RotAccelAbsolute_type;
  typedef ::xsd::cxx::tree::optional< RotAccelAbsolute_type > RotAccelAbsolute_optional;
  typedef ::xsd::cxx::tree::traits< RotAccelAbsolute_type, char > RotAccelAbsolute_traits;

  const RotAccelAbsolute_optional&
  RotAccelAbsolute () const;

  RotAccelAbsolute_optional&
  RotAccelAbsolute ();

  void
  RotAccelAbsolute (const RotAccelAbsolute_type& x);

  void
  RotAccelAbsolute (const RotAccelAbsolute_optional& x);

  void
  RotAccelAbsolute (::std::auto_ptr< RotAccelAbsolute_type > p);

  // RotAccelRelative
  //
  typedef ::RotAccelRelativeType RotAccelRelative_type;
  typedef ::xsd::cxx::tree::optional< RotAccelRelative_type > RotAccelRelative_optional;
  typedef ::xsd::cxx::tree::traits< RotAccelRelative_type, char > RotAccelRelative_traits;

  const RotAccelRelative_optional&
  RotAccelRelative () const;

  RotAccelRelative_optional&
  RotAccelRelative ();

  void
  RotAccelRelative (const RotAccelRelative_type& x);

  void
  RotAccelRelative (const RotAccelRelative_optional& x);

  void
  RotAccelRelative (::std::auto_ptr< RotAccelRelative_type > p);

  // RotSpeedAbsolute
  //
  typedef ::RotSpeedAbsoluteType RotSpeedAbsolute_type;
  typedef ::xsd::cxx::tree::optional< RotSpeedAbsolute_type > RotSpeedAbsolute_optional;
  typedef ::xsd::cxx::tree::traits< RotSpeedAbsolute_type, char > RotSpeedAbsolute_traits;

  const RotSpeedAbsolute_optional&
  RotSpeedAbsolute () const;

  RotSpeedAbsolute_optional&
  RotSpeedAbsolute ();

  void
  RotSpeedAbsolute (const RotSpeedAbsolute_type& x);

  void
  RotSpeedAbsolute (const RotSpeedAbsolute_optional& x);

  void
  RotSpeedAbsolute (::std::auto_ptr< RotSpeedAbsolute_type > p);

  // RotSpeedRelative
  //
  typedef ::RotSpeedRelativeType RotSpeedRelative_type;
  typedef ::xsd::cxx::tree::optional< RotSpeedRelative_type > RotSpeedRelative_optional;
  typedef ::xsd::cxx::tree::traits< RotSpeedRelative_type, char > RotSpeedRelative_traits;

  const RotSpeedRelative_optional&
  RotSpeedRelative () const;

  RotSpeedRelative_optional&
  RotSpeedRelative ();

  void
  RotSpeedRelative (const RotSpeedRelative_type& x);

  void
  RotSpeedRelative (const RotSpeedRelative_optional& x);

  void
  RotSpeedRelative (::std::auto_ptr< RotSpeedRelative_type > p);

  // TorqueUnitName
  //
  typedef ::TorqueUnitEnumType TorqueUnitName_type;
  typedef ::xsd::cxx::tree::optional< TorqueUnitName_type > TorqueUnitName_optional;
  typedef ::xsd::cxx::tree::traits< TorqueUnitName_type, char > TorqueUnitName_traits;

  const TorqueUnitName_optional&
  TorqueUnitName () const;

  TorqueUnitName_optional&
  TorqueUnitName ();

  void
  TorqueUnitName (const TorqueUnitName_type& x);

  void
  TorqueUnitName (const TorqueUnitName_optional& x);

  void
  TorqueUnitName (::std::auto_ptr< TorqueUnitName_type > p);

  // TransAccelAbsolute
  //
  typedef ::TransAccelAbsoluteType TransAccelAbsolute_type;
  typedef ::xsd::cxx::tree::optional< TransAccelAbsolute_type > TransAccelAbsolute_optional;
  typedef ::xsd::cxx::tree::traits< TransAccelAbsolute_type, char > TransAccelAbsolute_traits;

  const TransAccelAbsolute_optional&
  TransAccelAbsolute () const;

  TransAccelAbsolute_optional&
  TransAccelAbsolute ();

  void
  TransAccelAbsolute (const TransAccelAbsolute_type& x);

  void
  TransAccelAbsolute (const TransAccelAbsolute_optional& x);

  void
  TransAccelAbsolute (::std::auto_ptr< TransAccelAbsolute_type > p);

  // TransAccelRelative
  //
  typedef ::TransAccelRelativeType TransAccelRelative_type;
  typedef ::xsd::cxx::tree::optional< TransAccelRelative_type > TransAccelRelative_optional;
  typedef ::xsd::cxx::tree::traits< TransAccelRelative_type, char > TransAccelRelative_traits;

  const TransAccelRelative_optional&
  TransAccelRelative () const;

  TransAccelRelative_optional&
  TransAccelRelative ();

  void
  TransAccelRelative (const TransAccelRelative_type& x);

  void
  TransAccelRelative (const TransAccelRelative_optional& x);

  void
  TransAccelRelative (::std::auto_ptr< TransAccelRelative_type > p);

  // TransSpeedAbsolute
  //
  typedef ::TransSpeedAbsoluteType TransSpeedAbsolute_type;
  typedef ::xsd::cxx::tree::optional< TransSpeedAbsolute_type > TransSpeedAbsolute_optional;
  typedef ::xsd::cxx::tree::traits< TransSpeedAbsolute_type, char > TransSpeedAbsolute_traits;

  const TransSpeedAbsolute_optional&
  TransSpeedAbsolute () const;

  TransSpeedAbsolute_optional&
  TransSpeedAbsolute ();

  void
  TransSpeedAbsolute (const TransSpeedAbsolute_type& x);

  void
  TransSpeedAbsolute (const TransSpeedAbsolute_optional& x);

  void
  TransSpeedAbsolute (::std::auto_ptr< TransSpeedAbsolute_type > p);

  // TransSpeedRelative
  //
  typedef ::TransSpeedRelativeType TransSpeedRelative_type;
  typedef ::xsd::cxx::tree::optional< TransSpeedRelative_type > TransSpeedRelative_optional;
  typedef ::xsd::cxx::tree::traits< TransSpeedRelative_type, char > TransSpeedRelative_traits;

  const TransSpeedRelative_optional&
  TransSpeedRelative () const;

  TransSpeedRelative_optional&
  TransSpeedRelative ();

  void
  TransSpeedRelative (const TransSpeedRelative_type& x);

  void
  TransSpeedRelative (const TransSpeedRelative_optional& x);

  void
  TransSpeedRelative (::std::auto_ptr< TransSpeedRelative_type > p);

  // JointTolerances
  //
  typedef ::JointPositionsTolerancesType JointTolerances_type;
  typedef ::xsd::cxx::tree::optional< JointTolerances_type > JointTolerances_optional;
  typedef ::xsd::cxx::tree::traits< JointTolerances_type, char > JointTolerances_traits;

  const JointTolerances_optional&
  JointTolerances () const;

  JointTolerances_optional&
  JointTolerances ();

  void
  JointTolerances (const JointTolerances_type& x);

  void
  JointTolerances (const JointTolerances_optional& x);

  void
  JointTolerances (::std::auto_ptr< JointTolerances_type > p);

  // Constructors.
  //
  SettingsStatusType ();

  SettingsStatusType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  SettingsStatusType (const SettingsStatusType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual SettingsStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  SettingsStatusType&
  operator= (const SettingsStatusType& x);

  virtual 
  ~SettingsStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  AngleUnitName_optional AngleUnitName_;
  EndEffectorParameterSetting_sequence EndEffectorParameterSetting_;
  EndEffectorSetting_optional EndEffectorSetting_;
  ForceUnitName_optional ForceUnitName_;
  JointLimits_sequence JointLimits_;
  IntermediatePoseTolerance_optional IntermediatePoseTolerance_;
  LengthUnitName_optional LengthUnitName_;
  MaxCartesianLimit_optional MaxCartesianLimit_;
  MinCartesianLimit_optional MinCartesianLimit_;
  MotionCoordinated_optional MotionCoordinated_;
  EndPoseTolerance_optional EndPoseTolerance_;
  RobotParameterSetting_sequence RobotParameterSetting_;
  RotAccelAbsolute_optional RotAccelAbsolute_;
  RotAccelRelative_optional RotAccelRelative_;
  RotSpeedAbsolute_optional RotSpeedAbsolute_;
  RotSpeedRelative_optional RotSpeedRelative_;
  TorqueUnitName_optional TorqueUnitName_;
  TransAccelAbsolute_optional TransAccelAbsolute_;
  TransAccelRelative_optional TransAccelRelative_;
  TransSpeedAbsolute_optional TransSpeedAbsolute_;
  TransSpeedRelative_optional TransSpeedRelative_;
  JointTolerances_optional JointTolerances_;
};

class ThreeFingerGripperStatusType: public ::GripperStatusType
{
  public:
  // Finger1Position
  //
  typedef ::FractionType Finger1Position_type;
  typedef ::xsd::cxx::tree::optional< Finger1Position_type > Finger1Position_optional;
  typedef ::xsd::cxx::tree::traits< Finger1Position_type, char > Finger1Position_traits;

  const Finger1Position_optional&
  Finger1Position () const;

  Finger1Position_optional&
  Finger1Position ();

  void
  Finger1Position (const Finger1Position_type& x);

  void
  Finger1Position (const Finger1Position_optional& x);

  void
  Finger1Position (::std::auto_ptr< Finger1Position_type > p);

  // Finger2Position
  //
  typedef ::FractionType Finger2Position_type;
  typedef ::xsd::cxx::tree::optional< Finger2Position_type > Finger2Position_optional;
  typedef ::xsd::cxx::tree::traits< Finger2Position_type, char > Finger2Position_traits;

  const Finger2Position_optional&
  Finger2Position () const;

  Finger2Position_optional&
  Finger2Position ();

  void
  Finger2Position (const Finger2Position_type& x);

  void
  Finger2Position (const Finger2Position_optional& x);

  void
  Finger2Position (::std::auto_ptr< Finger2Position_type > p);

  // Finger3Position
  //
  typedef ::FractionType Finger3Position_type;
  typedef ::xsd::cxx::tree::optional< Finger3Position_type > Finger3Position_optional;
  typedef ::xsd::cxx::tree::traits< Finger3Position_type, char > Finger3Position_traits;

  const Finger3Position_optional&
  Finger3Position () const;

  Finger3Position_optional&
  Finger3Position ();

  void
  Finger3Position (const Finger3Position_type& x);

  void
  Finger3Position (const Finger3Position_optional& x);

  void
  Finger3Position (::std::auto_ptr< Finger3Position_type > p);

  // Finger1Force
  //
  typedef ::xml_schema::double_ Finger1Force_type;
  typedef ::xsd::cxx::tree::optional< Finger1Force_type > Finger1Force_optional;
  typedef ::xsd::cxx::tree::traits< Finger1Force_type, char, ::xsd::cxx::tree::schema_type::double_ > Finger1Force_traits;

  const Finger1Force_optional&
  Finger1Force () const;

  Finger1Force_optional&
  Finger1Force ();

  void
  Finger1Force (const Finger1Force_type& x);

  void
  Finger1Force (const Finger1Force_optional& x);

  // Finger2Force
  //
  typedef ::xml_schema::double_ Finger2Force_type;
  typedef ::xsd::cxx::tree::optional< Finger2Force_type > Finger2Force_optional;
  typedef ::xsd::cxx::tree::traits< Finger2Force_type, char, ::xsd::cxx::tree::schema_type::double_ > Finger2Force_traits;

  const Finger2Force_optional&
  Finger2Force () const;

  Finger2Force_optional&
  Finger2Force ();

  void
  Finger2Force (const Finger2Force_type& x);

  void
  Finger2Force (const Finger2Force_optional& x);

  // Finger3Force
  //
  typedef ::xml_schema::double_ Finger3Force_type;
  typedef ::xsd::cxx::tree::optional< Finger3Force_type > Finger3Force_optional;
  typedef ::xsd::cxx::tree::traits< Finger3Force_type, char, ::xsd::cxx::tree::schema_type::double_ > Finger3Force_traits;

  const Finger3Force_optional&
  Finger3Force () const;

  Finger3Force_optional&
  Finger3Force ();

  void
  Finger3Force (const Finger3Force_type& x);

  void
  Finger3Force (const Finger3Force_optional& x);

  // Constructors.
  //
  ThreeFingerGripperStatusType (const ::GripperStatusType&);

  ThreeFingerGripperStatusType (const GripperName_type&);

  ThreeFingerGripperStatusType (::std::auto_ptr< GripperName_type >);

  ThreeFingerGripperStatusType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  ThreeFingerGripperStatusType (const ThreeFingerGripperStatusType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  virtual ThreeFingerGripperStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ThreeFingerGripperStatusType&
  operator= (const ThreeFingerGripperStatusType& x);

  virtual 
  ~ThreeFingerGripperStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Finger1Position_optional Finger1Position_;
  Finger2Position_optional Finger2Position_;
  Finger3Position_optional Finger3Position_;
  Finger1Force_optional Finger1Force_;
  Finger2Force_optional Finger2Force_;
  Finger3Force_optional Finger3Force_;
};

class VacuumGripperStatusType: public ::GripperStatusType
{
  public:
  // IsPowered
  //
  typedef ::xml_schema::boolean IsPowered_type;
  typedef ::xsd::cxx::tree::traits< IsPowered_type, char > IsPowered_traits;

  const IsPowered_type&
  IsPowered () const;

  IsPowered_type&
  IsPowered ();

  void
  IsPowered (const IsPowered_type& x);

  // Constructors.
  //
  VacuumGripperStatusType (const ::GripperStatusType&,
                           const IsPowered_type&);

  VacuumGripperStatusType (const GripperName_type&,
                           const IsPowered_type&);

  VacuumGripperStatusType (::std::auto_ptr< GripperName_type >,
                           const IsPowered_type&);

  VacuumGripperStatusType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  VacuumGripperStatusType (const VacuumGripperStatusType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual VacuumGripperStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  VacuumGripperStatusType&
  operator= (const VacuumGripperStatusType& x);

  virtual 
  ~VacuumGripperStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< IsPowered_type > IsPowered_;
};

class MapType: public ::xml_schema::type
{
  public:
  // map
  //
  typedef ::map map_type;
  typedef ::xsd::cxx::tree::traits< map_type, char > map_traits;

  const map_type&
  map () const;

  map_type&
  map ();

  void
  map (const map_type& x);

  void
  map (::std::auto_ptr< map_type > p);

  // Constructors.
  //
  MapType (const map_type&);

  MapType (::std::auto_ptr< map_type >);

  MapType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  MapType (const MapType& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual MapType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  MapType&
  operator= (const MapType& x);

  virtual 
  ~MapType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< map_type > map_;
};

class MapItemType: public ::xml_schema::type
{
  public:
  // key
  //
  typedef ::xml_schema::string key_type;
  typedef ::xsd::cxx::tree::traits< key_type, char > key_traits;

  const key_type&
  key () const;

  key_type&
  key ();

  void
  key (const key_type& x);

  void
  key (::std::auto_ptr< key_type > p);

  // value
  //
  typedef ::xml_schema::string value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  void
  value (::std::auto_ptr< value_type > p);

  // name
  //
  typedef ::xml_schema::simple_type name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // Constructors.
  //
  MapItemType (const key_type&,
               const value_type&,
               const name_type&);

  MapItemType (::std::auto_ptr< key_type >,
               ::std::auto_ptr< value_type >,
               const name_type&);

  MapItemType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  MapItemType (const MapItemType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual MapItemType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  MapItemType&
  operator= (const MapItemType& x);

  virtual 
  ~MapItemType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< key_type > key_;
  ::xsd::cxx::tree::one< value_type > value_;
  ::xsd::cxx::tree::one< name_type > name_;
};

class ModelsStatusType: public ::xml_schema::type
{
  public:
  // Name
  //
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Pose
  //
  typedef ::PoseType Pose_type;
  typedef ::xsd::cxx::tree::traits< Pose_type, char > Pose_traits;

  const Pose_type&
  Pose () const;

  Pose_type&
  Pose ();

  void
  Pose (const Pose_type& x);

  void
  Pose (::std::auto_ptr< Pose_type > p);

  // Twist
  //
  typedef ::TwistType Twist_type;
  typedef ::xsd::cxx::tree::optional< Twist_type > Twist_optional;
  typedef ::xsd::cxx::tree::traits< Twist_type, char > Twist_traits;

  const Twist_optional&
  Twist () const;

  Twist_optional&
  Twist ();

  void
  Twist (const Twist_type& x);

  void
  Twist (const Twist_optional& x);

  void
  Twist (::std::auto_ptr< Twist_type > p);

  // Wrench
  //
  typedef ::WrenchType Wrench_type;
  typedef ::xsd::cxx::tree::optional< Wrench_type > Wrench_optional;
  typedef ::xsd::cxx::tree::traits< Wrench_type, char > Wrench_traits;

  const Wrench_optional&
  Wrench () const;

  Wrench_optional&
  Wrench ();

  void
  Wrench (const Wrench_type& x);

  void
  Wrench (const Wrench_optional& x);

  void
  Wrench (::std::auto_ptr< Wrench_type > p);

  // Properties
  //
  typedef ::MapType Properties_type;
  typedef ::xsd::cxx::tree::optional< Properties_type > Properties_optional;
  typedef ::xsd::cxx::tree::traits< Properties_type, char > Properties_traits;

  const Properties_optional&
  Properties () const;

  Properties_optional&
  Properties ();

  void
  Properties (const Properties_type& x);

  void
  Properties (const Properties_optional& x);

  void
  Properties (::std::auto_ptr< Properties_type > p);

  // Constructors.
  //
  ModelsStatusType (const Name_type&,
                    const Pose_type&);

  ModelsStatusType (const Name_type&,
                    ::std::auto_ptr< Pose_type >);

  ModelsStatusType (::std::auto_ptr< Name_type >,
                    ::std::auto_ptr< Pose_type >);

  ModelsStatusType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  ModelsStatusType (const ModelsStatusType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual ModelsStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ModelsStatusType&
  operator= (const ModelsStatusType& x);

  virtual 
  ~ModelsStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Name_type > Name_;
  ::xsd::cxx::tree::one< Pose_type > Pose_;
  Twist_optional Twist_;
  Wrench_optional Wrench_;
  Properties_optional Properties_;
};

class SensorStatusesType: public ::DataThingType
{
  public:
  // OnOffSensorStatus
  //
  typedef ::OnOffSensorStatusType OnOffSensorStatus_type;
  typedef ::xsd::cxx::tree::sequence< OnOffSensorStatus_type > OnOffSensorStatus_sequence;
  typedef OnOffSensorStatus_sequence::iterator OnOffSensorStatus_iterator;
  typedef OnOffSensorStatus_sequence::const_iterator OnOffSensorStatus_const_iterator;
  typedef ::xsd::cxx::tree::traits< OnOffSensorStatus_type, char > OnOffSensorStatus_traits;

  const OnOffSensorStatus_sequence&
  OnOffSensorStatus () const;

  OnOffSensorStatus_sequence&
  OnOffSensorStatus ();

  void
  OnOffSensorStatus (const OnOffSensorStatus_sequence& s);

  // ScalarSensorStatus
  //
  typedef ::ScalarSensorStatusType ScalarSensorStatus_type;
  typedef ::xsd::cxx::tree::sequence< ScalarSensorStatus_type > ScalarSensorStatus_sequence;
  typedef ScalarSensorStatus_sequence::iterator ScalarSensorStatus_iterator;
  typedef ScalarSensorStatus_sequence::const_iterator ScalarSensorStatus_const_iterator;
  typedef ::xsd::cxx::tree::traits< ScalarSensorStatus_type, char > ScalarSensorStatus_traits;

  const ScalarSensorStatus_sequence&
  ScalarSensorStatus () const;

  ScalarSensorStatus_sequence&
  ScalarSensorStatus ();

  void
  ScalarSensorStatus (const ScalarSensorStatus_sequence& s);

  // CountSensorStatus
  //
  typedef ::CountSensorStatusType CountSensorStatus_type;
  typedef ::xsd::cxx::tree::sequence< CountSensorStatus_type > CountSensorStatus_sequence;
  typedef CountSensorStatus_sequence::iterator CountSensorStatus_iterator;
  typedef CountSensorStatus_sequence::const_iterator CountSensorStatus_const_iterator;
  typedef ::xsd::cxx::tree::traits< CountSensorStatus_type, char > CountSensorStatus_traits;

  const CountSensorStatus_sequence&
  CountSensorStatus () const;

  CountSensorStatus_sequence&
  CountSensorStatus ();

  void
  CountSensorStatus (const CountSensorStatus_sequence& s);

  // ForceTorqueSensorStatus
  //
  typedef ::ForceTorqueSensorStatusType ForceTorqueSensorStatus_type;
  typedef ::xsd::cxx::tree::sequence< ForceTorqueSensorStatus_type > ForceTorqueSensorStatus_sequence;
  typedef ForceTorqueSensorStatus_sequence::iterator ForceTorqueSensorStatus_iterator;
  typedef ForceTorqueSensorStatus_sequence::const_iterator ForceTorqueSensorStatus_const_iterator;
  typedef ::xsd::cxx::tree::traits< ForceTorqueSensorStatus_type, char > ForceTorqueSensorStatus_traits;

  const ForceTorqueSensorStatus_sequence&
  ForceTorqueSensorStatus () const;

  ForceTorqueSensorStatus_sequence&
  ForceTorqueSensorStatus ();

  void
  ForceTorqueSensorStatus (const ForceTorqueSensorStatus_sequence& s);

  // Constructors.
  //
  SensorStatusesType ();

  SensorStatusesType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  SensorStatusesType (const SensorStatusesType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual SensorStatusesType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  SensorStatusesType&
  operator= (const SensorStatusesType& x);

  virtual 
  ~SensorStatusesType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  OnOffSensorStatus_sequence OnOffSensorStatus_;
  ScalarSensorStatus_sequence ScalarSensorStatus_;
  CountSensorStatus_sequence CountSensorStatus_;
  ForceTorqueSensorStatus_sequence ForceTorqueSensorStatus_;
};

class GuardsStatusesType: public ::DataThingType
{
  public:
  // Guard
  //
  typedef ::GuardType Guard_type;
  typedef ::xsd::cxx::tree::sequence< Guard_type > Guard_sequence;
  typedef Guard_sequence::iterator Guard_iterator;
  typedef Guard_sequence::const_iterator Guard_const_iterator;
  typedef ::xsd::cxx::tree::traits< Guard_type, char > Guard_traits;

  const Guard_sequence&
  Guard () const;

  Guard_sequence&
  Guard ();

  void
  Guard (const Guard_sequence& s);

  // TriggerCount
  //
  typedef ::xml_schema::int_ TriggerCount_type;
  typedef ::xsd::cxx::tree::traits< TriggerCount_type, char > TriggerCount_traits;

  const TriggerCount_type&
  TriggerCount () const;

  TriggerCount_type&
  TriggerCount ();

  void
  TriggerCount (const TriggerCount_type& x);

  // TriggerStopTimeMicros
  //
  typedef ::xml_schema::long_ TriggerStopTimeMicros_type;
  typedef ::xsd::cxx::tree::traits< TriggerStopTimeMicros_type, char > TriggerStopTimeMicros_traits;

  const TriggerStopTimeMicros_type&
  TriggerStopTimeMicros () const;

  TriggerStopTimeMicros_type&
  TriggerStopTimeMicros ();

  void
  TriggerStopTimeMicros (const TriggerStopTimeMicros_type& x);

  // TriggerValue
  //
  typedef ::xml_schema::double_ TriggerValue_type;
  typedef ::xsd::cxx::tree::optional< TriggerValue_type > TriggerValue_optional;
  typedef ::xsd::cxx::tree::traits< TriggerValue_type, char, ::xsd::cxx::tree::schema_type::double_ > TriggerValue_traits;

  const TriggerValue_optional&
  TriggerValue () const;

  TriggerValue_optional&
  TriggerValue ();

  void
  TriggerValue (const TriggerValue_type& x);

  void
  TriggerValue (const TriggerValue_optional& x);

  // TriggerPose
  //
  typedef ::PoseType TriggerPose_type;
  typedef ::xsd::cxx::tree::optional< TriggerPose_type > TriggerPose_optional;
  typedef ::xsd::cxx::tree::traits< TriggerPose_type, char > TriggerPose_traits;

  const TriggerPose_optional&
  TriggerPose () const;

  TriggerPose_optional&
  TriggerPose ();

  void
  TriggerPose (const TriggerPose_type& x);

  void
  TriggerPose (const TriggerPose_optional& x);

  void
  TriggerPose (::std::auto_ptr< TriggerPose_type > p);

  // Constructors.
  //
  GuardsStatusesType (const TriggerCount_type&,
                      const TriggerStopTimeMicros_type&);

  GuardsStatusesType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  GuardsStatusesType (const GuardsStatusesType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual GuardsStatusesType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  GuardsStatusesType&
  operator= (const GuardsStatusesType& x);

  virtual 
  ~GuardsStatusesType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Guard_sequence Guard_;
  ::xsd::cxx::tree::one< TriggerCount_type > TriggerCount_;
  ::xsd::cxx::tree::one< TriggerStopTimeMicros_type > TriggerStopTimeMicros_;
  TriggerValue_optional TriggerValue_;
  TriggerPose_optional TriggerPose_;
};

class SensorStatusType: public ::DataThingType
{
  public:
  // SensorID
  //
  typedef ::xml_schema::token SensorID_type;
  typedef ::xsd::cxx::tree::traits< SensorID_type, char > SensorID_traits;

  const SensorID_type&
  SensorID () const;

  SensorID_type&
  SensorID ();

  void
  SensorID (const SensorID_type& x);

  void
  SensorID (::std::auto_ptr< SensorID_type > p);

  // ReadCount
  //
  typedef ::xml_schema::int_ ReadCount_type;
  typedef ::xsd::cxx::tree::traits< ReadCount_type, char > ReadCount_traits;

  const ReadCount_type&
  ReadCount () const;

  ReadCount_type&
  ReadCount ();

  void
  ReadCount (const ReadCount_type& x);

  // LastReadTime
  //
  typedef ::xml_schema::long_ LastReadTime_type;
  typedef ::xsd::cxx::tree::traits< LastReadTime_type, char > LastReadTime_traits;

  const LastReadTime_type&
  LastReadTime () const;

  LastReadTime_type&
  LastReadTime ();

  void
  LastReadTime (const LastReadTime_type& x);

  // SensorParameterSetting
  //
  typedef ::ParameterSettingType SensorParameterSetting_type;
  typedef ::xsd::cxx::tree::sequence< SensorParameterSetting_type > SensorParameterSetting_sequence;
  typedef SensorParameterSetting_sequence::iterator SensorParameterSetting_iterator;
  typedef SensorParameterSetting_sequence::const_iterator SensorParameterSetting_const_iterator;
  typedef ::xsd::cxx::tree::traits< SensorParameterSetting_type, char > SensorParameterSetting_traits;

  const SensorParameterSetting_sequence&
  SensorParameterSetting () const;

  SensorParameterSetting_sequence&
  SensorParameterSetting ();

  void
  SensorParameterSetting (const SensorParameterSetting_sequence& s);

  // Constructors.
  //
  SensorStatusType (const SensorID_type&,
                    const ReadCount_type&,
                    const LastReadTime_type&);

  SensorStatusType (::std::auto_ptr< SensorID_type >,
                    const ReadCount_type&,
                    const LastReadTime_type&);

  SensorStatusType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  SensorStatusType (const SensorStatusType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual SensorStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  SensorStatusType&
  operator= (const SensorStatusType& x);

  virtual 
  ~SensorStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< SensorID_type > SensorID_;
  ::xsd::cxx::tree::one< ReadCount_type > ReadCount_;
  ::xsd::cxx::tree::one< LastReadTime_type > LastReadTime_;
  SensorParameterSetting_sequence SensorParameterSetting_;
};

class OnOffSensorStatusType: public ::SensorStatusType
{
  public:
  // On
  //
  typedef ::xml_schema::boolean On_type;
  typedef ::xsd::cxx::tree::traits< On_type, char > On_traits;

  const On_type&
  On () const;

  On_type&
  On ();

  void
  On (const On_type& x);

  // Constructors.
  //
  OnOffSensorStatusType (const ::SensorStatusType&,
                         const On_type&);

  OnOffSensorStatusType (const SensorID_type&,
                         const ReadCount_type&,
                         const LastReadTime_type&,
                         const On_type&);

  OnOffSensorStatusType (::std::auto_ptr< SensorID_type >,
                         const ReadCount_type&,
                         const LastReadTime_type&,
                         const On_type&);

  OnOffSensorStatusType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  OnOffSensorStatusType (const OnOffSensorStatusType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual OnOffSensorStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  OnOffSensorStatusType&
  operator= (const OnOffSensorStatusType& x);

  virtual 
  ~OnOffSensorStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< On_type > On_;
};

class ForceTorqueSensorStatusType: public ::SensorStatusType
{
  public:
  // Fx
  //
  typedef ::xml_schema::double_ Fx_type;
  typedef ::xsd::cxx::tree::traits< Fx_type, char, ::xsd::cxx::tree::schema_type::double_ > Fx_traits;

  const Fx_type&
  Fx () const;

  Fx_type&
  Fx ();

  void
  Fx (const Fx_type& x);

  // Fy
  //
  typedef ::xml_schema::double_ Fy_type;
  typedef ::xsd::cxx::tree::traits< Fy_type, char, ::xsd::cxx::tree::schema_type::double_ > Fy_traits;

  const Fy_type&
  Fy () const;

  Fy_type&
  Fy ();

  void
  Fy (const Fy_type& x);

  // Fz
  //
  typedef ::xml_schema::double_ Fz_type;
  typedef ::xsd::cxx::tree::traits< Fz_type, char, ::xsd::cxx::tree::schema_type::double_ > Fz_traits;

  const Fz_type&
  Fz () const;

  Fz_type&
  Fz ();

  void
  Fz (const Fz_type& x);

  // Tx
  //
  typedef ::xml_schema::double_ Tx_type;
  typedef ::xsd::cxx::tree::traits< Tx_type, char, ::xsd::cxx::tree::schema_type::double_ > Tx_traits;

  const Tx_type&
  Tx () const;

  Tx_type&
  Tx ();

  void
  Tx (const Tx_type& x);

  // Ty
  //
  typedef ::xml_schema::double_ Ty_type;
  typedef ::xsd::cxx::tree::traits< Ty_type, char, ::xsd::cxx::tree::schema_type::double_ > Ty_traits;

  const Ty_type&
  Ty () const;

  Ty_type&
  Ty ();

  void
  Ty (const Ty_type& x);

  // Tz
  //
  typedef ::xml_schema::double_ Tz_type;
  typedef ::xsd::cxx::tree::traits< Tz_type, char, ::xsd::cxx::tree::schema_type::double_ > Tz_traits;

  const Tz_type&
  Tz () const;

  Tz_type&
  Tz ();

  void
  Tz (const Tz_type& x);

  // Constructors.
  //
  ForceTorqueSensorStatusType (const ::SensorStatusType&,
                               const Fx_type&,
                               const Fy_type&,
                               const Fz_type&,
                               const Tx_type&,
                               const Ty_type&,
                               const Tz_type&);

  ForceTorqueSensorStatusType (const SensorID_type&,
                               const ReadCount_type&,
                               const LastReadTime_type&,
                               const Fx_type&,
                               const Fy_type&,
                               const Fz_type&,
                               const Tx_type&,
                               const Ty_type&,
                               const Tz_type&);

  ForceTorqueSensorStatusType (::std::auto_ptr< SensorID_type >,
                               const ReadCount_type&,
                               const LastReadTime_type&,
                               const Fx_type&,
                               const Fy_type&,
                               const Fz_type&,
                               const Tx_type&,
                               const Ty_type&,
                               const Tz_type&);

  ForceTorqueSensorStatusType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  ForceTorqueSensorStatusType (const ForceTorqueSensorStatusType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  virtual ForceTorqueSensorStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ForceTorqueSensorStatusType&
  operator= (const ForceTorqueSensorStatusType& x);

  virtual 
  ~ForceTorqueSensorStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Fx_type > Fx_;
  ::xsd::cxx::tree::one< Fy_type > Fy_;
  ::xsd::cxx::tree::one< Fz_type > Fz_;
  ::xsd::cxx::tree::one< Tx_type > Tx_;
  ::xsd::cxx::tree::one< Ty_type > Ty_;
  ::xsd::cxx::tree::one< Tz_type > Tz_;
};

class ScalarSensorStatusType: public ::SensorStatusType
{
  public:
  // ScalarValue.
  //
  typedef ::xml_schema::double_ ScalarValue__type;
  typedef ::xsd::cxx::tree::traits< ScalarValue__type, char, ::xsd::cxx::tree::schema_type::double_ > ScalarValue__traits;

  const ScalarValue__type&
  ScalarValue_ () const;

  ScalarValue__type&
  ScalarValue_ ();

  void
  ScalarValue_ (const ScalarValue__type& x);

  // Constructors.
  //
  ScalarSensorStatusType (const ::SensorStatusType&,
                          const ScalarValue__type&);

  ScalarSensorStatusType (const SensorID_type&,
                          const ReadCount_type&,
                          const LastReadTime_type&,
                          const ScalarValue__type&);

  ScalarSensorStatusType (::std::auto_ptr< SensorID_type >,
                          const ReadCount_type&,
                          const LastReadTime_type&,
                          const ScalarValue__type&);

  ScalarSensorStatusType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  ScalarSensorStatusType (const ScalarSensorStatusType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual ScalarSensorStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ScalarSensorStatusType&
  operator= (const ScalarSensorStatusType& x);

  virtual 
  ~ScalarSensorStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< ScalarValue__type > ScalarValue__;
};

class CountSensorStatusType: public ::SensorStatusType
{
  public:
  // CountValue.
  //
  typedef ::xml_schema::int_ CountValue__type;
  typedef ::xsd::cxx::tree::traits< CountValue__type, char > CountValue__traits;

  const CountValue__type&
  CountValue_ () const;

  CountValue__type&
  CountValue_ ();

  void
  CountValue_ (const CountValue__type& x);

  // Constructors.
  //
  CountSensorStatusType (const ::SensorStatusType&,
                         const CountValue__type&);

  CountSensorStatusType (const SensorID_type&,
                         const ReadCount_type&,
                         const LastReadTime_type&,
                         const CountValue__type&);

  CountSensorStatusType (::std::auto_ptr< SensorID_type >,
                         const ReadCount_type&,
                         const LastReadTime_type&,
                         const CountValue__type&);

  CountSensorStatusType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  CountSensorStatusType (const CountSensorStatusType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual CountSensorStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CountSensorStatusType&
  operator= (const CountSensorStatusType& x);

  virtual 
  ~CountSensorStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< CountValue__type > CountValue__;
};

class map: public ::xml_schema::type
{
  public:
  // item
  //
  typedef ::MapItemType item_type;
  typedef ::xsd::cxx::tree::sequence< item_type > item_sequence;
  typedef item_sequence::iterator item_iterator;
  typedef item_sequence::const_iterator item_const_iterator;
  typedef ::xsd::cxx::tree::traits< item_type, char > item_traits;

  const item_sequence&
  item () const;

  item_sequence&
  item ();

  void
  item (const item_sequence& s);

  // Constructors.
  //
  map ();

  map (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  map (const map& x,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  virtual map*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  map&
  operator= (const map& x);

  virtual 
  ~map ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  item_sequence item_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& uri,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& uri,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse a URI or a local file.
//

::std::auto_ptr< ::map >
map_ (const ::std::string& uri,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::map >
map_ (const ::std::string& uri,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::map >
map_ (const ::std::string& uri,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::map >
map_ (::std::istream& is,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::map >
map_ (::std::istream& is,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::map >
map_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::map >
map_ (::std::istream& is,
      const ::std::string& id,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::map >
map_ (::std::istream& is,
      const ::std::string& id,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::map >
map_ (::std::istream& is,
      const ::std::string& id,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::map >
map_ (::xercesc::InputSource& is,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::map >
map_ (::xercesc::InputSource& is,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::map >
map_ (::xercesc::InputSource& is,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::map >
map_ (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::map >
map_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

// Serialize to std::ostream.
//

void
CRCLStatus (::std::ostream& os,
            const ::CRCLStatusType& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
CRCLStatus (::std::ostream& os,
            const ::CRCLStatusType& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
CRCLStatus (::std::ostream& os,
            const ::CRCLStatusType& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
CRCLStatus (::xercesc::XMLFormatTarget& ft,
            const ::CRCLStatusType& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
CRCLStatus (::xercesc::XMLFormatTarget& ft,
            const ::CRCLStatusType& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
CRCLStatus (::xercesc::XMLFormatTarget& ft,
            const ::CRCLStatusType& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
CRCLStatus (::xercesc::DOMDocument& d,
            const ::CRCLStatusType& x,
            ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
CRCLStatus (const ::CRCLStatusType& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const CommandStateEnumType&);

void
operator<< (::xercesc::DOMAttr&, const CommandStateEnumType&);

void
operator<< (::xml_schema::list_stream&,
            const CommandStateEnumType&);

void
operator<< (::xercesc::DOMElement&, const CommandStatusType&);

void
operator<< (::xercesc::DOMElement&, const CRCLStatusType&);

void
operator<< (::xercesc::DOMElement&, const GripperStatusType&);

void
operator<< (::xercesc::DOMElement&, const JointStatusesType&);

void
operator<< (::xercesc::DOMElement&, const JointStatusType&);

void
operator<< (::xercesc::DOMElement&, const JointLimitType&);

void
operator<< (::xercesc::DOMElement&, const ParallelGripperStatusType&);

void
operator<< (::xercesc::DOMElement&, const PoseStatusType&);

void
operator<< (::xercesc::DOMElement&, const SettingsStatusType&);

void
operator<< (::xercesc::DOMElement&, const ThreeFingerGripperStatusType&);

void
operator<< (::xercesc::DOMElement&, const VacuumGripperStatusType&);

// Serialize to std::ostream.
//

void
map_ (::std::ostream& os,
      const ::map& x, 
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
map_ (::std::ostream& os,
      const ::map& x, 
      ::xml_schema::error_handler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
map_ (::std::ostream& os,
      const ::map& x, 
      ::xercesc::DOMErrorHandler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
map_ (::xercesc::XMLFormatTarget& ft,
      const ::map& x, 
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
map_ (::xercesc::XMLFormatTarget& ft,
      const ::map& x, 
      ::xml_schema::error_handler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
map_ (::xercesc::XMLFormatTarget& ft,
      const ::map& x, 
      ::xercesc::DOMErrorHandler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
map_ (::xercesc::DOMDocument& d,
      const ::map& x,
      ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
map_ (const ::map& x, 
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const MapType&);

void
operator<< (::xercesc::DOMElement&, const MapItemType&);

void
operator<< (::xercesc::DOMElement&, const ModelsStatusType&);

void
operator<< (::xercesc::DOMElement&, const SensorStatusesType&);

void
operator<< (::xercesc::DOMElement&, const GuardsStatusesType&);

void
operator<< (::xercesc::DOMElement&, const SensorStatusType&);

void
operator<< (::xercesc::DOMElement&, const OnOffSensorStatusType&);

void
operator<< (::xercesc::DOMElement&, const ForceTorqueSensorStatusType&);

void
operator<< (::xercesc::DOMElement&, const ScalarSensorStatusType&);

void
operator<< (::xercesc::DOMElement&, const CountSensorStatusType&);

void
operator<< (::xercesc::DOMElement&, const map&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CRCLSTATUS_HXX
