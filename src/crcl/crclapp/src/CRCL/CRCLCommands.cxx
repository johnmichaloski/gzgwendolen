// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "CRCLCommands.hxx"

// CRCLCommandType
// 

const CRCLCommandType::CommandID_type& CRCLCommandType::
CommandID () const
{
  return this->CommandID_.get ();
}

CRCLCommandType::CommandID_type& CRCLCommandType::
CommandID ()
{
  return this->CommandID_.get ();
}

void CRCLCommandType::
CommandID (const CommandID_type& x)
{
  this->CommandID_.set (x);
}

const CRCLCommandType::Guard_sequence& CRCLCommandType::
Guard () const
{
  return this->Guard_;
}

CRCLCommandType::Guard_sequence& CRCLCommandType::
Guard ()
{
  return this->Guard_;
}

void CRCLCommandType::
Guard (const Guard_sequence& s)
{
  this->Guard_ = s;
}


// MiddleCommandType
// 


// ActuateJointsType
// 

const ActuateJointsType::ActuateJoint_sequence& ActuateJointsType::
ActuateJoint () const
{
  return this->ActuateJoint_;
}

ActuateJointsType::ActuateJoint_sequence& ActuateJointsType::
ActuateJoint ()
{
  return this->ActuateJoint_;
}

void ActuateJointsType::
ActuateJoint (const ActuateJoint_sequence& s)
{
  this->ActuateJoint_ = s;
}

const ActuateJointsType::JointTolerances_optional& ActuateJointsType::
JointTolerances () const
{
  return this->JointTolerances_;
}

ActuateJointsType::JointTolerances_optional& ActuateJointsType::
JointTolerances ()
{
  return this->JointTolerances_;
}

void ActuateJointsType::
JointTolerances (const JointTolerances_type& x)
{
  this->JointTolerances_.set (x);
}

void ActuateJointsType::
JointTolerances (const JointTolerances_optional& x)
{
  this->JointTolerances_ = x;
}

void ActuateJointsType::
JointTolerances (::std::auto_ptr< JointTolerances_type > x)
{
  this->JointTolerances_.set (x);
}


// ActuateJointType
// 

const ActuateJointType::JointNumber_type& ActuateJointType::
JointNumber () const
{
  return this->JointNumber_.get ();
}

ActuateJointType::JointNumber_type& ActuateJointType::
JointNumber ()
{
  return this->JointNumber_.get ();
}

void ActuateJointType::
JointNumber (const JointNumber_type& x)
{
  this->JointNumber_.set (x);
}

const ActuateJointType::JointPosition_type& ActuateJointType::
JointPosition () const
{
  return this->JointPosition_.get ();
}

ActuateJointType::JointPosition_type& ActuateJointType::
JointPosition ()
{
  return this->JointPosition_.get ();
}

void ActuateJointType::
JointPosition (const JointPosition_type& x)
{
  this->JointPosition_.set (x);
}

const ActuateJointType::JointDetails_type& ActuateJointType::
JointDetails () const
{
  return this->JointDetails_.get ();
}

ActuateJointType::JointDetails_type& ActuateJointType::
JointDetails ()
{
  return this->JointDetails_.get ();
}

void ActuateJointType::
JointDetails (const JointDetails_type& x)
{
  this->JointDetails_.set (x);
}

void ActuateJointType::
JointDetails (::std::auto_ptr< JointDetails_type > x)
{
  this->JointDetails_.set (x);
}


// CloseToolChangerType
// 


// ConfigureJointReportsType
// 

const ConfigureJointReportsType::ResetAll_type& ConfigureJointReportsType::
ResetAll () const
{
  return this->ResetAll_.get ();
}

ConfigureJointReportsType::ResetAll_type& ConfigureJointReportsType::
ResetAll ()
{
  return this->ResetAll_.get ();
}

void ConfigureJointReportsType::
ResetAll (const ResetAll_type& x)
{
  this->ResetAll_.set (x);
}

const ConfigureJointReportsType::ConfigureJointReport_sequence& ConfigureJointReportsType::
ConfigureJointReport () const
{
  return this->ConfigureJointReport_;
}

ConfigureJointReportsType::ConfigureJointReport_sequence& ConfigureJointReportsType::
ConfigureJointReport ()
{
  return this->ConfigureJointReport_;
}

void ConfigureJointReportsType::
ConfigureJointReport (const ConfigureJointReport_sequence& s)
{
  this->ConfigureJointReport_ = s;
}


// ConfigureJointReportType
// 

const ConfigureJointReportType::JointNumber_type& ConfigureJointReportType::
JointNumber () const
{
  return this->JointNumber_.get ();
}

ConfigureJointReportType::JointNumber_type& ConfigureJointReportType::
JointNumber ()
{
  return this->JointNumber_.get ();
}

void ConfigureJointReportType::
JointNumber (const JointNumber_type& x)
{
  this->JointNumber_.set (x);
}

const ConfigureJointReportType::ReportPosition_type& ConfigureJointReportType::
ReportPosition () const
{
  return this->ReportPosition_.get ();
}

ConfigureJointReportType::ReportPosition_type& ConfigureJointReportType::
ReportPosition ()
{
  return this->ReportPosition_.get ();
}

void ConfigureJointReportType::
ReportPosition (const ReportPosition_type& x)
{
  this->ReportPosition_.set (x);
}

const ConfigureJointReportType::ReportTorqueOrForce_type& ConfigureJointReportType::
ReportTorqueOrForce () const
{
  return this->ReportTorqueOrForce_.get ();
}

ConfigureJointReportType::ReportTorqueOrForce_type& ConfigureJointReportType::
ReportTorqueOrForce ()
{
  return this->ReportTorqueOrForce_.get ();
}

void ConfigureJointReportType::
ReportTorqueOrForce (const ReportTorqueOrForce_type& x)
{
  this->ReportTorqueOrForce_.set (x);
}

const ConfigureJointReportType::ReportVelocity_type& ConfigureJointReportType::
ReportVelocity () const
{
  return this->ReportVelocity_.get ();
}

ConfigureJointReportType::ReportVelocity_type& ConfigureJointReportType::
ReportVelocity ()
{
  return this->ReportVelocity_.get ();
}

void ConfigureJointReportType::
ReportVelocity (const ReportVelocity_type& x)
{
  this->ReportVelocity_.set (x);
}


// DwellType
// 

const DwellType::DwellTime_type& DwellType::
DwellTime () const
{
  return this->DwellTime_.get ();
}

DwellType::DwellTime_type& DwellType::
DwellTime ()
{
  return this->DwellTime_.get ();
}

void DwellType::
DwellTime (const DwellTime_type& x)
{
  this->DwellTime_.set (x);
}


// EndCanonType
// 


// GetStatusType
// 


// InitCanonType
// 


// JointDetailsType
// 


// JointForceTorqueType
// 

const JointForceTorqueType::Setting_optional& JointForceTorqueType::
Setting () const
{
  return this->Setting_;
}

JointForceTorqueType::Setting_optional& JointForceTorqueType::
Setting ()
{
  return this->Setting_;
}

void JointForceTorqueType::
Setting (const Setting_type& x)
{
  this->Setting_.set (x);
}

void JointForceTorqueType::
Setting (const Setting_optional& x)
{
  this->Setting_ = x;
}

const JointForceTorqueType::ChangeRate_optional& JointForceTorqueType::
ChangeRate () const
{
  return this->ChangeRate_;
}

JointForceTorqueType::ChangeRate_optional& JointForceTorqueType::
ChangeRate ()
{
  return this->ChangeRate_;
}

void JointForceTorqueType::
ChangeRate (const ChangeRate_type& x)
{
  this->ChangeRate_.set (x);
}

void JointForceTorqueType::
ChangeRate (const ChangeRate_optional& x)
{
  this->ChangeRate_ = x;
}


// JointSpeedAccelType
// 

const JointSpeedAccelType::JointSpeed_optional& JointSpeedAccelType::
JointSpeed () const
{
  return this->JointSpeed_;
}

JointSpeedAccelType::JointSpeed_optional& JointSpeedAccelType::
JointSpeed ()
{
  return this->JointSpeed_;
}

void JointSpeedAccelType::
JointSpeed (const JointSpeed_type& x)
{
  this->JointSpeed_.set (x);
}

void JointSpeedAccelType::
JointSpeed (const JointSpeed_optional& x)
{
  this->JointSpeed_ = x;
}

const JointSpeedAccelType::JointAccel_optional& JointSpeedAccelType::
JointAccel () const
{
  return this->JointAccel_;
}

JointSpeedAccelType::JointAccel_optional& JointSpeedAccelType::
JointAccel ()
{
  return this->JointAccel_;
}

void JointSpeedAccelType::
JointAccel (const JointAccel_type& x)
{
  this->JointAccel_.set (x);
}

void JointSpeedAccelType::
JointAccel (const JointAccel_optional& x)
{
  this->JointAccel_ = x;
}


// MessageType
// 

const MessageType::Message_type& MessageType::
Message () const
{
  return this->Message_.get ();
}

MessageType::Message_type& MessageType::
Message ()
{
  return this->Message_.get ();
}

void MessageType::
Message (const Message_type& x)
{
  this->Message_.set (x);
}

void MessageType::
Message (::std::auto_ptr< Message_type > x)
{
  this->Message_.set (x);
}


// MoveScrewType
// 

const MoveScrewType::StartPosition_optional& MoveScrewType::
StartPosition () const
{
  return this->StartPosition_;
}

MoveScrewType::StartPosition_optional& MoveScrewType::
StartPosition ()
{
  return this->StartPosition_;
}

void MoveScrewType::
StartPosition (const StartPosition_type& x)
{
  this->StartPosition_.set (x);
}

void MoveScrewType::
StartPosition (const StartPosition_optional& x)
{
  this->StartPosition_ = x;
}

void MoveScrewType::
StartPosition (::std::auto_ptr< StartPosition_type > x)
{
  this->StartPosition_.set (x);
}

const MoveScrewType::AxisPoint_optional& MoveScrewType::
AxisPoint () const
{
  return this->AxisPoint_;
}

MoveScrewType::AxisPoint_optional& MoveScrewType::
AxisPoint ()
{
  return this->AxisPoint_;
}

void MoveScrewType::
AxisPoint (const AxisPoint_type& x)
{
  this->AxisPoint_.set (x);
}

void MoveScrewType::
AxisPoint (const AxisPoint_optional& x)
{
  this->AxisPoint_ = x;
}

void MoveScrewType::
AxisPoint (::std::auto_ptr< AxisPoint_type > x)
{
  this->AxisPoint_.set (x);
}

const MoveScrewType::AxialDistanceFree_optional& MoveScrewType::
AxialDistanceFree () const
{
  return this->AxialDistanceFree_;
}

MoveScrewType::AxialDistanceFree_optional& MoveScrewType::
AxialDistanceFree ()
{
  return this->AxialDistanceFree_;
}

void MoveScrewType::
AxialDistanceFree (const AxialDistanceFree_type& x)
{
  this->AxialDistanceFree_.set (x);
}

void MoveScrewType::
AxialDistanceFree (const AxialDistanceFree_optional& x)
{
  this->AxialDistanceFree_ = x;
}

const MoveScrewType::AxialDistanceScrew_type& MoveScrewType::
AxialDistanceScrew () const
{
  return this->AxialDistanceScrew_.get ();
}

MoveScrewType::AxialDistanceScrew_type& MoveScrewType::
AxialDistanceScrew ()
{
  return this->AxialDistanceScrew_.get ();
}

void MoveScrewType::
AxialDistanceScrew (const AxialDistanceScrew_type& x)
{
  this->AxialDistanceScrew_.set (x);
}

const MoveScrewType::Turn_type& MoveScrewType::
Turn () const
{
  return this->Turn_.get ();
}

MoveScrewType::Turn_type& MoveScrewType::
Turn ()
{
  return this->Turn_.get ();
}

void MoveScrewType::
Turn (const Turn_type& x)
{
  this->Turn_.set (x);
}


// MoveThroughToType
// 

const MoveThroughToType::MoveStraight_type& MoveThroughToType::
MoveStraight () const
{
  return this->MoveStraight_.get ();
}

MoveThroughToType::MoveStraight_type& MoveThroughToType::
MoveStraight ()
{
  return this->MoveStraight_.get ();
}

void MoveThroughToType::
MoveStraight (const MoveStraight_type& x)
{
  this->MoveStraight_.set (x);
}

const MoveThroughToType::Waypoint_sequence& MoveThroughToType::
Waypoint () const
{
  return this->Waypoint_;
}

MoveThroughToType::Waypoint_sequence& MoveThroughToType::
Waypoint ()
{
  return this->Waypoint_;
}

void MoveThroughToType::
Waypoint (const Waypoint_sequence& s)
{
  this->Waypoint_ = s;
}

const MoveThroughToType::NumPositions_type& MoveThroughToType::
NumPositions () const
{
  return this->NumPositions_.get ();
}

MoveThroughToType::NumPositions_type& MoveThroughToType::
NumPositions ()
{
  return this->NumPositions_.get ();
}

void MoveThroughToType::
NumPositions (const NumPositions_type& x)
{
  this->NumPositions_.set (x);
}


// MoveToType
// 

const MoveToType::MoveStraight_type& MoveToType::
MoveStraight () const
{
  return this->MoveStraight_.get ();
}

MoveToType::MoveStraight_type& MoveToType::
MoveStraight ()
{
  return this->MoveStraight_.get ();
}

void MoveToType::
MoveStraight (const MoveStraight_type& x)
{
  this->MoveStraight_.set (x);
}

const MoveToType::EndPosition_type& MoveToType::
EndPosition () const
{
  return this->EndPosition_.get ();
}

MoveToType::EndPosition_type& MoveToType::
EndPosition ()
{
  return this->EndPosition_.get ();
}

void MoveToType::
EndPosition (const EndPosition_type& x)
{
  this->EndPosition_.set (x);
}

void MoveToType::
EndPosition (::std::auto_ptr< EndPosition_type > x)
{
  this->EndPosition_.set (x);
}


// OpenToolChangerType
// 


// RunProgramType
// 

const RunProgramType::ProgramText_type& RunProgramType::
ProgramText () const
{
  return this->ProgramText_.get ();
}

RunProgramType::ProgramText_type& RunProgramType::
ProgramText ()
{
  return this->ProgramText_.get ();
}

void RunProgramType::
ProgramText (const ProgramText_type& x)
{
  this->ProgramText_.set (x);
}

void RunProgramType::
ProgramText (::std::auto_ptr< ProgramText_type > x)
{
  this->ProgramText_.set (x);
}


// SetAngleUnitsType
// 

const SetAngleUnitsType::UnitName_type& SetAngleUnitsType::
UnitName () const
{
  return this->UnitName_.get ();
}

SetAngleUnitsType::UnitName_type& SetAngleUnitsType::
UnitName ()
{
  return this->UnitName_.get ();
}

void SetAngleUnitsType::
UnitName (const UnitName_type& x)
{
  this->UnitName_.set (x);
}

void SetAngleUnitsType::
UnitName (::std::auto_ptr< UnitName_type > x)
{
  this->UnitName_.set (x);
}


// SetEndEffectorParametersType
// 

const SetEndEffectorParametersType::ParameterSetting_sequence& SetEndEffectorParametersType::
ParameterSetting () const
{
  return this->ParameterSetting_;
}

SetEndEffectorParametersType::ParameterSetting_sequence& SetEndEffectorParametersType::
ParameterSetting ()
{
  return this->ParameterSetting_;
}

void SetEndEffectorParametersType::
ParameterSetting (const ParameterSetting_sequence& s)
{
  this->ParameterSetting_ = s;
}


// SetEndEffectorType
// 

const SetEndEffectorType::Setting_type& SetEndEffectorType::
Setting () const
{
  return this->Setting_.get ();
}

SetEndEffectorType::Setting_type& SetEndEffectorType::
Setting ()
{
  return this->Setting_.get ();
}

void SetEndEffectorType::
Setting (const Setting_type& x)
{
  this->Setting_.set (x);
}

void SetEndEffectorType::
Setting (::std::auto_ptr< Setting_type > x)
{
  this->Setting_.set (x);
}


// SetEndPoseToleranceType
// 

const SetEndPoseToleranceType::Tolerance_type& SetEndPoseToleranceType::
Tolerance () const
{
  return this->Tolerance_.get ();
}

SetEndPoseToleranceType::Tolerance_type& SetEndPoseToleranceType::
Tolerance ()
{
  return this->Tolerance_.get ();
}

void SetEndPoseToleranceType::
Tolerance (const Tolerance_type& x)
{
  this->Tolerance_.set (x);
}

void SetEndPoseToleranceType::
Tolerance (::std::auto_ptr< Tolerance_type > x)
{
  this->Tolerance_.set (x);
}


// SetDefaultJointPositonsTolerancesType
// 

const SetDefaultJointPositonsTolerancesType::JointTolerances_type& SetDefaultJointPositonsTolerancesType::
JointTolerances () const
{
  return this->JointTolerances_.get ();
}

SetDefaultJointPositonsTolerancesType::JointTolerances_type& SetDefaultJointPositonsTolerancesType::
JointTolerances ()
{
  return this->JointTolerances_.get ();
}

void SetDefaultJointPositonsTolerancesType::
JointTolerances (const JointTolerances_type& x)
{
  this->JointTolerances_.set (x);
}

void SetDefaultJointPositonsTolerancesType::
JointTolerances (::std::auto_ptr< JointTolerances_type > x)
{
  this->JointTolerances_.set (x);
}


// SetForceUnitsType
// 

const SetForceUnitsType::UnitName_type& SetForceUnitsType::
UnitName () const
{
  return this->UnitName_.get ();
}

SetForceUnitsType::UnitName_type& SetForceUnitsType::
UnitName ()
{
  return this->UnitName_.get ();
}

void SetForceUnitsType::
UnitName (const UnitName_type& x)
{
  this->UnitName_.set (x);
}

void SetForceUnitsType::
UnitName (::std::auto_ptr< UnitName_type > x)
{
  this->UnitName_.set (x);
}


// SetIntermediatePoseToleranceType
// 

const SetIntermediatePoseToleranceType::Tolerance_type& SetIntermediatePoseToleranceType::
Tolerance () const
{
  return this->Tolerance_.get ();
}

SetIntermediatePoseToleranceType::Tolerance_type& SetIntermediatePoseToleranceType::
Tolerance ()
{
  return this->Tolerance_.get ();
}

void SetIntermediatePoseToleranceType::
Tolerance (const Tolerance_type& x)
{
  this->Tolerance_.set (x);
}

void SetIntermediatePoseToleranceType::
Tolerance (::std::auto_ptr< Tolerance_type > x)
{
  this->Tolerance_.set (x);
}


// SetLengthUnitsType
// 

const SetLengthUnitsType::UnitName_type& SetLengthUnitsType::
UnitName () const
{
  return this->UnitName_.get ();
}

SetLengthUnitsType::UnitName_type& SetLengthUnitsType::
UnitName ()
{
  return this->UnitName_.get ();
}

void SetLengthUnitsType::
UnitName (const UnitName_type& x)
{
  this->UnitName_.set (x);
}

void SetLengthUnitsType::
UnitName (::std::auto_ptr< UnitName_type > x)
{
  this->UnitName_.set (x);
}


// SetMotionCoordinationType
// 

const SetMotionCoordinationType::Coordinated_type& SetMotionCoordinationType::
Coordinated () const
{
  return this->Coordinated_.get ();
}

SetMotionCoordinationType::Coordinated_type& SetMotionCoordinationType::
Coordinated ()
{
  return this->Coordinated_.get ();
}

void SetMotionCoordinationType::
Coordinated (const Coordinated_type& x)
{
  this->Coordinated_.set (x);
}


// SetRobotParametersType
// 

const SetRobotParametersType::ParameterSetting_sequence& SetRobotParametersType::
ParameterSetting () const
{
  return this->ParameterSetting_;
}

SetRobotParametersType::ParameterSetting_sequence& SetRobotParametersType::
ParameterSetting ()
{
  return this->ParameterSetting_;
}

void SetRobotParametersType::
ParameterSetting (const ParameterSetting_sequence& s)
{
  this->ParameterSetting_ = s;
}


// SetRotAccelType
// 

const SetRotAccelType::RotAccel_type& SetRotAccelType::
RotAccel () const
{
  return this->RotAccel_.get ();
}

SetRotAccelType::RotAccel_type& SetRotAccelType::
RotAccel ()
{
  return this->RotAccel_.get ();
}

void SetRotAccelType::
RotAccel (const RotAccel_type& x)
{
  this->RotAccel_.set (x);
}

void SetRotAccelType::
RotAccel (::std::auto_ptr< RotAccel_type > x)
{
  this->RotAccel_.set (x);
}


// SetRotSpeedType
// 

const SetRotSpeedType::RotSpeed_type& SetRotSpeedType::
RotSpeed () const
{
  return this->RotSpeed_.get ();
}

SetRotSpeedType::RotSpeed_type& SetRotSpeedType::
RotSpeed ()
{
  return this->RotSpeed_.get ();
}

void SetRotSpeedType::
RotSpeed (const RotSpeed_type& x)
{
  this->RotSpeed_.set (x);
}

void SetRotSpeedType::
RotSpeed (::std::auto_ptr< RotSpeed_type > x)
{
  this->RotSpeed_.set (x);
}


// SetTorqueUnitsType
// 

const SetTorqueUnitsType::UnitName_type& SetTorqueUnitsType::
UnitName () const
{
  return this->UnitName_.get ();
}

SetTorqueUnitsType::UnitName_type& SetTorqueUnitsType::
UnitName ()
{
  return this->UnitName_.get ();
}

void SetTorqueUnitsType::
UnitName (const UnitName_type& x)
{
  this->UnitName_.set (x);
}

void SetTorqueUnitsType::
UnitName (::std::auto_ptr< UnitName_type > x)
{
  this->UnitName_.set (x);
}


// SetTransAccelType
// 

const SetTransAccelType::TransAccel_type& SetTransAccelType::
TransAccel () const
{
  return this->TransAccel_.get ();
}

SetTransAccelType::TransAccel_type& SetTransAccelType::
TransAccel ()
{
  return this->TransAccel_.get ();
}

void SetTransAccelType::
TransAccel (const TransAccel_type& x)
{
  this->TransAccel_.set (x);
}

void SetTransAccelType::
TransAccel (::std::auto_ptr< TransAccel_type > x)
{
  this->TransAccel_.set (x);
}


// SetTransSpeedType
// 

const SetTransSpeedType::TransSpeed_type& SetTransSpeedType::
TransSpeed () const
{
  return this->TransSpeed_.get ();
}

SetTransSpeedType::TransSpeed_type& SetTransSpeedType::
TransSpeed ()
{
  return this->TransSpeed_.get ();
}

void SetTransSpeedType::
TransSpeed (const TransSpeed_type& x)
{
  this->TransSpeed_.set (x);
}

void SetTransSpeedType::
TransSpeed (::std::auto_ptr< TransSpeed_type > x)
{
  this->TransSpeed_.set (x);
}


// StopConditionEnumType
// 

StopConditionEnumType::
StopConditionEnumType (value v)
: ::xml_schema::token (_xsd_StopConditionEnumType_literals_[v])
{
}

StopConditionEnumType::
StopConditionEnumType (const char* v)
: ::xml_schema::token (v)
{
}

StopConditionEnumType::
StopConditionEnumType (const ::std::string& v)
: ::xml_schema::token (v)
{
}

StopConditionEnumType::
StopConditionEnumType (const ::xml_schema::token& v)
: ::xml_schema::token (v)
{
}

StopConditionEnumType::
StopConditionEnumType (const StopConditionEnumType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::token (v, f, c)
{
}

StopConditionEnumType& StopConditionEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::token& > (*this) = 
  ::xml_schema::token (_xsd_StopConditionEnumType_literals_[v]);

  return *this;
}


// StopMotionType
// 

const StopMotionType::StopCondition_type& StopMotionType::
StopCondition () const
{
  return this->StopCondition_.get ();
}

StopMotionType::StopCondition_type& StopMotionType::
StopCondition ()
{
  return this->StopCondition_.get ();
}

void StopMotionType::
StopCondition (const StopCondition_type& x)
{
  this->StopCondition_.set (x);
}

void StopMotionType::
StopCondition (::std::auto_ptr< StopCondition_type > x)
{
  this->StopCondition_.set (x);
}


// ConfigureStatusReportType
// 

const ConfigureStatusReportType::ReportJointStatuses_type& ConfigureStatusReportType::
ReportJointStatuses () const
{
  return this->ReportJointStatuses_.get ();
}

ConfigureStatusReportType::ReportJointStatuses_type& ConfigureStatusReportType::
ReportJointStatuses ()
{
  return this->ReportJointStatuses_.get ();
}

void ConfigureStatusReportType::
ReportJointStatuses (const ReportJointStatuses_type& x)
{
  this->ReportJointStatuses_.set (x);
}

const ConfigureStatusReportType::ReportPoseStatus_type& ConfigureStatusReportType::
ReportPoseStatus () const
{
  return this->ReportPoseStatus_.get ();
}

ConfigureStatusReportType::ReportPoseStatus_type& ConfigureStatusReportType::
ReportPoseStatus ()
{
  return this->ReportPoseStatus_.get ();
}

void ConfigureStatusReportType::
ReportPoseStatus (const ReportPoseStatus_type& x)
{
  this->ReportPoseStatus_.set (x);
}

const ConfigureStatusReportType::ReportGripperStatus_type& ConfigureStatusReportType::
ReportGripperStatus () const
{
  return this->ReportGripperStatus_.get ();
}

ConfigureStatusReportType::ReportGripperStatus_type& ConfigureStatusReportType::
ReportGripperStatus ()
{
  return this->ReportGripperStatus_.get ();
}

void ConfigureStatusReportType::
ReportGripperStatus (const ReportGripperStatus_type& x)
{
  this->ReportGripperStatus_.set (x);
}

const ConfigureStatusReportType::ReportSettingsStatus_type& ConfigureStatusReportType::
ReportSettingsStatus () const
{
  return this->ReportSettingsStatus_.get ();
}

ConfigureStatusReportType::ReportSettingsStatus_type& ConfigureStatusReportType::
ReportSettingsStatus ()
{
  return this->ReportSettingsStatus_.get ();
}

void ConfigureStatusReportType::
ReportSettingsStatus (const ReportSettingsStatus_type& x)
{
  this->ReportSettingsStatus_.set (x);
}

const ConfigureStatusReportType::ReportSensorsStatus_type& ConfigureStatusReportType::
ReportSensorsStatus () const
{
  return this->ReportSensorsStatus_.get ();
}

ConfigureStatusReportType::ReportSensorsStatus_type& ConfigureStatusReportType::
ReportSensorsStatus ()
{
  return this->ReportSensorsStatus_.get ();
}

void ConfigureStatusReportType::
ReportSensorsStatus (const ReportSensorsStatus_type& x)
{
  this->ReportSensorsStatus_.set (x);
}

const ConfigureStatusReportType::ReportGuardsStatus_type& ConfigureStatusReportType::
ReportGuardsStatus () const
{
  return this->ReportGuardsStatus_.get ();
}

ConfigureStatusReportType::ReportGuardsStatus_type& ConfigureStatusReportType::
ReportGuardsStatus ()
{
  return this->ReportGuardsStatus_.get ();
}

void ConfigureStatusReportType::
ReportGuardsStatus (const ReportGuardsStatus_type& x)
{
  this->ReportGuardsStatus_.set (x);
}

const ConfigureStatusReportType::ReportModelStatus_type& ConfigureStatusReportType::
ReportModelStatus () const
{
  return this->ReportModelStatus_.get ();
}

ConfigureStatusReportType::ReportModelStatus_type& ConfigureStatusReportType::
ReportModelStatus ()
{
  return this->ReportModelStatus_.get ();
}

void ConfigureStatusReportType::
ReportModelStatus (const ReportModelStatus_type& x)
{
  this->ReportModelStatus_.set (x);
}


// EnableSensorType
// 

const EnableSensorType::SensorID_type& EnableSensorType::
SensorID () const
{
  return this->SensorID_.get ();
}

EnableSensorType::SensorID_type& EnableSensorType::
SensorID ()
{
  return this->SensorID_.get ();
}

void EnableSensorType::
SensorID (const SensorID_type& x)
{
  this->SensorID_.set (x);
}

void EnableSensorType::
SensorID (::std::auto_ptr< SensorID_type > x)
{
  this->SensorID_.set (x);
}

const EnableSensorType::SensorOption_sequence& EnableSensorType::
SensorOption () const
{
  return this->SensorOption_;
}

EnableSensorType::SensorOption_sequence& EnableSensorType::
SensorOption ()
{
  return this->SensorOption_;
}

void EnableSensorType::
SensorOption (const SensorOption_sequence& s)
{
  this->SensorOption_ = s;
}


// DisableSensorType
// 

const DisableSensorType::SensorID_type& DisableSensorType::
SensorID () const
{
  return this->SensorID_.get ();
}

DisableSensorType::SensorID_type& DisableSensorType::
SensorID ()
{
  return this->SensorID_.get ();
}

void DisableSensorType::
SensorID (const SensorID_type& x)
{
  this->SensorID_.set (x);
}

void DisableSensorType::
SensorID (::std::auto_ptr< SensorID_type > x)
{
  this->SensorID_.set (x);
}


// EnableGripperType
// 

const EnableGripperType::GripperName_type& EnableGripperType::
GripperName () const
{
  return this->GripperName_.get ();
}

EnableGripperType::GripperName_type& EnableGripperType::
GripperName ()
{
  return this->GripperName_.get ();
}

void EnableGripperType::
GripperName (const GripperName_type& x)
{
  this->GripperName_.set (x);
}

void EnableGripperType::
GripperName (::std::auto_ptr< GripperName_type > x)
{
  this->GripperName_.set (x);
}

const EnableGripperType::GripperOption_sequence& EnableGripperType::
GripperOption () const
{
  return this->GripperOption_;
}

EnableGripperType::GripperOption_sequence& EnableGripperType::
GripperOption ()
{
  return this->GripperOption_;
}

void EnableGripperType::
GripperOption (const GripperOption_sequence& s)
{
  this->GripperOption_ = s;
}


// DisableGripperType
// 

const DisableGripperType::GripperName_type& DisableGripperType::
GripperName () const
{
  return this->GripperName_.get ();
}

DisableGripperType::GripperName_type& DisableGripperType::
GripperName ()
{
  return this->GripperName_.get ();
}

void DisableGripperType::
GripperName (const GripperName_type& x)
{
  this->GripperName_.set (x);
}

void DisableGripperType::
GripperName (::std::auto_ptr< GripperName_type > x)
{
  this->GripperName_.set (x);
}


// EnableRobotParameterStatusType
// 

const EnableRobotParameterStatusType::RobotParameterName_type& EnableRobotParameterStatusType::
RobotParameterName () const
{
  return this->RobotParameterName_.get ();
}

EnableRobotParameterStatusType::RobotParameterName_type& EnableRobotParameterStatusType::
RobotParameterName ()
{
  return this->RobotParameterName_.get ();
}

void EnableRobotParameterStatusType::
RobotParameterName (const RobotParameterName_type& x)
{
  this->RobotParameterName_.set (x);
}

void EnableRobotParameterStatusType::
RobotParameterName (::std::auto_ptr< RobotParameterName_type > x)
{
  this->RobotParameterName_.set (x);
}


// DisableRobotParameterStatusType
// 

const DisableRobotParameterStatusType::RobotParameterName_type& DisableRobotParameterStatusType::
RobotParameterName () const
{
  return this->RobotParameterName_.get ();
}

DisableRobotParameterStatusType::RobotParameterName_type& DisableRobotParameterStatusType::
RobotParameterName ()
{
  return this->RobotParameterName_.get ();
}

void DisableRobotParameterStatusType::
RobotParameterName (const RobotParameterName_type& x)
{
  this->RobotParameterName_.set (x);
}

void DisableRobotParameterStatusType::
RobotParameterName (::std::auto_ptr< RobotParameterName_type > x)
{
  this->RobotParameterName_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

// CRCLCommandType
//

CRCLCommandType::
CRCLCommandType (const CommandID_type& CommandID)
: ::DataThingType (),
  CommandID_ (CommandID, this),
  Guard_ (this)
{
}

CRCLCommandType::
CRCLCommandType (const CRCLCommandType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  CommandID_ (x.CommandID_, f, this),
  Guard_ (x.Guard_, f, this)
{
}

CRCLCommandType::
CRCLCommandType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  CommandID_ (this),
  Guard_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CRCLCommandType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CommandID
    //
    if (n.name () == "CommandID" && n.namespace_ ().empty ())
    {
      if (!CommandID_.present ())
      {
        this->CommandID_.set (CommandID_traits::create (i, f, this));
        continue;
      }
    }

    // Guard
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Guard",
          "",
          &::xsd::cxx::tree::factory_impl< Guard_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Guard_type > r (
          dynamic_cast< Guard_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Guard_.push_back (r);
        continue;
      }
    }

    break;
  }

  if (!CommandID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CommandID",
      "");
  }
}

CRCLCommandType* CRCLCommandType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CRCLCommandType (*this, f, c);
}

CRCLCommandType& CRCLCommandType::
operator= (const CRCLCommandType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->CommandID_ = x.CommandID_;
    this->Guard_ = x.Guard_;
  }

  return *this;
}

CRCLCommandType::
~CRCLCommandType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CRCLCommandType >
_xsd_CRCLCommandType_type_factory_init (
  "CRCLCommandType",
  "");

// MiddleCommandType
//

MiddleCommandType::
MiddleCommandType (const ::CRCLCommandType& _xsd_CRCLCommandType_base)
: ::CRCLCommandType (_xsd_CRCLCommandType_base)
{
}

MiddleCommandType::
MiddleCommandType (const CommandID_type& CommandID)
: ::CRCLCommandType (CommandID)
{
}

MiddleCommandType::
MiddleCommandType (const MiddleCommandType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::CRCLCommandType (x, f, c)
{
}

MiddleCommandType::
MiddleCommandType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::CRCLCommandType (e, f, c)
{
}

MiddleCommandType* MiddleCommandType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MiddleCommandType (*this, f, c);
}

MiddleCommandType::
~MiddleCommandType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, MiddleCommandType >
_xsd_MiddleCommandType_type_factory_init (
  "MiddleCommandType",
  "");

// ActuateJointsType
//

ActuateJointsType::
ActuateJointsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ActuateJoint_ (this),
  JointTolerances_ (this)
{
}

ActuateJointsType::
ActuateJointsType (const CommandID_type& CommandID)
: ::MiddleCommandType (CommandID),
  ActuateJoint_ (this),
  JointTolerances_ (this)
{
}

ActuateJointsType::
ActuateJointsType (const ActuateJointsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  ActuateJoint_ (x.ActuateJoint_, f, this),
  JointTolerances_ (x.JointTolerances_, f, this)
{
}

ActuateJointsType::
ActuateJointsType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  ActuateJoint_ (this),
  JointTolerances_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ActuateJointsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ActuateJoint
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ActuateJoint",
          "",
          &::xsd::cxx::tree::factory_impl< ActuateJoint_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ActuateJoint_type > r (
          dynamic_cast< ActuateJoint_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->ActuateJoint_.push_back (r);
        continue;
      }
    }

    // JointTolerances
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointTolerances",
          "",
          &::xsd::cxx::tree::factory_impl< JointTolerances_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->JointTolerances_)
        {
          ::std::auto_ptr< JointTolerances_type > r (
            dynamic_cast< JointTolerances_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->JointTolerances_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

ActuateJointsType* ActuateJointsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ActuateJointsType (*this, f, c);
}

ActuateJointsType& ActuateJointsType::
operator= (const ActuateJointsType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->ActuateJoint_ = x.ActuateJoint_;
    this->JointTolerances_ = x.JointTolerances_;
  }

  return *this;
}

ActuateJointsType::
~ActuateJointsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ActuateJointsType >
_xsd_ActuateJointsType_type_factory_init (
  "ActuateJointsType",
  "");

// ActuateJointType
//

ActuateJointType::
ActuateJointType (const JointNumber_type& JointNumber,
                  const JointPosition_type& JointPosition,
                  const JointDetails_type& JointDetails)
: ::DataThingType (),
  JointNumber_ (JointNumber, this),
  JointPosition_ (JointPosition, this),
  JointDetails_ (JointDetails, this)
{
}

ActuateJointType::
ActuateJointType (const JointNumber_type& JointNumber,
                  const JointPosition_type& JointPosition,
                  ::std::auto_ptr< JointDetails_type > JointDetails)
: ::DataThingType (),
  JointNumber_ (JointNumber, this),
  JointPosition_ (JointPosition, this),
  JointDetails_ (JointDetails, this)
{
}

ActuateJointType::
ActuateJointType (const ActuateJointType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  JointNumber_ (x.JointNumber_, f, this),
  JointPosition_ (x.JointPosition_, f, this),
  JointDetails_ (x.JointDetails_, f, this)
{
}

ActuateJointType::
ActuateJointType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  JointNumber_ (this),
  JointPosition_ (this),
  JointDetails_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ActuateJointType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointNumber
    //
    if (n.name () == "JointNumber" && n.namespace_ ().empty ())
    {
      if (!JointNumber_.present ())
      {
        this->JointNumber_.set (JointNumber_traits::create (i, f, this));
        continue;
      }
    }

    // JointPosition
    //
    if (n.name () == "JointPosition" && n.namespace_ ().empty ())
    {
      if (!JointPosition_.present ())
      {
        this->JointPosition_.set (JointPosition_traits::create (i, f, this));
        continue;
      }
    }

    // JointDetails
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointDetails",
          "",
          &::xsd::cxx::tree::factory_impl< JointDetails_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!JointDetails_.present ())
        {
          ::std::auto_ptr< JointDetails_type > r (
            dynamic_cast< JointDetails_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->JointDetails_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!JointNumber_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointNumber",
      "");
  }

  if (!JointPosition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointPosition",
      "");
  }

  if (!JointDetails_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointDetails",
      "");
  }
}

ActuateJointType* ActuateJointType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ActuateJointType (*this, f, c);
}

ActuateJointType& ActuateJointType::
operator= (const ActuateJointType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->JointNumber_ = x.JointNumber_;
    this->JointPosition_ = x.JointPosition_;
    this->JointDetails_ = x.JointDetails_;
  }

  return *this;
}

ActuateJointType::
~ActuateJointType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ActuateJointType >
_xsd_ActuateJointType_type_factory_init (
  "ActuateJointType",
  "");

// CloseToolChangerType
//

CloseToolChangerType::
CloseToolChangerType (const ::MiddleCommandType& _xsd_MiddleCommandType_base)
: ::MiddleCommandType (_xsd_MiddleCommandType_base)
{
}

CloseToolChangerType::
CloseToolChangerType (const CommandID_type& CommandID)
: ::MiddleCommandType (CommandID)
{
}

CloseToolChangerType::
CloseToolChangerType (const CloseToolChangerType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c)
{
}

CloseToolChangerType::
CloseToolChangerType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::MiddleCommandType (e, f, c)
{
}

CloseToolChangerType* CloseToolChangerType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CloseToolChangerType (*this, f, c);
}

CloseToolChangerType::
~CloseToolChangerType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CloseToolChangerType >
_xsd_CloseToolChangerType_type_factory_init (
  "CloseToolChangerType",
  "");

// ConfigureJointReportsType
//

ConfigureJointReportsType::
ConfigureJointReportsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                           const ResetAll_type& ResetAll)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ResetAll_ (ResetAll, this),
  ConfigureJointReport_ (this)
{
}

ConfigureJointReportsType::
ConfigureJointReportsType (const CommandID_type& CommandID,
                           const ResetAll_type& ResetAll)
: ::MiddleCommandType (CommandID),
  ResetAll_ (ResetAll, this),
  ConfigureJointReport_ (this)
{
}

ConfigureJointReportsType::
ConfigureJointReportsType (const ConfigureJointReportsType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  ResetAll_ (x.ResetAll_, f, this),
  ConfigureJointReport_ (x.ConfigureJointReport_, f, this)
{
}

ConfigureJointReportsType::
ConfigureJointReportsType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  ResetAll_ (this),
  ConfigureJointReport_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ConfigureJointReportsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ResetAll
    //
    if (n.name () == "ResetAll" && n.namespace_ ().empty ())
    {
      if (!ResetAll_.present ())
      {
        this->ResetAll_.set (ResetAll_traits::create (i, f, this));
        continue;
      }
    }

    // ConfigureJointReport
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ConfigureJointReport",
          "",
          &::xsd::cxx::tree::factory_impl< ConfigureJointReport_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ConfigureJointReport_type > r (
          dynamic_cast< ConfigureJointReport_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->ConfigureJointReport_.push_back (r);
        continue;
      }
    }

    break;
  }

  if (!ResetAll_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ResetAll",
      "");
  }
}

ConfigureJointReportsType* ConfigureJointReportsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ConfigureJointReportsType (*this, f, c);
}

ConfigureJointReportsType& ConfigureJointReportsType::
operator= (const ConfigureJointReportsType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->ResetAll_ = x.ResetAll_;
    this->ConfigureJointReport_ = x.ConfigureJointReport_;
  }

  return *this;
}

ConfigureJointReportsType::
~ConfigureJointReportsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConfigureJointReportsType >
_xsd_ConfigureJointReportsType_type_factory_init (
  "ConfigureJointReportsType",
  "");

// ConfigureJointReportType
//

ConfigureJointReportType::
ConfigureJointReportType (const JointNumber_type& JointNumber,
                          const ReportPosition_type& ReportPosition,
                          const ReportTorqueOrForce_type& ReportTorqueOrForce,
                          const ReportVelocity_type& ReportVelocity)
: ::DataThingType (),
  JointNumber_ (JointNumber, this),
  ReportPosition_ (ReportPosition, this),
  ReportTorqueOrForce_ (ReportTorqueOrForce, this),
  ReportVelocity_ (ReportVelocity, this)
{
}

ConfigureJointReportType::
ConfigureJointReportType (const ConfigureJointReportType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  JointNumber_ (x.JointNumber_, f, this),
  ReportPosition_ (x.ReportPosition_, f, this),
  ReportTorqueOrForce_ (x.ReportTorqueOrForce_, f, this),
  ReportVelocity_ (x.ReportVelocity_, f, this)
{
}

ConfigureJointReportType::
ConfigureJointReportType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  JointNumber_ (this),
  ReportPosition_ (this),
  ReportTorqueOrForce_ (this),
  ReportVelocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ConfigureJointReportType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointNumber
    //
    if (n.name () == "JointNumber" && n.namespace_ ().empty ())
    {
      if (!JointNumber_.present ())
      {
        this->JointNumber_.set (JointNumber_traits::create (i, f, this));
        continue;
      }
    }

    // ReportPosition
    //
    if (n.name () == "ReportPosition" && n.namespace_ ().empty ())
    {
      if (!ReportPosition_.present ())
      {
        this->ReportPosition_.set (ReportPosition_traits::create (i, f, this));
        continue;
      }
    }

    // ReportTorqueOrForce
    //
    if (n.name () == "ReportTorqueOrForce" && n.namespace_ ().empty ())
    {
      if (!ReportTorqueOrForce_.present ())
      {
        this->ReportTorqueOrForce_.set (ReportTorqueOrForce_traits::create (i, f, this));
        continue;
      }
    }

    // ReportVelocity
    //
    if (n.name () == "ReportVelocity" && n.namespace_ ().empty ())
    {
      if (!ReportVelocity_.present ())
      {
        this->ReportVelocity_.set (ReportVelocity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!JointNumber_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointNumber",
      "");
  }

  if (!ReportPosition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportPosition",
      "");
  }

  if (!ReportTorqueOrForce_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportTorqueOrForce",
      "");
  }

  if (!ReportVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportVelocity",
      "");
  }
}

ConfigureJointReportType* ConfigureJointReportType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ConfigureJointReportType (*this, f, c);
}

ConfigureJointReportType& ConfigureJointReportType::
operator= (const ConfigureJointReportType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->JointNumber_ = x.JointNumber_;
    this->ReportPosition_ = x.ReportPosition_;
    this->ReportTorqueOrForce_ = x.ReportTorqueOrForce_;
    this->ReportVelocity_ = x.ReportVelocity_;
  }

  return *this;
}

ConfigureJointReportType::
~ConfigureJointReportType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConfigureJointReportType >
_xsd_ConfigureJointReportType_type_factory_init (
  "ConfigureJointReportType",
  "");

// DwellType
//

DwellType::
DwellType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
           const DwellTime_type& DwellTime)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  DwellTime_ (DwellTime, this)
{
}

DwellType::
DwellType (const CommandID_type& CommandID,
           const DwellTime_type& DwellTime)
: ::MiddleCommandType (CommandID),
  DwellTime_ (DwellTime, this)
{
}

DwellType::
DwellType (const DwellType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  DwellTime_ (x.DwellTime_, f, this)
{
}

DwellType::
DwellType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  DwellTime_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DwellType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DwellTime
    //
    if (n.name () == "DwellTime" && n.namespace_ ().empty ())
    {
      if (!DwellTime_.present ())
      {
        this->DwellTime_.set (DwellTime_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!DwellTime_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DwellTime",
      "");
  }
}

DwellType* DwellType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DwellType (*this, f, c);
}

DwellType& DwellType::
operator= (const DwellType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->DwellTime_ = x.DwellTime_;
  }

  return *this;
}

DwellType::
~DwellType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, DwellType >
_xsd_DwellType_type_factory_init (
  "DwellType",
  "");

// EndCanonType
//

EndCanonType::
EndCanonType (const ::CRCLCommandType& _xsd_CRCLCommandType_base)
: ::CRCLCommandType (_xsd_CRCLCommandType_base)
{
}

EndCanonType::
EndCanonType (const CommandID_type& CommandID)
: ::CRCLCommandType (CommandID)
{
}

EndCanonType::
EndCanonType (const EndCanonType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::CRCLCommandType (x, f, c)
{
}

EndCanonType::
EndCanonType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::CRCLCommandType (e, f, c)
{
}

EndCanonType* EndCanonType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EndCanonType (*this, f, c);
}

EndCanonType::
~EndCanonType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EndCanonType >
_xsd_EndCanonType_type_factory_init (
  "EndCanonType",
  "");

// GetStatusType
//

GetStatusType::
GetStatusType (const ::MiddleCommandType& _xsd_MiddleCommandType_base)
: ::MiddleCommandType (_xsd_MiddleCommandType_base)
{
}

GetStatusType::
GetStatusType (const CommandID_type& CommandID)
: ::MiddleCommandType (CommandID)
{
}

GetStatusType::
GetStatusType (const GetStatusType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c)
{
}

GetStatusType::
GetStatusType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::MiddleCommandType (e, f, c)
{
}

GetStatusType* GetStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GetStatusType (*this, f, c);
}

GetStatusType::
~GetStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GetStatusType >
_xsd_GetStatusType_type_factory_init (
  "GetStatusType",
  "");

// InitCanonType
//

InitCanonType::
InitCanonType (const ::CRCLCommandType& _xsd_CRCLCommandType_base)
: ::CRCLCommandType (_xsd_CRCLCommandType_base)
{
}

InitCanonType::
InitCanonType (const CommandID_type& CommandID)
: ::CRCLCommandType (CommandID)
{
}

InitCanonType::
InitCanonType (const InitCanonType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::CRCLCommandType (x, f, c)
{
}

InitCanonType::
InitCanonType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::CRCLCommandType (e, f, c)
{
}

InitCanonType* InitCanonType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InitCanonType (*this, f, c);
}

InitCanonType::
~InitCanonType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, InitCanonType >
_xsd_InitCanonType_type_factory_init (
  "InitCanonType",
  "");

// JointDetailsType
//

JointDetailsType::
JointDetailsType ()
: ::DataThingType ()
{
}

JointDetailsType::
JointDetailsType (const JointDetailsType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::DataThingType (x, f, c)
{
}

JointDetailsType::
JointDetailsType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::DataThingType (e, f, c)
{
}

JointDetailsType* JointDetailsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointDetailsType (*this, f, c);
}

JointDetailsType::
~JointDetailsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointDetailsType >
_xsd_JointDetailsType_type_factory_init (
  "JointDetailsType",
  "");

// JointForceTorqueType
//

JointForceTorqueType::
JointForceTorqueType ()
: ::JointDetailsType (),
  Setting_ (this),
  ChangeRate_ (this)
{
}

JointForceTorqueType::
JointForceTorqueType (const JointForceTorqueType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::JointDetailsType (x, f, c),
  Setting_ (x.Setting_, f, this),
  ChangeRate_ (x.ChangeRate_, f, this)
{
}

JointForceTorqueType::
JointForceTorqueType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::JointDetailsType (e, f | ::xml_schema::flags::base, c),
  Setting_ (this),
  ChangeRate_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void JointForceTorqueType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::JointDetailsType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Setting
    //
    if (n.name () == "Setting" && n.namespace_ ().empty ())
    {
      if (!this->Setting_)
      {
        this->Setting_.set (Setting_traits::create (i, f, this));
        continue;
      }
    }

    // ChangeRate
    //
    if (n.name () == "ChangeRate" && n.namespace_ ().empty ())
    {
      if (!this->ChangeRate_)
      {
        this->ChangeRate_.set (ChangeRate_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

JointForceTorqueType* JointForceTorqueType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointForceTorqueType (*this, f, c);
}

JointForceTorqueType& JointForceTorqueType::
operator= (const JointForceTorqueType& x)
{
  if (this != &x)
  {
    static_cast< ::JointDetailsType& > (*this) = x;
    this->Setting_ = x.Setting_;
    this->ChangeRate_ = x.ChangeRate_;
  }

  return *this;
}

JointForceTorqueType::
~JointForceTorqueType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointForceTorqueType >
_xsd_JointForceTorqueType_type_factory_init (
  "JointForceTorqueType",
  "");

// JointSpeedAccelType
//

JointSpeedAccelType::
JointSpeedAccelType ()
: ::JointDetailsType (),
  JointSpeed_ (this),
  JointAccel_ (this)
{
}

JointSpeedAccelType::
JointSpeedAccelType (const JointSpeedAccelType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::JointDetailsType (x, f, c),
  JointSpeed_ (x.JointSpeed_, f, this),
  JointAccel_ (x.JointAccel_, f, this)
{
}

JointSpeedAccelType::
JointSpeedAccelType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::JointDetailsType (e, f | ::xml_schema::flags::base, c),
  JointSpeed_ (this),
  JointAccel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void JointSpeedAccelType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::JointDetailsType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointSpeed
    //
    if (n.name () == "JointSpeed" && n.namespace_ ().empty ())
    {
      if (!this->JointSpeed_)
      {
        this->JointSpeed_.set (JointSpeed_traits::create (i, f, this));
        continue;
      }
    }

    // JointAccel
    //
    if (n.name () == "JointAccel" && n.namespace_ ().empty ())
    {
      if (!this->JointAccel_)
      {
        this->JointAccel_.set (JointAccel_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

JointSpeedAccelType* JointSpeedAccelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointSpeedAccelType (*this, f, c);
}

JointSpeedAccelType& JointSpeedAccelType::
operator= (const JointSpeedAccelType& x)
{
  if (this != &x)
  {
    static_cast< ::JointDetailsType& > (*this) = x;
    this->JointSpeed_ = x.JointSpeed_;
    this->JointAccel_ = x.JointAccel_;
  }

  return *this;
}

JointSpeedAccelType::
~JointSpeedAccelType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointSpeedAccelType >
_xsd_JointSpeedAccelType_type_factory_init (
  "JointSpeedAccelType",
  "");

// MessageType
//

MessageType::
MessageType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
             const Message_type& Message)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Message_ (Message, this)
{
}

MessageType::
MessageType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
             ::std::auto_ptr< Message_type > Message)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Message_ (Message, this)
{
}

MessageType::
MessageType (const CommandID_type& CommandID,
             const Message_type& Message)
: ::MiddleCommandType (CommandID),
  Message_ (Message, this)
{
}

MessageType::
MessageType (const CommandID_type& CommandID,
             ::std::auto_ptr< Message_type > Message)
: ::MiddleCommandType (CommandID),
  Message_ (Message, this)
{
}

MessageType::
MessageType (const MessageType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  Message_ (x.Message_, f, this)
{
}

MessageType::
MessageType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  Message_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Message
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Message",
          "",
          &::xsd::cxx::tree::factory_impl< Message_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Message_.present ())
        {
          ::std::auto_ptr< Message_type > r (
            dynamic_cast< Message_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Message_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Message_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Message",
      "");
  }
}

MessageType* MessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MessageType (*this, f, c);
}

MessageType& MessageType::
operator= (const MessageType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->Message_ = x.Message_;
  }

  return *this;
}

MessageType::
~MessageType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, MessageType >
_xsd_MessageType_type_factory_init (
  "MessageType",
  "");

// MoveScrewType
//

MoveScrewType::
MoveScrewType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
               const AxialDistanceScrew_type& AxialDistanceScrew,
               const Turn_type& Turn)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  StartPosition_ (this),
  AxisPoint_ (this),
  AxialDistanceFree_ (this),
  AxialDistanceScrew_ (AxialDistanceScrew, this),
  Turn_ (Turn, this)
{
}

MoveScrewType::
MoveScrewType (const CommandID_type& CommandID,
               const AxialDistanceScrew_type& AxialDistanceScrew,
               const Turn_type& Turn)
: ::MiddleCommandType (CommandID),
  StartPosition_ (this),
  AxisPoint_ (this),
  AxialDistanceFree_ (this),
  AxialDistanceScrew_ (AxialDistanceScrew, this),
  Turn_ (Turn, this)
{
}

MoveScrewType::
MoveScrewType (const MoveScrewType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  StartPosition_ (x.StartPosition_, f, this),
  AxisPoint_ (x.AxisPoint_, f, this),
  AxialDistanceFree_ (x.AxialDistanceFree_, f, this),
  AxialDistanceScrew_ (x.AxialDistanceScrew_, f, this),
  Turn_ (x.Turn_, f, this)
{
}

MoveScrewType::
MoveScrewType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  StartPosition_ (this),
  AxisPoint_ (this),
  AxialDistanceFree_ (this),
  AxialDistanceScrew_ (this),
  Turn_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MoveScrewType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // StartPosition
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "StartPosition",
          "",
          &::xsd::cxx::tree::factory_impl< StartPosition_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->StartPosition_)
        {
          ::std::auto_ptr< StartPosition_type > r (
            dynamic_cast< StartPosition_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->StartPosition_.set (r);
          continue;
        }
      }
    }

    // AxisPoint
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "AxisPoint",
          "",
          &::xsd::cxx::tree::factory_impl< AxisPoint_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->AxisPoint_)
        {
          ::std::auto_ptr< AxisPoint_type > r (
            dynamic_cast< AxisPoint_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AxisPoint_.set (r);
          continue;
        }
      }
    }

    // AxialDistanceFree
    //
    if (n.name () == "AxialDistanceFree" && n.namespace_ ().empty ())
    {
      if (!this->AxialDistanceFree_)
      {
        this->AxialDistanceFree_.set (AxialDistanceFree_traits::create (i, f, this));
        continue;
      }
    }

    // AxialDistanceScrew
    //
    if (n.name () == "AxialDistanceScrew" && n.namespace_ ().empty ())
    {
      if (!AxialDistanceScrew_.present ())
      {
        this->AxialDistanceScrew_.set (AxialDistanceScrew_traits::create (i, f, this));
        continue;
      }
    }

    // Turn
    //
    if (n.name () == "Turn" && n.namespace_ ().empty ())
    {
      if (!Turn_.present ())
      {
        this->Turn_.set (Turn_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!AxialDistanceScrew_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AxialDistanceScrew",
      "");
  }

  if (!Turn_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Turn",
      "");
  }
}

MoveScrewType* MoveScrewType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MoveScrewType (*this, f, c);
}

MoveScrewType& MoveScrewType::
operator= (const MoveScrewType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->StartPosition_ = x.StartPosition_;
    this->AxisPoint_ = x.AxisPoint_;
    this->AxialDistanceFree_ = x.AxialDistanceFree_;
    this->AxialDistanceScrew_ = x.AxialDistanceScrew_;
    this->Turn_ = x.Turn_;
  }

  return *this;
}

MoveScrewType::
~MoveScrewType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, MoveScrewType >
_xsd_MoveScrewType_type_factory_init (
  "MoveScrewType",
  "");

// MoveThroughToType
//

MoveThroughToType::
MoveThroughToType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   const MoveStraight_type& MoveStraight,
                   const NumPositions_type& NumPositions)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  MoveStraight_ (MoveStraight, this),
  Waypoint_ (this),
  NumPositions_ (NumPositions, this)
{
}

MoveThroughToType::
MoveThroughToType (const CommandID_type& CommandID,
                   const MoveStraight_type& MoveStraight,
                   const NumPositions_type& NumPositions)
: ::MiddleCommandType (CommandID),
  MoveStraight_ (MoveStraight, this),
  Waypoint_ (this),
  NumPositions_ (NumPositions, this)
{
}

MoveThroughToType::
MoveThroughToType (const MoveThroughToType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  MoveStraight_ (x.MoveStraight_, f, this),
  Waypoint_ (x.Waypoint_, f, this),
  NumPositions_ (x.NumPositions_, f, this)
{
}

MoveThroughToType::
MoveThroughToType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  MoveStraight_ (this),
  Waypoint_ (this),
  NumPositions_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MoveThroughToType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MoveStraight
    //
    if (n.name () == "MoveStraight" && n.namespace_ ().empty ())
    {
      if (!MoveStraight_.present ())
      {
        this->MoveStraight_.set (MoveStraight_traits::create (i, f, this));
        continue;
      }
    }

    // Waypoint
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Waypoint",
          "",
          &::xsd::cxx::tree::factory_impl< Waypoint_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Waypoint_type > r (
          dynamic_cast< Waypoint_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Waypoint_.push_back (r);
        continue;
      }
    }

    // NumPositions
    //
    if (n.name () == "NumPositions" && n.namespace_ ().empty ())
    {
      if (!NumPositions_.present ())
      {
        this->NumPositions_.set (NumPositions_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!MoveStraight_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "MoveStraight",
      "");
  }

  if (!NumPositions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "NumPositions",
      "");
  }
}

MoveThroughToType* MoveThroughToType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MoveThroughToType (*this, f, c);
}

MoveThroughToType& MoveThroughToType::
operator= (const MoveThroughToType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->MoveStraight_ = x.MoveStraight_;
    this->Waypoint_ = x.Waypoint_;
    this->NumPositions_ = x.NumPositions_;
  }

  return *this;
}

MoveThroughToType::
~MoveThroughToType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, MoveThroughToType >
_xsd_MoveThroughToType_type_factory_init (
  "MoveThroughToType",
  "");

// MoveToType
//

MoveToType::
MoveToType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
            const MoveStraight_type& MoveStraight,
            const EndPosition_type& EndPosition)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  MoveStraight_ (MoveStraight, this),
  EndPosition_ (EndPosition, this)
{
}

MoveToType::
MoveToType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
            const MoveStraight_type& MoveStraight,
            ::std::auto_ptr< EndPosition_type > EndPosition)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  MoveStraight_ (MoveStraight, this),
  EndPosition_ (EndPosition, this)
{
}

MoveToType::
MoveToType (const CommandID_type& CommandID,
            const MoveStraight_type& MoveStraight,
            const EndPosition_type& EndPosition)
: ::MiddleCommandType (CommandID),
  MoveStraight_ (MoveStraight, this),
  EndPosition_ (EndPosition, this)
{
}

MoveToType::
MoveToType (const CommandID_type& CommandID,
            const MoveStraight_type& MoveStraight,
            ::std::auto_ptr< EndPosition_type > EndPosition)
: ::MiddleCommandType (CommandID),
  MoveStraight_ (MoveStraight, this),
  EndPosition_ (EndPosition, this)
{
}

MoveToType::
MoveToType (const MoveToType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  MoveStraight_ (x.MoveStraight_, f, this),
  EndPosition_ (x.EndPosition_, f, this)
{
}

MoveToType::
MoveToType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  MoveStraight_ (this),
  EndPosition_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MoveToType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MoveStraight
    //
    if (n.name () == "MoveStraight" && n.namespace_ ().empty ())
    {
      if (!MoveStraight_.present ())
      {
        this->MoveStraight_.set (MoveStraight_traits::create (i, f, this));
        continue;
      }
    }

    // EndPosition
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "EndPosition",
          "",
          &::xsd::cxx::tree::factory_impl< EndPosition_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!EndPosition_.present ())
        {
          ::std::auto_ptr< EndPosition_type > r (
            dynamic_cast< EndPosition_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->EndPosition_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!MoveStraight_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "MoveStraight",
      "");
  }

  if (!EndPosition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EndPosition",
      "");
  }
}

MoveToType* MoveToType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MoveToType (*this, f, c);
}

MoveToType& MoveToType::
operator= (const MoveToType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->MoveStraight_ = x.MoveStraight_;
    this->EndPosition_ = x.EndPosition_;
  }

  return *this;
}

MoveToType::
~MoveToType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, MoveToType >
_xsd_MoveToType_type_factory_init (
  "MoveToType",
  "");

// OpenToolChangerType
//

OpenToolChangerType::
OpenToolChangerType (const ::MiddleCommandType& _xsd_MiddleCommandType_base)
: ::MiddleCommandType (_xsd_MiddleCommandType_base)
{
}

OpenToolChangerType::
OpenToolChangerType (const CommandID_type& CommandID)
: ::MiddleCommandType (CommandID)
{
}

OpenToolChangerType::
OpenToolChangerType (const OpenToolChangerType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c)
{
}

OpenToolChangerType::
OpenToolChangerType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::MiddleCommandType (e, f, c)
{
}

OpenToolChangerType* OpenToolChangerType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OpenToolChangerType (*this, f, c);
}

OpenToolChangerType::
~OpenToolChangerType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, OpenToolChangerType >
_xsd_OpenToolChangerType_type_factory_init (
  "OpenToolChangerType",
  "");

// RunProgramType
//

RunProgramType::
RunProgramType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                const ProgramText_type& ProgramText)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ProgramText_ (ProgramText, this)
{
}

RunProgramType::
RunProgramType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                ::std::auto_ptr< ProgramText_type > ProgramText)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ProgramText_ (ProgramText, this)
{
}

RunProgramType::
RunProgramType (const CommandID_type& CommandID,
                const ProgramText_type& ProgramText)
: ::MiddleCommandType (CommandID),
  ProgramText_ (ProgramText, this)
{
}

RunProgramType::
RunProgramType (const CommandID_type& CommandID,
                ::std::auto_ptr< ProgramText_type > ProgramText)
: ::MiddleCommandType (CommandID),
  ProgramText_ (ProgramText, this)
{
}

RunProgramType::
RunProgramType (const RunProgramType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  ProgramText_ (x.ProgramText_, f, this)
{
}

RunProgramType::
RunProgramType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  ProgramText_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RunProgramType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ProgramText
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ProgramText",
          "",
          &::xsd::cxx::tree::factory_impl< ProgramText_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!ProgramText_.present ())
        {
          ::std::auto_ptr< ProgramText_type > r (
            dynamic_cast< ProgramText_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ProgramText_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!ProgramText_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ProgramText",
      "");
  }
}

RunProgramType* RunProgramType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RunProgramType (*this, f, c);
}

RunProgramType& RunProgramType::
operator= (const RunProgramType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->ProgramText_ = x.ProgramText_;
  }

  return *this;
}

RunProgramType::
~RunProgramType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RunProgramType >
_xsd_RunProgramType_type_factory_init (
  "RunProgramType",
  "");

// SetAngleUnitsType
//

SetAngleUnitsType::
SetAngleUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   const UnitName_type& UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetAngleUnitsType::
SetAngleUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetAngleUnitsType::
SetAngleUnitsType (const CommandID_type& CommandID,
                   const UnitName_type& UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetAngleUnitsType::
SetAngleUnitsType (const CommandID_type& CommandID,
                   ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetAngleUnitsType::
SetAngleUnitsType (const SetAngleUnitsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  UnitName_ (x.UnitName_, f, this)
{
}

SetAngleUnitsType::
SetAngleUnitsType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  UnitName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetAngleUnitsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // UnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "UnitName",
          "",
          &::xsd::cxx::tree::factory_impl< UnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!UnitName_.present ())
        {
          ::std::auto_ptr< UnitName_type > r (
            dynamic_cast< UnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->UnitName_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!UnitName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "UnitName",
      "");
  }
}

SetAngleUnitsType* SetAngleUnitsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetAngleUnitsType (*this, f, c);
}

SetAngleUnitsType& SetAngleUnitsType::
operator= (const SetAngleUnitsType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->UnitName_ = x.UnitName_;
  }

  return *this;
}

SetAngleUnitsType::
~SetAngleUnitsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetAngleUnitsType >
_xsd_SetAngleUnitsType_type_factory_init (
  "SetAngleUnitsType",
  "");

// SetEndEffectorParametersType
//

SetEndEffectorParametersType::
SetEndEffectorParametersType (const ::MiddleCommandType& _xsd_MiddleCommandType_base)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ParameterSetting_ (this)
{
}

SetEndEffectorParametersType::
SetEndEffectorParametersType (const CommandID_type& CommandID)
: ::MiddleCommandType (CommandID),
  ParameterSetting_ (this)
{
}

SetEndEffectorParametersType::
SetEndEffectorParametersType (const SetEndEffectorParametersType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  ParameterSetting_ (x.ParameterSetting_, f, this)
{
}

SetEndEffectorParametersType::
SetEndEffectorParametersType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  ParameterSetting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetEndEffectorParametersType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ParameterSetting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ParameterSetting",
          "",
          &::xsd::cxx::tree::factory_impl< ParameterSetting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ParameterSetting_type > r (
          dynamic_cast< ParameterSetting_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->ParameterSetting_.push_back (r);
        continue;
      }
    }

    break;
  }
}

SetEndEffectorParametersType* SetEndEffectorParametersType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetEndEffectorParametersType (*this, f, c);
}

SetEndEffectorParametersType& SetEndEffectorParametersType::
operator= (const SetEndEffectorParametersType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->ParameterSetting_ = x.ParameterSetting_;
  }

  return *this;
}

SetEndEffectorParametersType::
~SetEndEffectorParametersType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetEndEffectorParametersType >
_xsd_SetEndEffectorParametersType_type_factory_init (
  "SetEndEffectorParametersType",
  "");

// SetEndEffectorType
//

SetEndEffectorType::
SetEndEffectorType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    const Setting_type& Setting)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Setting_ (Setting, this)
{
}

SetEndEffectorType::
SetEndEffectorType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    ::std::auto_ptr< Setting_type > Setting)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Setting_ (Setting, this)
{
}

SetEndEffectorType::
SetEndEffectorType (const CommandID_type& CommandID,
                    const Setting_type& Setting)
: ::MiddleCommandType (CommandID),
  Setting_ (Setting, this)
{
}

SetEndEffectorType::
SetEndEffectorType (const CommandID_type& CommandID,
                    ::std::auto_ptr< Setting_type > Setting)
: ::MiddleCommandType (CommandID),
  Setting_ (Setting, this)
{
}

SetEndEffectorType::
SetEndEffectorType (const SetEndEffectorType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  Setting_ (x.Setting_, f, this)
{
}

SetEndEffectorType::
SetEndEffectorType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  Setting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetEndEffectorType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Setting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Setting",
          "",
          &::xsd::cxx::tree::factory_impl< Setting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Setting_.present ())
        {
          ::std::auto_ptr< Setting_type > r (
            dynamic_cast< Setting_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Setting_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Setting_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Setting",
      "");
  }
}

SetEndEffectorType* SetEndEffectorType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetEndEffectorType (*this, f, c);
}

SetEndEffectorType& SetEndEffectorType::
operator= (const SetEndEffectorType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->Setting_ = x.Setting_;
  }

  return *this;
}

SetEndEffectorType::
~SetEndEffectorType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetEndEffectorType >
_xsd_SetEndEffectorType_type_factory_init (
  "SetEndEffectorType",
  "");

// SetEndPoseToleranceType
//

SetEndPoseToleranceType::
SetEndPoseToleranceType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                         const Tolerance_type& Tolerance)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Tolerance_ (Tolerance, this)
{
}

SetEndPoseToleranceType::
SetEndPoseToleranceType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                         ::std::auto_ptr< Tolerance_type > Tolerance)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Tolerance_ (Tolerance, this)
{
}

SetEndPoseToleranceType::
SetEndPoseToleranceType (const CommandID_type& CommandID,
                         const Tolerance_type& Tolerance)
: ::MiddleCommandType (CommandID),
  Tolerance_ (Tolerance, this)
{
}

SetEndPoseToleranceType::
SetEndPoseToleranceType (const CommandID_type& CommandID,
                         ::std::auto_ptr< Tolerance_type > Tolerance)
: ::MiddleCommandType (CommandID),
  Tolerance_ (Tolerance, this)
{
}

SetEndPoseToleranceType::
SetEndPoseToleranceType (const SetEndPoseToleranceType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  Tolerance_ (x.Tolerance_, f, this)
{
}

SetEndPoseToleranceType::
SetEndPoseToleranceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  Tolerance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetEndPoseToleranceType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Tolerance
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Tolerance",
          "",
          &::xsd::cxx::tree::factory_impl< Tolerance_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Tolerance_.present ())
        {
          ::std::auto_ptr< Tolerance_type > r (
            dynamic_cast< Tolerance_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Tolerance_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Tolerance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Tolerance",
      "");
  }
}

SetEndPoseToleranceType* SetEndPoseToleranceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetEndPoseToleranceType (*this, f, c);
}

SetEndPoseToleranceType& SetEndPoseToleranceType::
operator= (const SetEndPoseToleranceType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->Tolerance_ = x.Tolerance_;
  }

  return *this;
}

SetEndPoseToleranceType::
~SetEndPoseToleranceType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetEndPoseToleranceType >
_xsd_SetEndPoseToleranceType_type_factory_init (
  "SetEndPoseToleranceType",
  "");

// SetDefaultJointPositonsTolerancesType
//

SetDefaultJointPositonsTolerancesType::
SetDefaultJointPositonsTolerancesType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                                       const JointTolerances_type& JointTolerances)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  JointTolerances_ (JointTolerances, this)
{
}

SetDefaultJointPositonsTolerancesType::
SetDefaultJointPositonsTolerancesType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                                       ::std::auto_ptr< JointTolerances_type > JointTolerances)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  JointTolerances_ (JointTolerances, this)
{
}

SetDefaultJointPositonsTolerancesType::
SetDefaultJointPositonsTolerancesType (const CommandID_type& CommandID,
                                       const JointTolerances_type& JointTolerances)
: ::MiddleCommandType (CommandID),
  JointTolerances_ (JointTolerances, this)
{
}

SetDefaultJointPositonsTolerancesType::
SetDefaultJointPositonsTolerancesType (const CommandID_type& CommandID,
                                       ::std::auto_ptr< JointTolerances_type > JointTolerances)
: ::MiddleCommandType (CommandID),
  JointTolerances_ (JointTolerances, this)
{
}

SetDefaultJointPositonsTolerancesType::
SetDefaultJointPositonsTolerancesType (const SetDefaultJointPositonsTolerancesType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  JointTolerances_ (x.JointTolerances_, f, this)
{
}

SetDefaultJointPositonsTolerancesType::
SetDefaultJointPositonsTolerancesType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  JointTolerances_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetDefaultJointPositonsTolerancesType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointTolerances
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointTolerances",
          "",
          &::xsd::cxx::tree::factory_impl< JointTolerances_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!JointTolerances_.present ())
        {
          ::std::auto_ptr< JointTolerances_type > r (
            dynamic_cast< JointTolerances_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->JointTolerances_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!JointTolerances_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointTolerances",
      "");
  }
}

SetDefaultJointPositonsTolerancesType* SetDefaultJointPositonsTolerancesType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetDefaultJointPositonsTolerancesType (*this, f, c);
}

SetDefaultJointPositonsTolerancesType& SetDefaultJointPositonsTolerancesType::
operator= (const SetDefaultJointPositonsTolerancesType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->JointTolerances_ = x.JointTolerances_;
  }

  return *this;
}

SetDefaultJointPositonsTolerancesType::
~SetDefaultJointPositonsTolerancesType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetDefaultJointPositonsTolerancesType >
_xsd_SetDefaultJointPositonsTolerancesType_type_factory_init (
  "SetDefaultJointPositonsTolerancesType",
  "");

// SetForceUnitsType
//

SetForceUnitsType::
SetForceUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   const UnitName_type& UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetForceUnitsType::
SetForceUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetForceUnitsType::
SetForceUnitsType (const CommandID_type& CommandID,
                   const UnitName_type& UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetForceUnitsType::
SetForceUnitsType (const CommandID_type& CommandID,
                   ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetForceUnitsType::
SetForceUnitsType (const SetForceUnitsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  UnitName_ (x.UnitName_, f, this)
{
}

SetForceUnitsType::
SetForceUnitsType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  UnitName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetForceUnitsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // UnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "UnitName",
          "",
          &::xsd::cxx::tree::factory_impl< UnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!UnitName_.present ())
        {
          ::std::auto_ptr< UnitName_type > r (
            dynamic_cast< UnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->UnitName_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!UnitName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "UnitName",
      "");
  }
}

SetForceUnitsType* SetForceUnitsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetForceUnitsType (*this, f, c);
}

SetForceUnitsType& SetForceUnitsType::
operator= (const SetForceUnitsType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->UnitName_ = x.UnitName_;
  }

  return *this;
}

SetForceUnitsType::
~SetForceUnitsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetForceUnitsType >
_xsd_SetForceUnitsType_type_factory_init (
  "SetForceUnitsType",
  "");

// SetIntermediatePoseToleranceType
//

SetIntermediatePoseToleranceType::
SetIntermediatePoseToleranceType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                                  const Tolerance_type& Tolerance)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Tolerance_ (Tolerance, this)
{
}

SetIntermediatePoseToleranceType::
SetIntermediatePoseToleranceType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                                  ::std::auto_ptr< Tolerance_type > Tolerance)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Tolerance_ (Tolerance, this)
{
}

SetIntermediatePoseToleranceType::
SetIntermediatePoseToleranceType (const CommandID_type& CommandID,
                                  const Tolerance_type& Tolerance)
: ::MiddleCommandType (CommandID),
  Tolerance_ (Tolerance, this)
{
}

SetIntermediatePoseToleranceType::
SetIntermediatePoseToleranceType (const CommandID_type& CommandID,
                                  ::std::auto_ptr< Tolerance_type > Tolerance)
: ::MiddleCommandType (CommandID),
  Tolerance_ (Tolerance, this)
{
}

SetIntermediatePoseToleranceType::
SetIntermediatePoseToleranceType (const SetIntermediatePoseToleranceType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  Tolerance_ (x.Tolerance_, f, this)
{
}

SetIntermediatePoseToleranceType::
SetIntermediatePoseToleranceType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  Tolerance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetIntermediatePoseToleranceType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Tolerance
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Tolerance",
          "",
          &::xsd::cxx::tree::factory_impl< Tolerance_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Tolerance_.present ())
        {
          ::std::auto_ptr< Tolerance_type > r (
            dynamic_cast< Tolerance_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Tolerance_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Tolerance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Tolerance",
      "");
  }
}

SetIntermediatePoseToleranceType* SetIntermediatePoseToleranceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetIntermediatePoseToleranceType (*this, f, c);
}

SetIntermediatePoseToleranceType& SetIntermediatePoseToleranceType::
operator= (const SetIntermediatePoseToleranceType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->Tolerance_ = x.Tolerance_;
  }

  return *this;
}

SetIntermediatePoseToleranceType::
~SetIntermediatePoseToleranceType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetIntermediatePoseToleranceType >
_xsd_SetIntermediatePoseToleranceType_type_factory_init (
  "SetIntermediatePoseToleranceType",
  "");

// SetLengthUnitsType
//

SetLengthUnitsType::
SetLengthUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    const UnitName_type& UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetLengthUnitsType::
SetLengthUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetLengthUnitsType::
SetLengthUnitsType (const CommandID_type& CommandID,
                    const UnitName_type& UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetLengthUnitsType::
SetLengthUnitsType (const CommandID_type& CommandID,
                    ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetLengthUnitsType::
SetLengthUnitsType (const SetLengthUnitsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  UnitName_ (x.UnitName_, f, this)
{
}

SetLengthUnitsType::
SetLengthUnitsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  UnitName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetLengthUnitsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // UnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "UnitName",
          "",
          &::xsd::cxx::tree::factory_impl< UnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!UnitName_.present ())
        {
          ::std::auto_ptr< UnitName_type > r (
            dynamic_cast< UnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->UnitName_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!UnitName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "UnitName",
      "");
  }
}

SetLengthUnitsType* SetLengthUnitsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetLengthUnitsType (*this, f, c);
}

SetLengthUnitsType& SetLengthUnitsType::
operator= (const SetLengthUnitsType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->UnitName_ = x.UnitName_;
  }

  return *this;
}

SetLengthUnitsType::
~SetLengthUnitsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetLengthUnitsType >
_xsd_SetLengthUnitsType_type_factory_init (
  "SetLengthUnitsType",
  "");

// SetMotionCoordinationType
//

SetMotionCoordinationType::
SetMotionCoordinationType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                           const Coordinated_type& Coordinated)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Coordinated_ (Coordinated, this)
{
}

SetMotionCoordinationType::
SetMotionCoordinationType (const CommandID_type& CommandID,
                           const Coordinated_type& Coordinated)
: ::MiddleCommandType (CommandID),
  Coordinated_ (Coordinated, this)
{
}

SetMotionCoordinationType::
SetMotionCoordinationType (const SetMotionCoordinationType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  Coordinated_ (x.Coordinated_, f, this)
{
}

SetMotionCoordinationType::
SetMotionCoordinationType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  Coordinated_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetMotionCoordinationType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Coordinated
    //
    if (n.name () == "Coordinated" && n.namespace_ ().empty ())
    {
      if (!Coordinated_.present ())
      {
        this->Coordinated_.set (Coordinated_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Coordinated_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Coordinated",
      "");
  }
}

SetMotionCoordinationType* SetMotionCoordinationType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetMotionCoordinationType (*this, f, c);
}

SetMotionCoordinationType& SetMotionCoordinationType::
operator= (const SetMotionCoordinationType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->Coordinated_ = x.Coordinated_;
  }

  return *this;
}

SetMotionCoordinationType::
~SetMotionCoordinationType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetMotionCoordinationType >
_xsd_SetMotionCoordinationType_type_factory_init (
  "SetMotionCoordinationType",
  "");

// SetRobotParametersType
//

SetRobotParametersType::
SetRobotParametersType (const ::MiddleCommandType& _xsd_MiddleCommandType_base)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ParameterSetting_ (this)
{
}

SetRobotParametersType::
SetRobotParametersType (const CommandID_type& CommandID)
: ::MiddleCommandType (CommandID),
  ParameterSetting_ (this)
{
}

SetRobotParametersType::
SetRobotParametersType (const SetRobotParametersType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  ParameterSetting_ (x.ParameterSetting_, f, this)
{
}

SetRobotParametersType::
SetRobotParametersType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  ParameterSetting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetRobotParametersType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ParameterSetting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ParameterSetting",
          "",
          &::xsd::cxx::tree::factory_impl< ParameterSetting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ParameterSetting_type > r (
          dynamic_cast< ParameterSetting_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->ParameterSetting_.push_back (r);
        continue;
      }
    }

    break;
  }
}

SetRobotParametersType* SetRobotParametersType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetRobotParametersType (*this, f, c);
}

SetRobotParametersType& SetRobotParametersType::
operator= (const SetRobotParametersType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->ParameterSetting_ = x.ParameterSetting_;
  }

  return *this;
}

SetRobotParametersType::
~SetRobotParametersType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetRobotParametersType >
_xsd_SetRobotParametersType_type_factory_init (
  "SetRobotParametersType",
  "");

// SetRotAccelType
//

SetRotAccelType::
SetRotAccelType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                 const RotAccel_type& RotAccel)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  RotAccel_ (RotAccel, this)
{
}

SetRotAccelType::
SetRotAccelType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                 ::std::auto_ptr< RotAccel_type > RotAccel)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  RotAccel_ (RotAccel, this)
{
}

SetRotAccelType::
SetRotAccelType (const CommandID_type& CommandID,
                 const RotAccel_type& RotAccel)
: ::MiddleCommandType (CommandID),
  RotAccel_ (RotAccel, this)
{
}

SetRotAccelType::
SetRotAccelType (const CommandID_type& CommandID,
                 ::std::auto_ptr< RotAccel_type > RotAccel)
: ::MiddleCommandType (CommandID),
  RotAccel_ (RotAccel, this)
{
}

SetRotAccelType::
SetRotAccelType (const SetRotAccelType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  RotAccel_ (x.RotAccel_, f, this)
{
}

SetRotAccelType::
SetRotAccelType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  RotAccel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetRotAccelType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RotAccel
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotAccel",
          "",
          &::xsd::cxx::tree::factory_impl< RotAccel_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!RotAccel_.present ())
        {
          ::std::auto_ptr< RotAccel_type > r (
            dynamic_cast< RotAccel_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotAccel_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!RotAccel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RotAccel",
      "");
  }
}

SetRotAccelType* SetRotAccelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetRotAccelType (*this, f, c);
}

SetRotAccelType& SetRotAccelType::
operator= (const SetRotAccelType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->RotAccel_ = x.RotAccel_;
  }

  return *this;
}

SetRotAccelType::
~SetRotAccelType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetRotAccelType >
_xsd_SetRotAccelType_type_factory_init (
  "SetRotAccelType",
  "");

// SetRotSpeedType
//

SetRotSpeedType::
SetRotSpeedType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                 const RotSpeed_type& RotSpeed)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  RotSpeed_ (RotSpeed, this)
{
}

SetRotSpeedType::
SetRotSpeedType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                 ::std::auto_ptr< RotSpeed_type > RotSpeed)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  RotSpeed_ (RotSpeed, this)
{
}

SetRotSpeedType::
SetRotSpeedType (const CommandID_type& CommandID,
                 const RotSpeed_type& RotSpeed)
: ::MiddleCommandType (CommandID),
  RotSpeed_ (RotSpeed, this)
{
}

SetRotSpeedType::
SetRotSpeedType (const CommandID_type& CommandID,
                 ::std::auto_ptr< RotSpeed_type > RotSpeed)
: ::MiddleCommandType (CommandID),
  RotSpeed_ (RotSpeed, this)
{
}

SetRotSpeedType::
SetRotSpeedType (const SetRotSpeedType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  RotSpeed_ (x.RotSpeed_, f, this)
{
}

SetRotSpeedType::
SetRotSpeedType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  RotSpeed_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetRotSpeedType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RotSpeed
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotSpeed",
          "",
          &::xsd::cxx::tree::factory_impl< RotSpeed_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!RotSpeed_.present ())
        {
          ::std::auto_ptr< RotSpeed_type > r (
            dynamic_cast< RotSpeed_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotSpeed_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!RotSpeed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RotSpeed",
      "");
  }
}

SetRotSpeedType* SetRotSpeedType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetRotSpeedType (*this, f, c);
}

SetRotSpeedType& SetRotSpeedType::
operator= (const SetRotSpeedType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->RotSpeed_ = x.RotSpeed_;
  }

  return *this;
}

SetRotSpeedType::
~SetRotSpeedType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetRotSpeedType >
_xsd_SetRotSpeedType_type_factory_init (
  "SetRotSpeedType",
  "");

// SetTorqueUnitsType
//

SetTorqueUnitsType::
SetTorqueUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    const UnitName_type& UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetTorqueUnitsType::
SetTorqueUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetTorqueUnitsType::
SetTorqueUnitsType (const CommandID_type& CommandID,
                    const UnitName_type& UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetTorqueUnitsType::
SetTorqueUnitsType (const CommandID_type& CommandID,
                    ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetTorqueUnitsType::
SetTorqueUnitsType (const SetTorqueUnitsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  UnitName_ (x.UnitName_, f, this)
{
}

SetTorqueUnitsType::
SetTorqueUnitsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  UnitName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetTorqueUnitsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // UnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "UnitName",
          "",
          &::xsd::cxx::tree::factory_impl< UnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!UnitName_.present ())
        {
          ::std::auto_ptr< UnitName_type > r (
            dynamic_cast< UnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->UnitName_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!UnitName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "UnitName",
      "");
  }
}

SetTorqueUnitsType* SetTorqueUnitsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetTorqueUnitsType (*this, f, c);
}

SetTorqueUnitsType& SetTorqueUnitsType::
operator= (const SetTorqueUnitsType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->UnitName_ = x.UnitName_;
  }

  return *this;
}

SetTorqueUnitsType::
~SetTorqueUnitsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetTorqueUnitsType >
_xsd_SetTorqueUnitsType_type_factory_init (
  "SetTorqueUnitsType",
  "");

// SetTransAccelType
//

SetTransAccelType::
SetTransAccelType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   const TransAccel_type& TransAccel)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  TransAccel_ (TransAccel, this)
{
}

SetTransAccelType::
SetTransAccelType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   ::std::auto_ptr< TransAccel_type > TransAccel)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  TransAccel_ (TransAccel, this)
{
}

SetTransAccelType::
SetTransAccelType (const CommandID_type& CommandID,
                   const TransAccel_type& TransAccel)
: ::MiddleCommandType (CommandID),
  TransAccel_ (TransAccel, this)
{
}

SetTransAccelType::
SetTransAccelType (const CommandID_type& CommandID,
                   ::std::auto_ptr< TransAccel_type > TransAccel)
: ::MiddleCommandType (CommandID),
  TransAccel_ (TransAccel, this)
{
}

SetTransAccelType::
SetTransAccelType (const SetTransAccelType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  TransAccel_ (x.TransAccel_, f, this)
{
}

SetTransAccelType::
SetTransAccelType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  TransAccel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetTransAccelType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TransAccel
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransAccel",
          "",
          &::xsd::cxx::tree::factory_impl< TransAccel_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!TransAccel_.present ())
        {
          ::std::auto_ptr< TransAccel_type > r (
            dynamic_cast< TransAccel_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransAccel_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!TransAccel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TransAccel",
      "");
  }
}

SetTransAccelType* SetTransAccelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetTransAccelType (*this, f, c);
}

SetTransAccelType& SetTransAccelType::
operator= (const SetTransAccelType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->TransAccel_ = x.TransAccel_;
  }

  return *this;
}

SetTransAccelType::
~SetTransAccelType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetTransAccelType >
_xsd_SetTransAccelType_type_factory_init (
  "SetTransAccelType",
  "");

// SetTransSpeedType
//

SetTransSpeedType::
SetTransSpeedType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   const TransSpeed_type& TransSpeed)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  TransSpeed_ (TransSpeed, this)
{
}

SetTransSpeedType::
SetTransSpeedType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   ::std::auto_ptr< TransSpeed_type > TransSpeed)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  TransSpeed_ (TransSpeed, this)
{
}

SetTransSpeedType::
SetTransSpeedType (const CommandID_type& CommandID,
                   const TransSpeed_type& TransSpeed)
: ::MiddleCommandType (CommandID),
  TransSpeed_ (TransSpeed, this)
{
}

SetTransSpeedType::
SetTransSpeedType (const CommandID_type& CommandID,
                   ::std::auto_ptr< TransSpeed_type > TransSpeed)
: ::MiddleCommandType (CommandID),
  TransSpeed_ (TransSpeed, this)
{
}

SetTransSpeedType::
SetTransSpeedType (const SetTransSpeedType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  TransSpeed_ (x.TransSpeed_, f, this)
{
}

SetTransSpeedType::
SetTransSpeedType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  TransSpeed_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetTransSpeedType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TransSpeed
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransSpeed",
          "",
          &::xsd::cxx::tree::factory_impl< TransSpeed_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!TransSpeed_.present ())
        {
          ::std::auto_ptr< TransSpeed_type > r (
            dynamic_cast< TransSpeed_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransSpeed_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!TransSpeed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TransSpeed",
      "");
  }
}

SetTransSpeedType* SetTransSpeedType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetTransSpeedType (*this, f, c);
}

SetTransSpeedType& SetTransSpeedType::
operator= (const SetTransSpeedType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->TransSpeed_ = x.TransSpeed_;
  }

  return *this;
}

SetTransSpeedType::
~SetTransSpeedType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetTransSpeedType >
_xsd_SetTransSpeedType_type_factory_init (
  "SetTransSpeedType",
  "");

// StopConditionEnumType
//

StopConditionEnumType::
StopConditionEnumType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::token (e, f, c)
{
  _xsd_StopConditionEnumType_convert ();
}

StopConditionEnumType::
StopConditionEnumType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::token (a, f, c)
{
  _xsd_StopConditionEnumType_convert ();
}

StopConditionEnumType::
StopConditionEnumType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::token (s, e, f, c)
{
  _xsd_StopConditionEnumType_convert ();
}

StopConditionEnumType* StopConditionEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class StopConditionEnumType (*this, f, c);
}

StopConditionEnumType::value StopConditionEnumType::
_xsd_StopConditionEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_StopConditionEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_StopConditionEnumType_indexes_,
                    _xsd_StopConditionEnumType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_StopConditionEnumType_indexes_ + 3 || _xsd_StopConditionEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const StopConditionEnumType::
_xsd_StopConditionEnumType_literals_[3] =
{
  "Immediate",
  "Fast",
  "Normal"
};

const StopConditionEnumType::value StopConditionEnumType::
_xsd_StopConditionEnumType_indexes_[3] =
{
  ::StopConditionEnumType::Fast,
  ::StopConditionEnumType::Immediate,
  ::StopConditionEnumType::Normal
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, StopConditionEnumType >
_xsd_StopConditionEnumType_type_factory_init (
  "StopConditionEnumType",
  "");

// StopMotionType
//

StopMotionType::
StopMotionType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                const StopCondition_type& StopCondition)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  StopCondition_ (StopCondition, this)
{
}

StopMotionType::
StopMotionType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                ::std::auto_ptr< StopCondition_type > StopCondition)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  StopCondition_ (StopCondition, this)
{
}

StopMotionType::
StopMotionType (const CommandID_type& CommandID,
                const StopCondition_type& StopCondition)
: ::MiddleCommandType (CommandID),
  StopCondition_ (StopCondition, this)
{
}

StopMotionType::
StopMotionType (const CommandID_type& CommandID,
                ::std::auto_ptr< StopCondition_type > StopCondition)
: ::MiddleCommandType (CommandID),
  StopCondition_ (StopCondition, this)
{
}

StopMotionType::
StopMotionType (const StopMotionType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  StopCondition_ (x.StopCondition_, f, this)
{
}

StopMotionType::
StopMotionType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  StopCondition_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void StopMotionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // StopCondition
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "StopCondition",
          "",
          &::xsd::cxx::tree::factory_impl< StopCondition_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!StopCondition_.present ())
        {
          ::std::auto_ptr< StopCondition_type > r (
            dynamic_cast< StopCondition_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->StopCondition_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!StopCondition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "StopCondition",
      "");
  }
}

StopMotionType* StopMotionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class StopMotionType (*this, f, c);
}

StopMotionType& StopMotionType::
operator= (const StopMotionType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->StopCondition_ = x.StopCondition_;
  }

  return *this;
}

StopMotionType::
~StopMotionType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, StopMotionType >
_xsd_StopMotionType_type_factory_init (
  "StopMotionType",
  "");

// ConfigureStatusReportType
//

ConfigureStatusReportType::
ConfigureStatusReportType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                           const ReportJointStatuses_type& ReportJointStatuses,
                           const ReportPoseStatus_type& ReportPoseStatus,
                           const ReportGripperStatus_type& ReportGripperStatus,
                           const ReportSettingsStatus_type& ReportSettingsStatus,
                           const ReportSensorsStatus_type& ReportSensorsStatus,
                           const ReportGuardsStatus_type& ReportGuardsStatus,
                           const ReportModelStatus_type& ReportModelStatus)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ReportJointStatuses_ (ReportJointStatuses, this),
  ReportPoseStatus_ (ReportPoseStatus, this),
  ReportGripperStatus_ (ReportGripperStatus, this),
  ReportSettingsStatus_ (ReportSettingsStatus, this),
  ReportSensorsStatus_ (ReportSensorsStatus, this),
  ReportGuardsStatus_ (ReportGuardsStatus, this),
  ReportModelStatus_ (ReportModelStatus, this)
{
}

ConfigureStatusReportType::
ConfigureStatusReportType (const CommandID_type& CommandID,
                           const ReportJointStatuses_type& ReportJointStatuses,
                           const ReportPoseStatus_type& ReportPoseStatus,
                           const ReportGripperStatus_type& ReportGripperStatus,
                           const ReportSettingsStatus_type& ReportSettingsStatus,
                           const ReportSensorsStatus_type& ReportSensorsStatus,
                           const ReportGuardsStatus_type& ReportGuardsStatus,
                           const ReportModelStatus_type& ReportModelStatus)
: ::MiddleCommandType (CommandID),
  ReportJointStatuses_ (ReportJointStatuses, this),
  ReportPoseStatus_ (ReportPoseStatus, this),
  ReportGripperStatus_ (ReportGripperStatus, this),
  ReportSettingsStatus_ (ReportSettingsStatus, this),
  ReportSensorsStatus_ (ReportSensorsStatus, this),
  ReportGuardsStatus_ (ReportGuardsStatus, this),
  ReportModelStatus_ (ReportModelStatus, this)
{
}

ConfigureStatusReportType::
ConfigureStatusReportType (const ConfigureStatusReportType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  ReportJointStatuses_ (x.ReportJointStatuses_, f, this),
  ReportPoseStatus_ (x.ReportPoseStatus_, f, this),
  ReportGripperStatus_ (x.ReportGripperStatus_, f, this),
  ReportSettingsStatus_ (x.ReportSettingsStatus_, f, this),
  ReportSensorsStatus_ (x.ReportSensorsStatus_, f, this),
  ReportGuardsStatus_ (x.ReportGuardsStatus_, f, this),
  ReportModelStatus_ (x.ReportModelStatus_, f, this)
{
}

ConfigureStatusReportType::
ConfigureStatusReportType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  ReportJointStatuses_ (this),
  ReportPoseStatus_ (this),
  ReportGripperStatus_ (this),
  ReportSettingsStatus_ (this),
  ReportSensorsStatus_ (this),
  ReportGuardsStatus_ (this),
  ReportModelStatus_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ConfigureStatusReportType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ReportJointStatuses
    //
    if (n.name () == "ReportJointStatuses" && n.namespace_ ().empty ())
    {
      if (!ReportJointStatuses_.present ())
      {
        this->ReportJointStatuses_.set (ReportJointStatuses_traits::create (i, f, this));
        continue;
      }
    }

    // ReportPoseStatus
    //
    if (n.name () == "ReportPoseStatus" && n.namespace_ ().empty ())
    {
      if (!ReportPoseStatus_.present ())
      {
        this->ReportPoseStatus_.set (ReportPoseStatus_traits::create (i, f, this));
        continue;
      }
    }

    // ReportGripperStatus
    //
    if (n.name () == "ReportGripperStatus" && n.namespace_ ().empty ())
    {
      if (!ReportGripperStatus_.present ())
      {
        this->ReportGripperStatus_.set (ReportGripperStatus_traits::create (i, f, this));
        continue;
      }
    }

    // ReportSettingsStatus
    //
    if (n.name () == "ReportSettingsStatus" && n.namespace_ ().empty ())
    {
      if (!ReportSettingsStatus_.present ())
      {
        this->ReportSettingsStatus_.set (ReportSettingsStatus_traits::create (i, f, this));
        continue;
      }
    }

    // ReportSensorsStatus
    //
    if (n.name () == "ReportSensorsStatus" && n.namespace_ ().empty ())
    {
      if (!ReportSensorsStatus_.present ())
      {
        this->ReportSensorsStatus_.set (ReportSensorsStatus_traits::create (i, f, this));
        continue;
      }
    }

    // ReportGuardsStatus
    //
    if (n.name () == "ReportGuardsStatus" && n.namespace_ ().empty ())
    {
      if (!ReportGuardsStatus_.present ())
      {
        this->ReportGuardsStatus_.set (ReportGuardsStatus_traits::create (i, f, this));
        continue;
      }
    }

    // ReportModelStatus
    //
    if (n.name () == "ReportModelStatus" && n.namespace_ ().empty ())
    {
      if (!ReportModelStatus_.present ())
      {
        this->ReportModelStatus_.set (ReportModelStatus_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!ReportJointStatuses_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportJointStatuses",
      "");
  }

  if (!ReportPoseStatus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportPoseStatus",
      "");
  }

  if (!ReportGripperStatus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportGripperStatus",
      "");
  }

  if (!ReportSettingsStatus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportSettingsStatus",
      "");
  }

  if (!ReportSensorsStatus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportSensorsStatus",
      "");
  }

  if (!ReportGuardsStatus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportGuardsStatus",
      "");
  }

  if (!ReportModelStatus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportModelStatus",
      "");
  }
}

ConfigureStatusReportType* ConfigureStatusReportType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ConfigureStatusReportType (*this, f, c);
}

ConfigureStatusReportType& ConfigureStatusReportType::
operator= (const ConfigureStatusReportType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->ReportJointStatuses_ = x.ReportJointStatuses_;
    this->ReportPoseStatus_ = x.ReportPoseStatus_;
    this->ReportGripperStatus_ = x.ReportGripperStatus_;
    this->ReportSettingsStatus_ = x.ReportSettingsStatus_;
    this->ReportSensorsStatus_ = x.ReportSensorsStatus_;
    this->ReportGuardsStatus_ = x.ReportGuardsStatus_;
    this->ReportModelStatus_ = x.ReportModelStatus_;
  }

  return *this;
}

ConfigureStatusReportType::
~ConfigureStatusReportType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConfigureStatusReportType >
_xsd_ConfigureStatusReportType_type_factory_init (
  "ConfigureStatusReportType",
  "");

// EnableSensorType
//

EnableSensorType::
EnableSensorType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                  const SensorID_type& SensorID)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  SensorID_ (SensorID, this),
  SensorOption_ (this)
{
}

EnableSensorType::
EnableSensorType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                  ::std::auto_ptr< SensorID_type > SensorID)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  SensorID_ (SensorID, this),
  SensorOption_ (this)
{
}

EnableSensorType::
EnableSensorType (const CommandID_type& CommandID,
                  const SensorID_type& SensorID)
: ::MiddleCommandType (CommandID),
  SensorID_ (SensorID, this),
  SensorOption_ (this)
{
}

EnableSensorType::
EnableSensorType (const CommandID_type& CommandID,
                  ::std::auto_ptr< SensorID_type > SensorID)
: ::MiddleCommandType (CommandID),
  SensorID_ (SensorID, this),
  SensorOption_ (this)
{
}

EnableSensorType::
EnableSensorType (const EnableSensorType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  SensorID_ (x.SensorID_, f, this),
  SensorOption_ (x.SensorOption_, f, this)
{
}

EnableSensorType::
EnableSensorType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  SensorID_ (this),
  SensorOption_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void EnableSensorType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SensorID
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "SensorID",
          "",
          &::xsd::cxx::tree::factory_impl< SensorID_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!SensorID_.present ())
        {
          ::std::auto_ptr< SensorID_type > r (
            dynamic_cast< SensorID_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->SensorID_.set (r);
          continue;
        }
      }
    }

    // SensorOption
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "SensorOption",
          "",
          &::xsd::cxx::tree::factory_impl< SensorOption_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< SensorOption_type > r (
          dynamic_cast< SensorOption_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->SensorOption_.push_back (r);
        continue;
      }
    }

    break;
  }

  if (!SensorID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SensorID",
      "");
  }
}

EnableSensorType* EnableSensorType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EnableSensorType (*this, f, c);
}

EnableSensorType& EnableSensorType::
operator= (const EnableSensorType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->SensorID_ = x.SensorID_;
    this->SensorOption_ = x.SensorOption_;
  }

  return *this;
}

EnableSensorType::
~EnableSensorType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnableSensorType >
_xsd_EnableSensorType_type_factory_init (
  "EnableSensorType",
  "");

// DisableSensorType
//

DisableSensorType::
DisableSensorType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   const SensorID_type& SensorID)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  SensorID_ (SensorID, this)
{
}

DisableSensorType::
DisableSensorType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   ::std::auto_ptr< SensorID_type > SensorID)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  SensorID_ (SensorID, this)
{
}

DisableSensorType::
DisableSensorType (const CommandID_type& CommandID,
                   const SensorID_type& SensorID)
: ::MiddleCommandType (CommandID),
  SensorID_ (SensorID, this)
{
}

DisableSensorType::
DisableSensorType (const CommandID_type& CommandID,
                   ::std::auto_ptr< SensorID_type > SensorID)
: ::MiddleCommandType (CommandID),
  SensorID_ (SensorID, this)
{
}

DisableSensorType::
DisableSensorType (const DisableSensorType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  SensorID_ (x.SensorID_, f, this)
{
}

DisableSensorType::
DisableSensorType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  SensorID_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DisableSensorType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SensorID
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "SensorID",
          "",
          &::xsd::cxx::tree::factory_impl< SensorID_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!SensorID_.present ())
        {
          ::std::auto_ptr< SensorID_type > r (
            dynamic_cast< SensorID_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->SensorID_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!SensorID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SensorID",
      "");
  }
}

DisableSensorType* DisableSensorType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DisableSensorType (*this, f, c);
}

DisableSensorType& DisableSensorType::
operator= (const DisableSensorType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->SensorID_ = x.SensorID_;
  }

  return *this;
}

DisableSensorType::
~DisableSensorType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, DisableSensorType >
_xsd_DisableSensorType_type_factory_init (
  "DisableSensorType",
  "");

// EnableGripperType
//

EnableGripperType::
EnableGripperType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   const GripperName_type& GripperName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  GripperName_ (GripperName, this),
  GripperOption_ (this)
{
}

EnableGripperType::
EnableGripperType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   ::std::auto_ptr< GripperName_type > GripperName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  GripperName_ (GripperName, this),
  GripperOption_ (this)
{
}

EnableGripperType::
EnableGripperType (const CommandID_type& CommandID,
                   const GripperName_type& GripperName)
: ::MiddleCommandType (CommandID),
  GripperName_ (GripperName, this),
  GripperOption_ (this)
{
}

EnableGripperType::
EnableGripperType (const CommandID_type& CommandID,
                   ::std::auto_ptr< GripperName_type > GripperName)
: ::MiddleCommandType (CommandID),
  GripperName_ (GripperName, this),
  GripperOption_ (this)
{
}

EnableGripperType::
EnableGripperType (const EnableGripperType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  GripperName_ (x.GripperName_, f, this),
  GripperOption_ (x.GripperOption_, f, this)
{
}

EnableGripperType::
EnableGripperType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  GripperName_ (this),
  GripperOption_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void EnableGripperType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // GripperName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GripperName",
          "",
          &::xsd::cxx::tree::factory_impl< GripperName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!GripperName_.present ())
        {
          ::std::auto_ptr< GripperName_type > r (
            dynamic_cast< GripperName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->GripperName_.set (r);
          continue;
        }
      }
    }

    // GripperOption
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GripperOption",
          "",
          &::xsd::cxx::tree::factory_impl< GripperOption_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< GripperOption_type > r (
          dynamic_cast< GripperOption_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->GripperOption_.push_back (r);
        continue;
      }
    }

    break;
  }

  if (!GripperName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "GripperName",
      "");
  }
}

EnableGripperType* EnableGripperType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EnableGripperType (*this, f, c);
}

EnableGripperType& EnableGripperType::
operator= (const EnableGripperType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->GripperName_ = x.GripperName_;
    this->GripperOption_ = x.GripperOption_;
  }

  return *this;
}

EnableGripperType::
~EnableGripperType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnableGripperType >
_xsd_EnableGripperType_type_factory_init (
  "EnableGripperType",
  "");

// DisableGripperType
//

DisableGripperType::
DisableGripperType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    const GripperName_type& GripperName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  GripperName_ (GripperName, this)
{
}

DisableGripperType::
DisableGripperType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    ::std::auto_ptr< GripperName_type > GripperName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  GripperName_ (GripperName, this)
{
}

DisableGripperType::
DisableGripperType (const CommandID_type& CommandID,
                    const GripperName_type& GripperName)
: ::MiddleCommandType (CommandID),
  GripperName_ (GripperName, this)
{
}

DisableGripperType::
DisableGripperType (const CommandID_type& CommandID,
                    ::std::auto_ptr< GripperName_type > GripperName)
: ::MiddleCommandType (CommandID),
  GripperName_ (GripperName, this)
{
}

DisableGripperType::
DisableGripperType (const DisableGripperType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  GripperName_ (x.GripperName_, f, this)
{
}

DisableGripperType::
DisableGripperType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  GripperName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DisableGripperType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // GripperName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GripperName",
          "",
          &::xsd::cxx::tree::factory_impl< GripperName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!GripperName_.present ())
        {
          ::std::auto_ptr< GripperName_type > r (
            dynamic_cast< GripperName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->GripperName_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!GripperName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "GripperName",
      "");
  }
}

DisableGripperType* DisableGripperType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DisableGripperType (*this, f, c);
}

DisableGripperType& DisableGripperType::
operator= (const DisableGripperType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->GripperName_ = x.GripperName_;
  }

  return *this;
}

DisableGripperType::
~DisableGripperType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, DisableGripperType >
_xsd_DisableGripperType_type_factory_init (
  "DisableGripperType",
  "");

// EnableRobotParameterStatusType
//

EnableRobotParameterStatusType::
EnableRobotParameterStatusType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                                const RobotParameterName_type& RobotParameterName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  RobotParameterName_ (RobotParameterName, this)
{
}

EnableRobotParameterStatusType::
EnableRobotParameterStatusType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                                ::std::auto_ptr< RobotParameterName_type > RobotParameterName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  RobotParameterName_ (RobotParameterName, this)
{
}

EnableRobotParameterStatusType::
EnableRobotParameterStatusType (const CommandID_type& CommandID,
                                const RobotParameterName_type& RobotParameterName)
: ::MiddleCommandType (CommandID),
  RobotParameterName_ (RobotParameterName, this)
{
}

EnableRobotParameterStatusType::
EnableRobotParameterStatusType (const CommandID_type& CommandID,
                                ::std::auto_ptr< RobotParameterName_type > RobotParameterName)
: ::MiddleCommandType (CommandID),
  RobotParameterName_ (RobotParameterName, this)
{
}

EnableRobotParameterStatusType::
EnableRobotParameterStatusType (const EnableRobotParameterStatusType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  RobotParameterName_ (x.RobotParameterName_, f, this)
{
}

EnableRobotParameterStatusType::
EnableRobotParameterStatusType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  RobotParameterName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void EnableRobotParameterStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RobotParameterName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RobotParameterName",
          "",
          &::xsd::cxx::tree::factory_impl< RobotParameterName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!RobotParameterName_.present ())
        {
          ::std::auto_ptr< RobotParameterName_type > r (
            dynamic_cast< RobotParameterName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RobotParameterName_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!RobotParameterName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RobotParameterName",
      "");
  }
}

EnableRobotParameterStatusType* EnableRobotParameterStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EnableRobotParameterStatusType (*this, f, c);
}

EnableRobotParameterStatusType& EnableRobotParameterStatusType::
operator= (const EnableRobotParameterStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->RobotParameterName_ = x.RobotParameterName_;
  }

  return *this;
}

EnableRobotParameterStatusType::
~EnableRobotParameterStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnableRobotParameterStatusType >
_xsd_EnableRobotParameterStatusType_type_factory_init (
  "EnableRobotParameterStatusType",
  "");

// DisableRobotParameterStatusType
//

DisableRobotParameterStatusType::
DisableRobotParameterStatusType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                                 const RobotParameterName_type& RobotParameterName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  RobotParameterName_ (RobotParameterName, this)
{
}

DisableRobotParameterStatusType::
DisableRobotParameterStatusType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                                 ::std::auto_ptr< RobotParameterName_type > RobotParameterName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  RobotParameterName_ (RobotParameterName, this)
{
}

DisableRobotParameterStatusType::
DisableRobotParameterStatusType (const CommandID_type& CommandID,
                                 const RobotParameterName_type& RobotParameterName)
: ::MiddleCommandType (CommandID),
  RobotParameterName_ (RobotParameterName, this)
{
}

DisableRobotParameterStatusType::
DisableRobotParameterStatusType (const CommandID_type& CommandID,
                                 ::std::auto_ptr< RobotParameterName_type > RobotParameterName)
: ::MiddleCommandType (CommandID),
  RobotParameterName_ (RobotParameterName, this)
{
}

DisableRobotParameterStatusType::
DisableRobotParameterStatusType (const DisableRobotParameterStatusType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  RobotParameterName_ (x.RobotParameterName_, f, this)
{
}

DisableRobotParameterStatusType::
DisableRobotParameterStatusType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  RobotParameterName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DisableRobotParameterStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RobotParameterName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RobotParameterName",
          "",
          &::xsd::cxx::tree::factory_impl< RobotParameterName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!RobotParameterName_.present ())
        {
          ::std::auto_ptr< RobotParameterName_type > r (
            dynamic_cast< RobotParameterName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RobotParameterName_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!RobotParameterName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RobotParameterName",
      "");
  }
}

DisableRobotParameterStatusType* DisableRobotParameterStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DisableRobotParameterStatusType (*this, f, c);
}

DisableRobotParameterStatusType& DisableRobotParameterStatusType::
operator= (const DisableRobotParameterStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->RobotParameterName_ = x.RobotParameterName_;
  }

  return *this;
}

DisableRobotParameterStatusType::
~DisableRobotParameterStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, DisableRobotParameterStatusType >
_xsd_DisableRobotParameterStatusType_type_factory_init (
  "DisableRobotParameterStatusType",
  "");

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
operator<< (::xercesc::DOMElement& e, const CRCLCommandType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // CommandID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CommandID",
        e));

    s << i.CommandID ();
  }

  // Guard
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (CRCLCommandType::Guard_const_iterator
         b (i.Guard ().begin ()), n (i.Guard ().end ());
         b != n; ++b)
    {
      if (typeid (CRCLCommandType::Guard_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Guard",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Guard",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CRCLCommandType >
_xsd_CRCLCommandType_type_serializer_init (
  "CRCLCommandType",
  "");


void
operator<< (::xercesc::DOMElement& e, const MiddleCommandType& i)
{
  e << static_cast< const ::CRCLCommandType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MiddleCommandType >
_xsd_MiddleCommandType_type_serializer_init (
  "MiddleCommandType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ActuateJointsType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // ActuateJoint
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (ActuateJointsType::ActuateJoint_const_iterator
         b (i.ActuateJoint ().begin ()), n (i.ActuateJoint ().end ());
         b != n; ++b)
    {
      if (typeid (ActuateJointsType::ActuateJoint_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ActuateJoint",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "ActuateJoint",
          "",
          false, true, e, *b);
    }
  }

  // JointTolerances
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.JointTolerances ())
    {
      const ActuateJointsType::JointTolerances_type& x (*i.JointTolerances ());
      if (typeid (ActuateJointsType::JointTolerances_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "JointTolerances",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "JointTolerances",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ActuateJointsType >
_xsd_ActuateJointsType_type_serializer_init (
  "ActuateJointsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ActuateJointType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // JointNumber
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointNumber",
        e));

    s << i.JointNumber ();
  }

  // JointPosition
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointPosition",
        e));

    s << ::xml_schema::as_double(i.JointPosition ());
  }

  // JointDetails
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const ActuateJointType::JointDetails_type& x (i.JointDetails ());
    if (typeid (ActuateJointType::JointDetails_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "JointDetails",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "JointDetails",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ActuateJointType >
_xsd_ActuateJointType_type_serializer_init (
  "ActuateJointType",
  "");


void
operator<< (::xercesc::DOMElement& e, const CloseToolChangerType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CloseToolChangerType >
_xsd_CloseToolChangerType_type_serializer_init (
  "CloseToolChangerType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ConfigureJointReportsType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // ResetAll
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ResetAll",
        e));

    s << i.ResetAll ();
  }

  // ConfigureJointReport
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (ConfigureJointReportsType::ConfigureJointReport_const_iterator
         b (i.ConfigureJointReport ().begin ()), n (i.ConfigureJointReport ().end ());
         b != n; ++b)
    {
      if (typeid (ConfigureJointReportsType::ConfigureJointReport_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConfigureJointReport",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "ConfigureJointReport",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConfigureJointReportsType >
_xsd_ConfigureJointReportsType_type_serializer_init (
  "ConfigureJointReportsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ConfigureJointReportType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // JointNumber
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointNumber",
        e));

    s << i.JointNumber ();
  }

  // ReportPosition
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportPosition",
        e));

    s << i.ReportPosition ();
  }

  // ReportTorqueOrForce
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportTorqueOrForce",
        e));

    s << i.ReportTorqueOrForce ();
  }

  // ReportVelocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportVelocity",
        e));

    s << i.ReportVelocity ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConfigureJointReportType >
_xsd_ConfigureJointReportType_type_serializer_init (
  "ConfigureJointReportType",
  "");


void
operator<< (::xercesc::DOMElement& e, const DwellType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // DwellTime
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DwellTime",
        e));

    s << ::xml_schema::as_double(i.DwellTime ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DwellType >
_xsd_DwellType_type_serializer_init (
  "DwellType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EndCanonType& i)
{
  e << static_cast< const ::CRCLCommandType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EndCanonType >
_xsd_EndCanonType_type_serializer_init (
  "EndCanonType",
  "");


void
operator<< (::xercesc::DOMElement& e, const GetStatusType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GetStatusType >
_xsd_GetStatusType_type_serializer_init (
  "GetStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const InitCanonType& i)
{
  e << static_cast< const ::CRCLCommandType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InitCanonType >
_xsd_InitCanonType_type_serializer_init (
  "InitCanonType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointDetailsType& i)
{
  e << static_cast< const ::DataThingType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointDetailsType >
_xsd_JointDetailsType_type_serializer_init (
  "JointDetailsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointForceTorqueType& i)
{
  e << static_cast< const ::JointDetailsType& > (i);

  // Setting
  //
  if (i.Setting ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Setting",
        e));

    s << ::xml_schema::as_double(*i.Setting ());
  }

  // ChangeRate
  //
  if (i.ChangeRate ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ChangeRate",
        e));

    s << ::xml_schema::as_double(*i.ChangeRate ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointForceTorqueType >
_xsd_JointForceTorqueType_type_serializer_init (
  "JointForceTorqueType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointSpeedAccelType& i)
{
  e << static_cast< const ::JointDetailsType& > (i);

  // JointSpeed
  //
  if (i.JointSpeed ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointSpeed",
        e));

    s << ::xml_schema::as_double(*i.JointSpeed ());
  }

  // JointAccel
  //
  if (i.JointAccel ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointAccel",
        e));

    s << ::xml_schema::as_double(*i.JointAccel ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointSpeedAccelType >
_xsd_JointSpeedAccelType_type_serializer_init (
  "JointSpeedAccelType",
  "");


void
operator<< (::xercesc::DOMElement& e, const MessageType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // Message
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const MessageType::Message_type& x (i.Message ());
    if (typeid (MessageType::Message_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Message",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Message",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MessageType >
_xsd_MessageType_type_serializer_init (
  "MessageType",
  "");


void
operator<< (::xercesc::DOMElement& e, const MoveScrewType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // StartPosition
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.StartPosition ())
    {
      const MoveScrewType::StartPosition_type& x (*i.StartPosition ());
      if (typeid (MoveScrewType::StartPosition_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StartPosition",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "StartPosition",
          "",
          false, true, e, x);
    }
  }

  // AxisPoint
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.AxisPoint ())
    {
      const MoveScrewType::AxisPoint_type& x (*i.AxisPoint ());
      if (typeid (MoveScrewType::AxisPoint_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AxisPoint",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AxisPoint",
          "",
          false, true, e, x);
    }
  }

  // AxialDistanceFree
  //
  if (i.AxialDistanceFree ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AxialDistanceFree",
        e));

    s << ::xml_schema::as_double(*i.AxialDistanceFree ());
  }

  // AxialDistanceScrew
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AxialDistanceScrew",
        e));

    s << ::xml_schema::as_double(i.AxialDistanceScrew ());
  }

  // Turn
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Turn",
        e));

    s << ::xml_schema::as_double(i.Turn ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MoveScrewType >
_xsd_MoveScrewType_type_serializer_init (
  "MoveScrewType",
  "");


void
operator<< (::xercesc::DOMElement& e, const MoveThroughToType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // MoveStraight
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MoveStraight",
        e));

    s << i.MoveStraight ();
  }

  // Waypoint
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (MoveThroughToType::Waypoint_const_iterator
         b (i.Waypoint ().begin ()), n (i.Waypoint ().end ());
         b != n; ++b)
    {
      if (typeid (MoveThroughToType::Waypoint_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Waypoint",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Waypoint",
          "",
          false, true, e, *b);
    }
  }

  // NumPositions
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "NumPositions",
        e));

    s << i.NumPositions ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MoveThroughToType >
_xsd_MoveThroughToType_type_serializer_init (
  "MoveThroughToType",
  "");


void
operator<< (::xercesc::DOMElement& e, const MoveToType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // MoveStraight
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MoveStraight",
        e));

    s << i.MoveStraight ();
  }

  // EndPosition
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const MoveToType::EndPosition_type& x (i.EndPosition ());
    if (typeid (MoveToType::EndPosition_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EndPosition",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "EndPosition",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MoveToType >
_xsd_MoveToType_type_serializer_init (
  "MoveToType",
  "");


void
operator<< (::xercesc::DOMElement& e, const OpenToolChangerType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OpenToolChangerType >
_xsd_OpenToolChangerType_type_serializer_init (
  "OpenToolChangerType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RunProgramType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // ProgramText
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const RunProgramType::ProgramText_type& x (i.ProgramText ());
    if (typeid (RunProgramType::ProgramText_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ProgramText",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "ProgramText",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RunProgramType >
_xsd_RunProgramType_type_serializer_init (
  "RunProgramType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetAngleUnitsType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // UnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetAngleUnitsType::UnitName_type& x (i.UnitName ());
    if (typeid (SetAngleUnitsType::UnitName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "UnitName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "UnitName",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetAngleUnitsType >
_xsd_SetAngleUnitsType_type_serializer_init (
  "SetAngleUnitsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetEndEffectorParametersType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // ParameterSetting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SetEndEffectorParametersType::ParameterSetting_const_iterator
         b (i.ParameterSetting ().begin ()), n (i.ParameterSetting ().end ());
         b != n; ++b)
    {
      if (typeid (SetEndEffectorParametersType::ParameterSetting_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ParameterSetting",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "ParameterSetting",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetEndEffectorParametersType >
_xsd_SetEndEffectorParametersType_type_serializer_init (
  "SetEndEffectorParametersType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetEndEffectorType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // Setting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetEndEffectorType::Setting_type& x (i.Setting ());
    if (typeid (SetEndEffectorType::Setting_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Setting",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Setting",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetEndEffectorType >
_xsd_SetEndEffectorType_type_serializer_init (
  "SetEndEffectorType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetEndPoseToleranceType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // Tolerance
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetEndPoseToleranceType::Tolerance_type& x (i.Tolerance ());
    if (typeid (SetEndPoseToleranceType::Tolerance_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Tolerance",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Tolerance",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetEndPoseToleranceType >
_xsd_SetEndPoseToleranceType_type_serializer_init (
  "SetEndPoseToleranceType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetDefaultJointPositonsTolerancesType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // JointTolerances
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetDefaultJointPositonsTolerancesType::JointTolerances_type& x (i.JointTolerances ());
    if (typeid (SetDefaultJointPositonsTolerancesType::JointTolerances_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "JointTolerances",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "JointTolerances",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetDefaultJointPositonsTolerancesType >
_xsd_SetDefaultJointPositonsTolerancesType_type_serializer_init (
  "SetDefaultJointPositonsTolerancesType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetForceUnitsType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // UnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetForceUnitsType::UnitName_type& x (i.UnitName ());
    if (typeid (SetForceUnitsType::UnitName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "UnitName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "UnitName",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetForceUnitsType >
_xsd_SetForceUnitsType_type_serializer_init (
  "SetForceUnitsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetIntermediatePoseToleranceType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // Tolerance
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetIntermediatePoseToleranceType::Tolerance_type& x (i.Tolerance ());
    if (typeid (SetIntermediatePoseToleranceType::Tolerance_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Tolerance",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Tolerance",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetIntermediatePoseToleranceType >
_xsd_SetIntermediatePoseToleranceType_type_serializer_init (
  "SetIntermediatePoseToleranceType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetLengthUnitsType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // UnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetLengthUnitsType::UnitName_type& x (i.UnitName ());
    if (typeid (SetLengthUnitsType::UnitName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "UnitName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "UnitName",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetLengthUnitsType >
_xsd_SetLengthUnitsType_type_serializer_init (
  "SetLengthUnitsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetMotionCoordinationType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // Coordinated
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Coordinated",
        e));

    s << i.Coordinated ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetMotionCoordinationType >
_xsd_SetMotionCoordinationType_type_serializer_init (
  "SetMotionCoordinationType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetRobotParametersType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // ParameterSetting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SetRobotParametersType::ParameterSetting_const_iterator
         b (i.ParameterSetting ().begin ()), n (i.ParameterSetting ().end ());
         b != n; ++b)
    {
      if (typeid (SetRobotParametersType::ParameterSetting_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ParameterSetting",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "ParameterSetting",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetRobotParametersType >
_xsd_SetRobotParametersType_type_serializer_init (
  "SetRobotParametersType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetRotAccelType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // RotAccel
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetRotAccelType::RotAccel_type& x (i.RotAccel ());
    if (typeid (SetRotAccelType::RotAccel_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RotAccel",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "RotAccel",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetRotAccelType >
_xsd_SetRotAccelType_type_serializer_init (
  "SetRotAccelType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetRotSpeedType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // RotSpeed
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetRotSpeedType::RotSpeed_type& x (i.RotSpeed ());
    if (typeid (SetRotSpeedType::RotSpeed_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RotSpeed",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "RotSpeed",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetRotSpeedType >
_xsd_SetRotSpeedType_type_serializer_init (
  "SetRotSpeedType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetTorqueUnitsType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // UnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetTorqueUnitsType::UnitName_type& x (i.UnitName ());
    if (typeid (SetTorqueUnitsType::UnitName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "UnitName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "UnitName",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetTorqueUnitsType >
_xsd_SetTorqueUnitsType_type_serializer_init (
  "SetTorqueUnitsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetTransAccelType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // TransAccel
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetTransAccelType::TransAccel_type& x (i.TransAccel ());
    if (typeid (SetTransAccelType::TransAccel_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TransAccel",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "TransAccel",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetTransAccelType >
_xsd_SetTransAccelType_type_serializer_init (
  "SetTransAccelType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetTransSpeedType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // TransSpeed
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetTransSpeedType::TransSpeed_type& x (i.TransSpeed ());
    if (typeid (SetTransSpeedType::TransSpeed_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TransSpeed",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "TransSpeed",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetTransSpeedType >
_xsd_SetTransSpeedType_type_serializer_init (
  "SetTransSpeedType",
  "");


void
operator<< (::xercesc::DOMElement& e, const StopConditionEnumType& i)
{
  e << static_cast< const ::xml_schema::token& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const StopConditionEnumType& i)
{
  a << static_cast< const ::xml_schema::token& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const StopConditionEnumType& i)
{
  l << static_cast< const ::xml_schema::token& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StopConditionEnumType >
_xsd_StopConditionEnumType_type_serializer_init (
  "StopConditionEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const StopMotionType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // StopCondition
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const StopMotionType::StopCondition_type& x (i.StopCondition ());
    if (typeid (StopMotionType::StopCondition_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "StopCondition",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "StopCondition",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StopMotionType >
_xsd_StopMotionType_type_serializer_init (
  "StopMotionType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ConfigureStatusReportType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // ReportJointStatuses
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportJointStatuses",
        e));

    s << i.ReportJointStatuses ();
  }

  // ReportPoseStatus
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportPoseStatus",
        e));

    s << i.ReportPoseStatus ();
  }

  // ReportGripperStatus
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportGripperStatus",
        e));

    s << i.ReportGripperStatus ();
  }

  // ReportSettingsStatus
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportSettingsStatus",
        e));

    s << i.ReportSettingsStatus ();
  }

  // ReportSensorsStatus
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportSensorsStatus",
        e));

    s << i.ReportSensorsStatus ();
  }

  // ReportGuardsStatus
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportGuardsStatus",
        e));

    s << i.ReportGuardsStatus ();
  }

  // ReportModelStatus
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportModelStatus",
        e));

    s << i.ReportModelStatus ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConfigureStatusReportType >
_xsd_ConfigureStatusReportType_type_serializer_init (
  "ConfigureStatusReportType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnableSensorType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // SensorID
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const EnableSensorType::SensorID_type& x (i.SensorID ());
    if (typeid (EnableSensorType::SensorID_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SensorID",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "SensorID",
        "",
        false, true, e, x);
  }

  // SensorOption
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (EnableSensorType::SensorOption_const_iterator
         b (i.SensorOption ().begin ()), n (i.SensorOption ().end ());
         b != n; ++b)
    {
      if (typeid (EnableSensorType::SensorOption_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SensorOption",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "SensorOption",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnableSensorType >
_xsd_EnableSensorType_type_serializer_init (
  "EnableSensorType",
  "");


void
operator<< (::xercesc::DOMElement& e, const DisableSensorType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // SensorID
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const DisableSensorType::SensorID_type& x (i.SensorID ());
    if (typeid (DisableSensorType::SensorID_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SensorID",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "SensorID",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DisableSensorType >
_xsd_DisableSensorType_type_serializer_init (
  "DisableSensorType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnableGripperType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // GripperName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const EnableGripperType::GripperName_type& x (i.GripperName ());
    if (typeid (EnableGripperType::GripperName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "GripperName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "GripperName",
        "",
        false, true, e, x);
  }

  // GripperOption
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (EnableGripperType::GripperOption_const_iterator
         b (i.GripperOption ().begin ()), n (i.GripperOption ().end ());
         b != n; ++b)
    {
      if (typeid (EnableGripperType::GripperOption_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GripperOption",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "GripperOption",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnableGripperType >
_xsd_EnableGripperType_type_serializer_init (
  "EnableGripperType",
  "");


void
operator<< (::xercesc::DOMElement& e, const DisableGripperType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // GripperName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const DisableGripperType::GripperName_type& x (i.GripperName ());
    if (typeid (DisableGripperType::GripperName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "GripperName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "GripperName",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DisableGripperType >
_xsd_DisableGripperType_type_serializer_init (
  "DisableGripperType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EnableRobotParameterStatusType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // RobotParameterName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const EnableRobotParameterStatusType::RobotParameterName_type& x (i.RobotParameterName ());
    if (typeid (EnableRobotParameterStatusType::RobotParameterName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RobotParameterName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "RobotParameterName",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnableRobotParameterStatusType >
_xsd_EnableRobotParameterStatusType_type_serializer_init (
  "EnableRobotParameterStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const DisableRobotParameterStatusType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // RobotParameterName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const DisableRobotParameterStatusType::RobotParameterName_type& x (i.RobotParameterName ());
    if (typeid (DisableRobotParameterStatusType::RobotParameterName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RobotParameterName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "RobotParameterName",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DisableRobotParameterStatusType >
_xsd_DisableRobotParameterStatusType_type_serializer_init (
  "DisableRobotParameterStatusType",
  "");


#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

