// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "CRCLStatus.hxx"
#include <iostream>

// CommandStateEnumType
// 

CommandStateEnumType::
CommandStateEnumType (value v)
: ::xml_schema::string (_xsd_CommandStateEnumType_literals_[v])
{
}

CommandStateEnumType::
CommandStateEnumType (const char* v)
: ::xml_schema::string (v)
{
}

CommandStateEnumType::
CommandStateEnumType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

CommandStateEnumType::
CommandStateEnumType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

CommandStateEnumType::
CommandStateEnumType (const CommandStateEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

CommandStateEnumType& CommandStateEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_CommandStateEnumType_literals_[v]);

  return *this;
}


// CommandStatusType
// 

const CommandStatusType::CommandID_type& CommandStatusType::
CommandID () const
{
  return this->CommandID_.get ();
}

CommandStatusType::CommandID_type& CommandStatusType::
CommandID ()
{
  return this->CommandID_.get ();
}

void CommandStatusType::
CommandID (const CommandID_type& x)
{
  this->CommandID_.set (x);
}

const CommandStatusType::StatusID_type& CommandStatusType::
StatusID () const
{
  return this->StatusID_.get ();
}

CommandStatusType::StatusID_type& CommandStatusType::
StatusID ()
{
  return this->StatusID_.get ();
}

void CommandStatusType::
StatusID (const StatusID_type& x)
{
  this->StatusID_.set (x);
}

const CommandStatusType::CommandState_type& CommandStatusType::
CommandState () const
{
  return this->CommandState_.get ();
}

CommandStatusType::CommandState_type& CommandStatusType::
CommandState ()
{
  return this->CommandState_.get ();
}

void CommandStatusType::
CommandState (const CommandState_type& x)
{
  this->CommandState_.set (x);
}

void CommandStatusType::
CommandState (::std::auto_ptr< CommandState_type > x)
{
  this->CommandState_.set (x);
}

const CommandStatusType::StateDescription_optional& CommandStatusType::
StateDescription () const
{
  return this->StateDescription_;
}

CommandStatusType::StateDescription_optional& CommandStatusType::
StateDescription ()
{
  return this->StateDescription_;
}

void CommandStatusType::
StateDescription (const StateDescription_type& x)
{
  this->StateDescription_.set (x);
}

void CommandStatusType::
StateDescription (const StateDescription_optional& x)
{
  this->StateDescription_ = x;
}

void CommandStatusType::
StateDescription (::std::auto_ptr< StateDescription_type > x)
{
  this->StateDescription_.set (x);
}

const CommandStatusType::ProgramFile_optional& CommandStatusType::
ProgramFile () const
{
  return this->ProgramFile_;
}

CommandStatusType::ProgramFile_optional& CommandStatusType::
ProgramFile ()
{
  return this->ProgramFile_;
}

void CommandStatusType::
ProgramFile (const ProgramFile_type& x)
{
  this->ProgramFile_.set (x);
}

void CommandStatusType::
ProgramFile (const ProgramFile_optional& x)
{
  this->ProgramFile_ = x;
}

void CommandStatusType::
ProgramFile (::std::auto_ptr< ProgramFile_type > x)
{
  this->ProgramFile_.set (x);
}

const CommandStatusType::ProgramIndex_optional& CommandStatusType::
ProgramIndex () const
{
  return this->ProgramIndex_;
}

CommandStatusType::ProgramIndex_optional& CommandStatusType::
ProgramIndex ()
{
  return this->ProgramIndex_;
}

void CommandStatusType::
ProgramIndex (const ProgramIndex_type& x)
{
  this->ProgramIndex_.set (x);
}

void CommandStatusType::
ProgramIndex (const ProgramIndex_optional& x)
{
  this->ProgramIndex_ = x;
}

const CommandStatusType::ProgramLength_optional& CommandStatusType::
ProgramLength () const
{
  return this->ProgramLength_;
}

CommandStatusType::ProgramLength_optional& CommandStatusType::
ProgramLength ()
{
  return this->ProgramLength_;
}

void CommandStatusType::
ProgramLength (const ProgramLength_type& x)
{
  this->ProgramLength_.set (x);
}

void CommandStatusType::
ProgramLength (const ProgramLength_optional& x)
{
  this->ProgramLength_ = x;
}

const CommandStatusType::OverridePercent_optional& CommandStatusType::
OverridePercent () const
{
  return this->OverridePercent_;
}

CommandStatusType::OverridePercent_optional& CommandStatusType::
OverridePercent ()
{
  return this->OverridePercent_;
}

void CommandStatusType::
OverridePercent (const OverridePercent_type& x)
{
  this->OverridePercent_.set (x);
}

void CommandStatusType::
OverridePercent (const OverridePercent_optional& x)
{
  this->OverridePercent_ = x;
}


// CRCLStatusType
// 

const CRCLStatusType::CommandStatus_type& CRCLStatusType::
CommandStatus () const
{
  return this->CommandStatus_.get ();
}

CRCLStatusType::CommandStatus_type& CRCLStatusType::
CommandStatus ()
{
  return this->CommandStatus_.get ();
}

void CRCLStatusType::
CommandStatus (const CommandStatus_type& x)
{
  this->CommandStatus_.set (x);
}

void CRCLStatusType::
CommandStatus (::std::auto_ptr< CommandStatus_type > x)
{
  this->CommandStatus_.set (x);
}

const CRCLStatusType::JointStatuses_optional& CRCLStatusType::
JointStatuses () const
{
  return this->JointStatuses_;
}

CRCLStatusType::JointStatuses_optional& CRCLStatusType::
JointStatuses ()
{
  return this->JointStatuses_;
}

void CRCLStatusType::
JointStatuses (const JointStatuses_type& x)
{
  this->JointStatuses_.set (x);
}

void CRCLStatusType::
JointStatuses (const JointStatuses_optional& x)
{
  this->JointStatuses_ = x;
}

void CRCLStatusType::
JointStatuses (::std::auto_ptr< JointStatuses_type > x)
{
  this->JointStatuses_.set (x);
}

const CRCLStatusType::PoseStatus_optional& CRCLStatusType::
PoseStatus () const
{
  return this->PoseStatus_;
}

CRCLStatusType::PoseStatus_optional& CRCLStatusType::
PoseStatus ()
{
  return this->PoseStatus_;
}

void CRCLStatusType::
PoseStatus (const PoseStatus_type& x)
{
  this->PoseStatus_.set (x);
}

void CRCLStatusType::
PoseStatus (const PoseStatus_optional& x)
{
  this->PoseStatus_ = x;
}

void CRCLStatusType::
PoseStatus (::std::auto_ptr< PoseStatus_type > x)
{
  this->PoseStatus_.set (x);
}

const CRCLStatusType::GripperStatus_optional& CRCLStatusType::
GripperStatus () const
{
  return this->GripperStatus_;
}

CRCLStatusType::GripperStatus_optional& CRCLStatusType::
GripperStatus ()
{
  return this->GripperStatus_;
}

void CRCLStatusType::
GripperStatus (const GripperStatus_type& x)
{
  this->GripperStatus_.set (x);
}

void CRCLStatusType::
GripperStatus (const GripperStatus_optional& x)
{
  this->GripperStatus_ = x;
}

void CRCLStatusType::
GripperStatus (::std::auto_ptr< GripperStatus_type > x)
{
  this->GripperStatus_.set (x);
}

const CRCLStatusType::SettingsStatus_optional& CRCLStatusType::
SettingsStatus () const
{
  return this->SettingsStatus_;
}

CRCLStatusType::SettingsStatus_optional& CRCLStatusType::
SettingsStatus ()
{
  return this->SettingsStatus_;
}

void CRCLStatusType::
SettingsStatus (const SettingsStatus_type& x)
{
  this->SettingsStatus_.set (x);
}

void CRCLStatusType::
SettingsStatus (const SettingsStatus_optional& x)
{
  this->SettingsStatus_ = x;
}

void CRCLStatusType::
SettingsStatus (::std::auto_ptr< SettingsStatus_type > x)
{
  this->SettingsStatus_.set (x);
}

const CRCLStatusType::SensorStatuses_optional& CRCLStatusType::
SensorStatuses () const
{
  return this->SensorStatuses_;
}

CRCLStatusType::SensorStatuses_optional& CRCLStatusType::
SensorStatuses ()
{
  return this->SensorStatuses_;
}

void CRCLStatusType::
SensorStatuses (const SensorStatuses_type& x)
{
  this->SensorStatuses_.set (x);
}

void CRCLStatusType::
SensorStatuses (const SensorStatuses_optional& x)
{
  this->SensorStatuses_ = x;
}

void CRCLStatusType::
SensorStatuses (::std::auto_ptr< SensorStatuses_type > x)
{
  this->SensorStatuses_.set (x);
}

const CRCLStatusType::GuardsStatuses_optional& CRCLStatusType::
GuardsStatuses () const
{
  return this->GuardsStatuses_;
}

CRCLStatusType::GuardsStatuses_optional& CRCLStatusType::
GuardsStatuses ()
{
  return this->GuardsStatuses_;
}

void CRCLStatusType::
GuardsStatuses (const GuardsStatuses_type& x)
{
  this->GuardsStatuses_.set (x);
}

void CRCLStatusType::
GuardsStatuses (const GuardsStatuses_optional& x)
{
  this->GuardsStatuses_ = x;
}

void CRCLStatusType::
GuardsStatuses (::std::auto_ptr< GuardsStatuses_type > x)
{
  this->GuardsStatuses_.set (x);
}

const CRCLStatusType::ModelStatus_sequence& CRCLStatusType::
ModelStatus () const
{
  return this->ModelStatus_;
}

CRCLStatusType::ModelStatus_sequence& CRCLStatusType::
ModelStatus ()
{
  return this->ModelStatus_;
}

void CRCLStatusType::
ModelStatus (const ModelStatus_sequence& s)
{
  this->ModelStatus_ = s;
}


// GripperStatusType
// 

const GripperStatusType::GripperName_type& GripperStatusType::
GripperName () const
{
  return this->GripperName_.get ();
}

GripperStatusType::GripperName_type& GripperStatusType::
GripperName ()
{
  return this->GripperName_.get ();
}

void GripperStatusType::
GripperName (const GripperName_type& x)
{
  this->GripperName_.set (x);
}

void GripperStatusType::
GripperName (::std::auto_ptr< GripperName_type > x)
{
  this->GripperName_.set (x);
}

const GripperStatusType::GripperOption_sequence& GripperStatusType::
GripperOption () const
{
  return this->GripperOption_;
}

GripperStatusType::GripperOption_sequence& GripperStatusType::
GripperOption ()
{
  return this->GripperOption_;
}

void GripperStatusType::
GripperOption (const GripperOption_sequence& s)
{
  this->GripperOption_ = s;
}

const GripperStatusType::HoldingObject_optional& GripperStatusType::
HoldingObject () const
{
  return this->HoldingObject_;
}

GripperStatusType::HoldingObject_optional& GripperStatusType::
HoldingObject ()
{
  return this->HoldingObject_;
}

void GripperStatusType::
HoldingObject (const HoldingObject_type& x)
{
  this->HoldingObject_.set (x);
}

void GripperStatusType::
HoldingObject (const HoldingObject_optional& x)
{
  this->HoldingObject_ = x;
}


// JointStatusesType
// 

const JointStatusesType::JointStatus_sequence& JointStatusesType::
JointStatus () const
{
  return this->JointStatus_;
}

JointStatusesType::JointStatus_sequence& JointStatusesType::
JointStatus ()
{
  return this->JointStatus_;
}

void JointStatusesType::
JointStatus (const JointStatus_sequence& s)
{
  this->JointStatus_ = s;
}


// JointStatusType
// 

const JointStatusType::JointNumber_type& JointStatusType::
JointNumber () const
{
  return this->JointNumber_.get ();
}

JointStatusType::JointNumber_type& JointStatusType::
JointNumber ()
{
  return this->JointNumber_.get ();
}

void JointStatusType::
JointNumber (const JointNumber_type& x)
{
  this->JointNumber_.set (x);
}

const JointStatusType::JointPosition_optional& JointStatusType::
JointPosition () const
{
  return this->JointPosition_;
}

JointStatusType::JointPosition_optional& JointStatusType::
JointPosition ()
{
  return this->JointPosition_;
}

void JointStatusType::
JointPosition (const JointPosition_type& x)
{
  this->JointPosition_.set (x);
}

void JointStatusType::
JointPosition (const JointPosition_optional& x)
{
  this->JointPosition_ = x;
}

const JointStatusType::JointTorqueOrForce_optional& JointStatusType::
JointTorqueOrForce () const
{
  return this->JointTorqueOrForce_;
}

JointStatusType::JointTorqueOrForce_optional& JointStatusType::
JointTorqueOrForce ()
{
  return this->JointTorqueOrForce_;
}

void JointStatusType::
JointTorqueOrForce (const JointTorqueOrForce_type& x)
{
  this->JointTorqueOrForce_.set (x);
}

void JointStatusType::
JointTorqueOrForce (const JointTorqueOrForce_optional& x)
{
  this->JointTorqueOrForce_ = x;
}

const JointStatusType::JointVelocity_optional& JointStatusType::
JointVelocity () const
{
  return this->JointVelocity_;
}

JointStatusType::JointVelocity_optional& JointStatusType::
JointVelocity ()
{
  return this->JointVelocity_;
}

void JointStatusType::
JointVelocity (const JointVelocity_type& x)
{
  this->JointVelocity_.set (x);
}

void JointStatusType::
JointVelocity (const JointVelocity_optional& x)
{
  this->JointVelocity_ = x;
}


// JointLimitType
// 

const JointLimitType::JointNumber_type& JointLimitType::
JointNumber () const
{
  return this->JointNumber_.get ();
}

JointLimitType::JointNumber_type& JointLimitType::
JointNumber ()
{
  return this->JointNumber_.get ();
}

void JointLimitType::
JointNumber (const JointNumber_type& x)
{
  this->JointNumber_.set (x);
}

const JointLimitType::JointMinPosition_optional& JointLimitType::
JointMinPosition () const
{
  return this->JointMinPosition_;
}

JointLimitType::JointMinPosition_optional& JointLimitType::
JointMinPosition ()
{
  return this->JointMinPosition_;
}

void JointLimitType::
JointMinPosition (const JointMinPosition_type& x)
{
  this->JointMinPosition_.set (x);
}

void JointLimitType::
JointMinPosition (const JointMinPosition_optional& x)
{
  this->JointMinPosition_ = x;
}

const JointLimitType::JointMaxPosition_optional& JointLimitType::
JointMaxPosition () const
{
  return this->JointMaxPosition_;
}

JointLimitType::JointMaxPosition_optional& JointLimitType::
JointMaxPosition ()
{
  return this->JointMaxPosition_;
}

void JointLimitType::
JointMaxPosition (const JointMaxPosition_type& x)
{
  this->JointMaxPosition_.set (x);
}

void JointLimitType::
JointMaxPosition (const JointMaxPosition_optional& x)
{
  this->JointMaxPosition_ = x;
}

const JointLimitType::JointMaxTorqueOrForce_optional& JointLimitType::
JointMaxTorqueOrForce () const
{
  return this->JointMaxTorqueOrForce_;
}

JointLimitType::JointMaxTorqueOrForce_optional& JointLimitType::
JointMaxTorqueOrForce ()
{
  return this->JointMaxTorqueOrForce_;
}

void JointLimitType::
JointMaxTorqueOrForce (const JointMaxTorqueOrForce_type& x)
{
  this->JointMaxTorqueOrForce_.set (x);
}

void JointLimitType::
JointMaxTorqueOrForce (const JointMaxTorqueOrForce_optional& x)
{
  this->JointMaxTorqueOrForce_ = x;
}

const JointLimitType::JointMaxVelocity_optional& JointLimitType::
JointMaxVelocity () const
{
  return this->JointMaxVelocity_;
}

JointLimitType::JointMaxVelocity_optional& JointLimitType::
JointMaxVelocity ()
{
  return this->JointMaxVelocity_;
}

void JointLimitType::
JointMaxVelocity (const JointMaxVelocity_type& x)
{
  this->JointMaxVelocity_.set (x);
}

void JointLimitType::
JointMaxVelocity (const JointMaxVelocity_optional& x)
{
  this->JointMaxVelocity_ = x;
}


// ParallelGripperStatusType
// 

const ParallelGripperStatusType::Separation_type& ParallelGripperStatusType::
Separation () const
{
  return this->Separation_.get ();
}

ParallelGripperStatusType::Separation_type& ParallelGripperStatusType::
Separation ()
{
  return this->Separation_.get ();
}

void ParallelGripperStatusType::
Separation (const Separation_type& x)
{
  this->Separation_.set (x);
}


// PoseStatusType
// 

const PoseStatusType::Pose_type& PoseStatusType::
Pose () const
{
  return this->Pose_.get ();
}

PoseStatusType::Pose_type& PoseStatusType::
Pose ()
{
  return this->Pose_.get ();
}

void PoseStatusType::
Pose (const Pose_type& x)
{
  this->Pose_.set (x);
}

void PoseStatusType::
Pose (::std::auto_ptr< Pose_type > x)
{
  this->Pose_.set (x);
}

const PoseStatusType::Twist_optional& PoseStatusType::
Twist () const
{
  return this->Twist_;
}

PoseStatusType::Twist_optional& PoseStatusType::
Twist ()
{
  return this->Twist_;
}

void PoseStatusType::
Twist (const Twist_type& x)
{
  this->Twist_.set (x);
}

void PoseStatusType::
Twist (const Twist_optional& x)
{
  this->Twist_ = x;
}

void PoseStatusType::
Twist (::std::auto_ptr< Twist_type > x)
{
  this->Twist_.set (x);
}

const PoseStatusType::Wrench_optional& PoseStatusType::
Wrench () const
{
  return this->Wrench_;
}

PoseStatusType::Wrench_optional& PoseStatusType::
Wrench ()
{
  return this->Wrench_;
}

void PoseStatusType::
Wrench (const Wrench_type& x)
{
  this->Wrench_.set (x);
}

void PoseStatusType::
Wrench (const Wrench_optional& x)
{
  this->Wrench_ = x;
}

void PoseStatusType::
Wrench (::std::auto_ptr< Wrench_type > x)
{
  this->Wrench_.set (x);
}

const PoseStatusType::Configuration_optional& PoseStatusType::
Configuration () const
{
  return this->Configuration_;
}

PoseStatusType::Configuration_optional& PoseStatusType::
Configuration ()
{
  return this->Configuration_;
}

void PoseStatusType::
Configuration (const Configuration_type& x)
{
  this->Configuration_.set (x);
}

void PoseStatusType::
Configuration (const Configuration_optional& x)
{
  this->Configuration_ = x;
}

void PoseStatusType::
Configuration (::std::auto_ptr< Configuration_type > x)
{
  this->Configuration_.set (x);
}


// SettingsStatusType
// 

const SettingsStatusType::AngleUnitName_optional& SettingsStatusType::
AngleUnitName () const
{
  return this->AngleUnitName_;
}

SettingsStatusType::AngleUnitName_optional& SettingsStatusType::
AngleUnitName ()
{
  return this->AngleUnitName_;
}

void SettingsStatusType::
AngleUnitName (const AngleUnitName_type& x)
{
  this->AngleUnitName_.set (x);
}

void SettingsStatusType::
AngleUnitName (const AngleUnitName_optional& x)
{
  this->AngleUnitName_ = x;
}

void SettingsStatusType::
AngleUnitName (::std::auto_ptr< AngleUnitName_type > x)
{
  this->AngleUnitName_.set (x);
}

const SettingsStatusType::EndEffectorParameterSetting_sequence& SettingsStatusType::
EndEffectorParameterSetting () const
{
  return this->EndEffectorParameterSetting_;
}

SettingsStatusType::EndEffectorParameterSetting_sequence& SettingsStatusType::
EndEffectorParameterSetting ()
{
  return this->EndEffectorParameterSetting_;
}

void SettingsStatusType::
EndEffectorParameterSetting (const EndEffectorParameterSetting_sequence& s)
{
  this->EndEffectorParameterSetting_ = s;
}

const SettingsStatusType::EndEffectorSetting_optional& SettingsStatusType::
EndEffectorSetting () const
{
  return this->EndEffectorSetting_;
}

SettingsStatusType::EndEffectorSetting_optional& SettingsStatusType::
EndEffectorSetting ()
{
  return this->EndEffectorSetting_;
}

void SettingsStatusType::
EndEffectorSetting (const EndEffectorSetting_type& x)
{
  this->EndEffectorSetting_.set (x);
}

void SettingsStatusType::
EndEffectorSetting (const EndEffectorSetting_optional& x)
{
  this->EndEffectorSetting_ = x;
}

void SettingsStatusType::
EndEffectorSetting (::std::auto_ptr< EndEffectorSetting_type > x)
{
  this->EndEffectorSetting_.set (x);
}

const SettingsStatusType::ForceUnitName_optional& SettingsStatusType::
ForceUnitName () const
{
  return this->ForceUnitName_;
}

SettingsStatusType::ForceUnitName_optional& SettingsStatusType::
ForceUnitName ()
{
  return this->ForceUnitName_;
}

void SettingsStatusType::
ForceUnitName (const ForceUnitName_type& x)
{
  this->ForceUnitName_.set (x);
}

void SettingsStatusType::
ForceUnitName (const ForceUnitName_optional& x)
{
  this->ForceUnitName_ = x;
}

void SettingsStatusType::
ForceUnitName (::std::auto_ptr< ForceUnitName_type > x)
{
  this->ForceUnitName_.set (x);
}

const SettingsStatusType::JointLimits_sequence& SettingsStatusType::
JointLimits () const
{
  return this->JointLimits_;
}

SettingsStatusType::JointLimits_sequence& SettingsStatusType::
JointLimits ()
{
  return this->JointLimits_;
}

void SettingsStatusType::
JointLimits (const JointLimits_sequence& s)
{
  this->JointLimits_ = s;
}

const SettingsStatusType::IntermediatePoseTolerance_optional& SettingsStatusType::
IntermediatePoseTolerance () const
{
  return this->IntermediatePoseTolerance_;
}

SettingsStatusType::IntermediatePoseTolerance_optional& SettingsStatusType::
IntermediatePoseTolerance ()
{
  return this->IntermediatePoseTolerance_;
}

void SettingsStatusType::
IntermediatePoseTolerance (const IntermediatePoseTolerance_type& x)
{
  this->IntermediatePoseTolerance_.set (x);
}

void SettingsStatusType::
IntermediatePoseTolerance (const IntermediatePoseTolerance_optional& x)
{
  this->IntermediatePoseTolerance_ = x;
}

void SettingsStatusType::
IntermediatePoseTolerance (::std::auto_ptr< IntermediatePoseTolerance_type > x)
{
  this->IntermediatePoseTolerance_.set (x);
}

const SettingsStatusType::LengthUnitName_optional& SettingsStatusType::
LengthUnitName () const
{
  return this->LengthUnitName_;
}

SettingsStatusType::LengthUnitName_optional& SettingsStatusType::
LengthUnitName ()
{
  return this->LengthUnitName_;
}

void SettingsStatusType::
LengthUnitName (const LengthUnitName_type& x)
{
  this->LengthUnitName_.set (x);
}

void SettingsStatusType::
LengthUnitName (const LengthUnitName_optional& x)
{
  this->LengthUnitName_ = x;
}

void SettingsStatusType::
LengthUnitName (::std::auto_ptr< LengthUnitName_type > x)
{
  this->LengthUnitName_.set (x);
}

const SettingsStatusType::MaxCartesianLimit_optional& SettingsStatusType::
MaxCartesianLimit () const
{
  return this->MaxCartesianLimit_;
}

SettingsStatusType::MaxCartesianLimit_optional& SettingsStatusType::
MaxCartesianLimit ()
{
  return this->MaxCartesianLimit_;
}

void SettingsStatusType::
MaxCartesianLimit (const MaxCartesianLimit_type& x)
{
  this->MaxCartesianLimit_.set (x);
}

void SettingsStatusType::
MaxCartesianLimit (const MaxCartesianLimit_optional& x)
{
  this->MaxCartesianLimit_ = x;
}

void SettingsStatusType::
MaxCartesianLimit (::std::auto_ptr< MaxCartesianLimit_type > x)
{
  this->MaxCartesianLimit_.set (x);
}

const SettingsStatusType::MinCartesianLimit_optional& SettingsStatusType::
MinCartesianLimit () const
{
  return this->MinCartesianLimit_;
}

SettingsStatusType::MinCartesianLimit_optional& SettingsStatusType::
MinCartesianLimit ()
{
  return this->MinCartesianLimit_;
}

void SettingsStatusType::
MinCartesianLimit (const MinCartesianLimit_type& x)
{
  this->MinCartesianLimit_.set (x);
}

void SettingsStatusType::
MinCartesianLimit (const MinCartesianLimit_optional& x)
{
  this->MinCartesianLimit_ = x;
}

void SettingsStatusType::
MinCartesianLimit (::std::auto_ptr< MinCartesianLimit_type > x)
{
  this->MinCartesianLimit_.set (x);
}

const SettingsStatusType::MotionCoordinated_optional& SettingsStatusType::
MotionCoordinated () const
{
  return this->MotionCoordinated_;
}

SettingsStatusType::MotionCoordinated_optional& SettingsStatusType::
MotionCoordinated ()
{
  return this->MotionCoordinated_;
}

void SettingsStatusType::
MotionCoordinated (const MotionCoordinated_type& x)
{
  this->MotionCoordinated_.set (x);
}

void SettingsStatusType::
MotionCoordinated (const MotionCoordinated_optional& x)
{
  this->MotionCoordinated_ = x;
}

const SettingsStatusType::EndPoseTolerance_optional& SettingsStatusType::
EndPoseTolerance () const
{
  return this->EndPoseTolerance_;
}

SettingsStatusType::EndPoseTolerance_optional& SettingsStatusType::
EndPoseTolerance ()
{
  return this->EndPoseTolerance_;
}

void SettingsStatusType::
EndPoseTolerance (const EndPoseTolerance_type& x)
{
  this->EndPoseTolerance_.set (x);
}

void SettingsStatusType::
EndPoseTolerance (const EndPoseTolerance_optional& x)
{
  this->EndPoseTolerance_ = x;
}

void SettingsStatusType::
EndPoseTolerance (::std::auto_ptr< EndPoseTolerance_type > x)
{
  this->EndPoseTolerance_.set (x);
}

const SettingsStatusType::RobotParameterSetting_sequence& SettingsStatusType::
RobotParameterSetting () const
{
  return this->RobotParameterSetting_;
}

SettingsStatusType::RobotParameterSetting_sequence& SettingsStatusType::
RobotParameterSetting ()
{
  return this->RobotParameterSetting_;
}

void SettingsStatusType::
RobotParameterSetting (const RobotParameterSetting_sequence& s)
{
  this->RobotParameterSetting_ = s;
}

const SettingsStatusType::RotAccelAbsolute_optional& SettingsStatusType::
RotAccelAbsolute () const
{
  return this->RotAccelAbsolute_;
}

SettingsStatusType::RotAccelAbsolute_optional& SettingsStatusType::
RotAccelAbsolute ()
{
  return this->RotAccelAbsolute_;
}

void SettingsStatusType::
RotAccelAbsolute (const RotAccelAbsolute_type& x)
{
  this->RotAccelAbsolute_.set (x);
}

void SettingsStatusType::
RotAccelAbsolute (const RotAccelAbsolute_optional& x)
{
  this->RotAccelAbsolute_ = x;
}

void SettingsStatusType::
RotAccelAbsolute (::std::auto_ptr< RotAccelAbsolute_type > x)
{
  this->RotAccelAbsolute_.set (x);
}

const SettingsStatusType::RotAccelRelative_optional& SettingsStatusType::
RotAccelRelative () const
{
  return this->RotAccelRelative_;
}

SettingsStatusType::RotAccelRelative_optional& SettingsStatusType::
RotAccelRelative ()
{
  return this->RotAccelRelative_;
}

void SettingsStatusType::
RotAccelRelative (const RotAccelRelative_type& x)
{
  this->RotAccelRelative_.set (x);
}

void SettingsStatusType::
RotAccelRelative (const RotAccelRelative_optional& x)
{
  this->RotAccelRelative_ = x;
}

void SettingsStatusType::
RotAccelRelative (::std::auto_ptr< RotAccelRelative_type > x)
{
  this->RotAccelRelative_.set (x);
}

const SettingsStatusType::RotSpeedAbsolute_optional& SettingsStatusType::
RotSpeedAbsolute () const
{
  return this->RotSpeedAbsolute_;
}

SettingsStatusType::RotSpeedAbsolute_optional& SettingsStatusType::
RotSpeedAbsolute ()
{
  return this->RotSpeedAbsolute_;
}

void SettingsStatusType::
RotSpeedAbsolute (const RotSpeedAbsolute_type& x)
{
  this->RotSpeedAbsolute_.set (x);
}

void SettingsStatusType::
RotSpeedAbsolute (const RotSpeedAbsolute_optional& x)
{
  this->RotSpeedAbsolute_ = x;
}

void SettingsStatusType::
RotSpeedAbsolute (::std::auto_ptr< RotSpeedAbsolute_type > x)
{
  this->RotSpeedAbsolute_.set (x);
}

const SettingsStatusType::RotSpeedRelative_optional& SettingsStatusType::
RotSpeedRelative () const
{
  return this->RotSpeedRelative_;
}

SettingsStatusType::RotSpeedRelative_optional& SettingsStatusType::
RotSpeedRelative ()
{
  return this->RotSpeedRelative_;
}

void SettingsStatusType::
RotSpeedRelative (const RotSpeedRelative_type& x)
{
  this->RotSpeedRelative_.set (x);
}

void SettingsStatusType::
RotSpeedRelative (const RotSpeedRelative_optional& x)
{
  this->RotSpeedRelative_ = x;
}

void SettingsStatusType::
RotSpeedRelative (::std::auto_ptr< RotSpeedRelative_type > x)
{
  this->RotSpeedRelative_.set (x);
}

const SettingsStatusType::TorqueUnitName_optional& SettingsStatusType::
TorqueUnitName () const
{
  return this->TorqueUnitName_;
}

SettingsStatusType::TorqueUnitName_optional& SettingsStatusType::
TorqueUnitName ()
{
  return this->TorqueUnitName_;
}

void SettingsStatusType::
TorqueUnitName (const TorqueUnitName_type& x)
{
  this->TorqueUnitName_.set (x);
}

void SettingsStatusType::
TorqueUnitName (const TorqueUnitName_optional& x)
{
  this->TorqueUnitName_ = x;
}

void SettingsStatusType::
TorqueUnitName (::std::auto_ptr< TorqueUnitName_type > x)
{
  this->TorqueUnitName_.set (x);
}

const SettingsStatusType::TransAccelAbsolute_optional& SettingsStatusType::
TransAccelAbsolute () const
{
  return this->TransAccelAbsolute_;
}

SettingsStatusType::TransAccelAbsolute_optional& SettingsStatusType::
TransAccelAbsolute ()
{
  return this->TransAccelAbsolute_;
}

void SettingsStatusType::
TransAccelAbsolute (const TransAccelAbsolute_type& x)
{
  this->TransAccelAbsolute_.set (x);
}

void SettingsStatusType::
TransAccelAbsolute (const TransAccelAbsolute_optional& x)
{
  this->TransAccelAbsolute_ = x;
}

void SettingsStatusType::
TransAccelAbsolute (::std::auto_ptr< TransAccelAbsolute_type > x)
{
  this->TransAccelAbsolute_.set (x);
}

const SettingsStatusType::TransAccelRelative_optional& SettingsStatusType::
TransAccelRelative () const
{
  return this->TransAccelRelative_;
}

SettingsStatusType::TransAccelRelative_optional& SettingsStatusType::
TransAccelRelative ()
{
  return this->TransAccelRelative_;
}

void SettingsStatusType::
TransAccelRelative (const TransAccelRelative_type& x)
{
  this->TransAccelRelative_.set (x);
}

void SettingsStatusType::
TransAccelRelative (const TransAccelRelative_optional& x)
{
  this->TransAccelRelative_ = x;
}

void SettingsStatusType::
TransAccelRelative (::std::auto_ptr< TransAccelRelative_type > x)
{
  this->TransAccelRelative_.set (x);
}

const SettingsStatusType::TransSpeedAbsolute_optional& SettingsStatusType::
TransSpeedAbsolute () const
{
  return this->TransSpeedAbsolute_;
}

SettingsStatusType::TransSpeedAbsolute_optional& SettingsStatusType::
TransSpeedAbsolute ()
{
  return this->TransSpeedAbsolute_;
}

void SettingsStatusType::
TransSpeedAbsolute (const TransSpeedAbsolute_type& x)
{
  this->TransSpeedAbsolute_.set (x);
}

void SettingsStatusType::
TransSpeedAbsolute (const TransSpeedAbsolute_optional& x)
{
  this->TransSpeedAbsolute_ = x;
}

void SettingsStatusType::
TransSpeedAbsolute (::std::auto_ptr< TransSpeedAbsolute_type > x)
{
  this->TransSpeedAbsolute_.set (x);
}

const SettingsStatusType::TransSpeedRelative_optional& SettingsStatusType::
TransSpeedRelative () const
{
  return this->TransSpeedRelative_;
}

SettingsStatusType::TransSpeedRelative_optional& SettingsStatusType::
TransSpeedRelative ()
{
  return this->TransSpeedRelative_;
}

void SettingsStatusType::
TransSpeedRelative (const TransSpeedRelative_type& x)
{
  this->TransSpeedRelative_.set (x);
}

void SettingsStatusType::
TransSpeedRelative (const TransSpeedRelative_optional& x)
{
  this->TransSpeedRelative_ = x;
}

void SettingsStatusType::
TransSpeedRelative (::std::auto_ptr< TransSpeedRelative_type > x)
{
  this->TransSpeedRelative_.set (x);
}

const SettingsStatusType::JointTolerances_optional& SettingsStatusType::
JointTolerances () const
{
  return this->JointTolerances_;
}

SettingsStatusType::JointTolerances_optional& SettingsStatusType::
JointTolerances ()
{
  return this->JointTolerances_;
}

void SettingsStatusType::
JointTolerances (const JointTolerances_type& x)
{
  this->JointTolerances_.set (x);
}

void SettingsStatusType::
JointTolerances (const JointTolerances_optional& x)
{
  this->JointTolerances_ = x;
}

void SettingsStatusType::
JointTolerances (::std::auto_ptr< JointTolerances_type > x)
{
  this->JointTolerances_.set (x);
}


// ThreeFingerGripperStatusType
// 

const ThreeFingerGripperStatusType::Finger1Position_optional& ThreeFingerGripperStatusType::
Finger1Position () const
{
  return this->Finger1Position_;
}

ThreeFingerGripperStatusType::Finger1Position_optional& ThreeFingerGripperStatusType::
Finger1Position ()
{
  return this->Finger1Position_;
}

void ThreeFingerGripperStatusType::
Finger1Position (const Finger1Position_type& x)
{
  this->Finger1Position_.set (x);
}

void ThreeFingerGripperStatusType::
Finger1Position (const Finger1Position_optional& x)
{
  this->Finger1Position_ = x;
}

void ThreeFingerGripperStatusType::
Finger1Position (::std::auto_ptr< Finger1Position_type > x)
{
  this->Finger1Position_.set (x);
}

const ThreeFingerGripperStatusType::Finger2Position_optional& ThreeFingerGripperStatusType::
Finger2Position () const
{
  return this->Finger2Position_;
}

ThreeFingerGripperStatusType::Finger2Position_optional& ThreeFingerGripperStatusType::
Finger2Position ()
{
  return this->Finger2Position_;
}

void ThreeFingerGripperStatusType::
Finger2Position (const Finger2Position_type& x)
{
  this->Finger2Position_.set (x);
}

void ThreeFingerGripperStatusType::
Finger2Position (const Finger2Position_optional& x)
{
  this->Finger2Position_ = x;
}

void ThreeFingerGripperStatusType::
Finger2Position (::std::auto_ptr< Finger2Position_type > x)
{
  this->Finger2Position_.set (x);
}

const ThreeFingerGripperStatusType::Finger3Position_optional& ThreeFingerGripperStatusType::
Finger3Position () const
{
  return this->Finger3Position_;
}

ThreeFingerGripperStatusType::Finger3Position_optional& ThreeFingerGripperStatusType::
Finger3Position ()
{
  return this->Finger3Position_;
}

void ThreeFingerGripperStatusType::
Finger3Position (const Finger3Position_type& x)
{
  this->Finger3Position_.set (x);
}

void ThreeFingerGripperStatusType::
Finger3Position (const Finger3Position_optional& x)
{
  this->Finger3Position_ = x;
}

void ThreeFingerGripperStatusType::
Finger3Position (::std::auto_ptr< Finger3Position_type > x)
{
  this->Finger3Position_.set (x);
}

const ThreeFingerGripperStatusType::Finger1Force_optional& ThreeFingerGripperStatusType::
Finger1Force () const
{
  return this->Finger1Force_;
}

ThreeFingerGripperStatusType::Finger1Force_optional& ThreeFingerGripperStatusType::
Finger1Force ()
{
  return this->Finger1Force_;
}

void ThreeFingerGripperStatusType::
Finger1Force (const Finger1Force_type& x)
{
  this->Finger1Force_.set (x);
}

void ThreeFingerGripperStatusType::
Finger1Force (const Finger1Force_optional& x)
{
  this->Finger1Force_ = x;
}

const ThreeFingerGripperStatusType::Finger2Force_optional& ThreeFingerGripperStatusType::
Finger2Force () const
{
  return this->Finger2Force_;
}

ThreeFingerGripperStatusType::Finger2Force_optional& ThreeFingerGripperStatusType::
Finger2Force ()
{
  return this->Finger2Force_;
}

void ThreeFingerGripperStatusType::
Finger2Force (const Finger2Force_type& x)
{
  this->Finger2Force_.set (x);
}

void ThreeFingerGripperStatusType::
Finger2Force (const Finger2Force_optional& x)
{
  this->Finger2Force_ = x;
}

const ThreeFingerGripperStatusType::Finger3Force_optional& ThreeFingerGripperStatusType::
Finger3Force () const
{
  return this->Finger3Force_;
}

ThreeFingerGripperStatusType::Finger3Force_optional& ThreeFingerGripperStatusType::
Finger3Force ()
{
  return this->Finger3Force_;
}

void ThreeFingerGripperStatusType::
Finger3Force (const Finger3Force_type& x)
{
  this->Finger3Force_.set (x);
}

void ThreeFingerGripperStatusType::
Finger3Force (const Finger3Force_optional& x)
{
  this->Finger3Force_ = x;
}


// VacuumGripperStatusType
// 

const VacuumGripperStatusType::IsPowered_type& VacuumGripperStatusType::
IsPowered () const
{
  return this->IsPowered_.get ();
}

VacuumGripperStatusType::IsPowered_type& VacuumGripperStatusType::
IsPowered ()
{
  return this->IsPowered_.get ();
}

void VacuumGripperStatusType::
IsPowered (const IsPowered_type& x)
{
  this->IsPowered_.set (x);
}


// MapType
// 

const MapType::map_type& MapType::
map () const
{
  return this->map_.get ();
}

MapType::map_type& MapType::
map ()
{
  return this->map_.get ();
}

void MapType::
map (const map_type& x)
{
  this->map_.set (x);
}

void MapType::
map (::std::auto_ptr< map_type > x)
{
  this->map_.set (x);
}


// MapItemType
// 

const MapItemType::key_type& MapItemType::
key () const
{
  return this->key_.get ();
}

MapItemType::key_type& MapItemType::
key ()
{
  return this->key_.get ();
}

void MapItemType::
key (const key_type& x)
{
  this->key_.set (x);
}

void MapItemType::
key (::std::auto_ptr< key_type > x)
{
  this->key_.set (x);
}

const MapItemType::value_type& MapItemType::
value () const
{
  return this->value_.get ();
}

MapItemType::value_type& MapItemType::
value ()
{
  return this->value_.get ();
}

void MapItemType::
value (const value_type& x)
{
  this->value_.set (x);
}

void MapItemType::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}

const MapItemType::name_type& MapItemType::
name () const
{
  return this->name_.get ();
}

MapItemType::name_type& MapItemType::
name ()
{
  return this->name_.get ();
}

void MapItemType::
name (const name_type& x)
{
  this->name_.set (x);
}

void MapItemType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// ModelsStatusType
// 

const ModelsStatusType::Name_type& ModelsStatusType::
Name () const
{
  return this->Name_.get ();
}

ModelsStatusType::Name_type& ModelsStatusType::
Name ()
{
  return this->Name_.get ();
}

void ModelsStatusType::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void ModelsStatusType::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const ModelsStatusType::Pose_type& ModelsStatusType::
Pose () const
{
  return this->Pose_.get ();
}

ModelsStatusType::Pose_type& ModelsStatusType::
Pose ()
{
  return this->Pose_.get ();
}

void ModelsStatusType::
Pose (const Pose_type& x)
{
  this->Pose_.set (x);
}

void ModelsStatusType::
Pose (::std::auto_ptr< Pose_type > x)
{
  this->Pose_.set (x);
}

const ModelsStatusType::Twist_optional& ModelsStatusType::
Twist () const
{
  return this->Twist_;
}

ModelsStatusType::Twist_optional& ModelsStatusType::
Twist ()
{
  return this->Twist_;
}

void ModelsStatusType::
Twist (const Twist_type& x)
{
  this->Twist_.set (x);
}

void ModelsStatusType::
Twist (const Twist_optional& x)
{
  this->Twist_ = x;
}

void ModelsStatusType::
Twist (::std::auto_ptr< Twist_type > x)
{
  this->Twist_.set (x);
}

const ModelsStatusType::Wrench_optional& ModelsStatusType::
Wrench () const
{
  return this->Wrench_;
}

ModelsStatusType::Wrench_optional& ModelsStatusType::
Wrench ()
{
  return this->Wrench_;
}

void ModelsStatusType::
Wrench (const Wrench_type& x)
{
  this->Wrench_.set (x);
}

void ModelsStatusType::
Wrench (const Wrench_optional& x)
{
  this->Wrench_ = x;
}

void ModelsStatusType::
Wrench (::std::auto_ptr< Wrench_type > x)
{
  this->Wrench_.set (x);
}

const ModelsStatusType::Properties_optional& ModelsStatusType::
Properties () const
{
  return this->Properties_;
}

ModelsStatusType::Properties_optional& ModelsStatusType::
Properties ()
{
  return this->Properties_;
}

void ModelsStatusType::
Properties (const Properties_type& x)
{
  this->Properties_.set (x);
}

void ModelsStatusType::
Properties (const Properties_optional& x)
{
  this->Properties_ = x;
}

void ModelsStatusType::
Properties (::std::auto_ptr< Properties_type > x)
{
  this->Properties_.set (x);
}


// SensorStatusesType
// 

const SensorStatusesType::OnOffSensorStatus_sequence& SensorStatusesType::
OnOffSensorStatus () const
{
  return this->OnOffSensorStatus_;
}

SensorStatusesType::OnOffSensorStatus_sequence& SensorStatusesType::
OnOffSensorStatus ()
{
  return this->OnOffSensorStatus_;
}

void SensorStatusesType::
OnOffSensorStatus (const OnOffSensorStatus_sequence& s)
{
  this->OnOffSensorStatus_ = s;
}

const SensorStatusesType::ScalarSensorStatus_sequence& SensorStatusesType::
ScalarSensorStatus () const
{
  return this->ScalarSensorStatus_;
}

SensorStatusesType::ScalarSensorStatus_sequence& SensorStatusesType::
ScalarSensorStatus ()
{
  return this->ScalarSensorStatus_;
}

void SensorStatusesType::
ScalarSensorStatus (const ScalarSensorStatus_sequence& s)
{
  this->ScalarSensorStatus_ = s;
}

const SensorStatusesType::CountSensorStatus_sequence& SensorStatusesType::
CountSensorStatus () const
{
  return this->CountSensorStatus_;
}

SensorStatusesType::CountSensorStatus_sequence& SensorStatusesType::
CountSensorStatus ()
{
  return this->CountSensorStatus_;
}

void SensorStatusesType::
CountSensorStatus (const CountSensorStatus_sequence& s)
{
  this->CountSensorStatus_ = s;
}

const SensorStatusesType::ForceTorqueSensorStatus_sequence& SensorStatusesType::
ForceTorqueSensorStatus () const
{
  return this->ForceTorqueSensorStatus_;
}

SensorStatusesType::ForceTorqueSensorStatus_sequence& SensorStatusesType::
ForceTorqueSensorStatus ()
{
  return this->ForceTorqueSensorStatus_;
}

void SensorStatusesType::
ForceTorqueSensorStatus (const ForceTorqueSensorStatus_sequence& s)
{
  this->ForceTorqueSensorStatus_ = s;
}


// GuardsStatusesType
// 

const GuardsStatusesType::Guard_sequence& GuardsStatusesType::
Guard () const
{
  return this->Guard_;
}

GuardsStatusesType::Guard_sequence& GuardsStatusesType::
Guard ()
{
  return this->Guard_;
}

void GuardsStatusesType::
Guard (const Guard_sequence& s)
{
  this->Guard_ = s;
}

const GuardsStatusesType::TriggerCount_type& GuardsStatusesType::
TriggerCount () const
{
  return this->TriggerCount_.get ();
}

GuardsStatusesType::TriggerCount_type& GuardsStatusesType::
TriggerCount ()
{
  return this->TriggerCount_.get ();
}

void GuardsStatusesType::
TriggerCount (const TriggerCount_type& x)
{
  this->TriggerCount_.set (x);
}

const GuardsStatusesType::TriggerStopTimeMicros_type& GuardsStatusesType::
TriggerStopTimeMicros () const
{
  return this->TriggerStopTimeMicros_.get ();
}

GuardsStatusesType::TriggerStopTimeMicros_type& GuardsStatusesType::
TriggerStopTimeMicros ()
{
  return this->TriggerStopTimeMicros_.get ();
}

void GuardsStatusesType::
TriggerStopTimeMicros (const TriggerStopTimeMicros_type& x)
{
  this->TriggerStopTimeMicros_.set (x);
}

const GuardsStatusesType::TriggerValue_optional& GuardsStatusesType::
TriggerValue () const
{
  return this->TriggerValue_;
}

GuardsStatusesType::TriggerValue_optional& GuardsStatusesType::
TriggerValue ()
{
  return this->TriggerValue_;
}

void GuardsStatusesType::
TriggerValue (const TriggerValue_type& x)
{
  this->TriggerValue_.set (x);
}

void GuardsStatusesType::
TriggerValue (const TriggerValue_optional& x)
{
  this->TriggerValue_ = x;
}

const GuardsStatusesType::TriggerPose_optional& GuardsStatusesType::
TriggerPose () const
{
  return this->TriggerPose_;
}

GuardsStatusesType::TriggerPose_optional& GuardsStatusesType::
TriggerPose ()
{
  return this->TriggerPose_;
}

void GuardsStatusesType::
TriggerPose (const TriggerPose_type& x)
{
  this->TriggerPose_.set (x);
}

void GuardsStatusesType::
TriggerPose (const TriggerPose_optional& x)
{
  this->TriggerPose_ = x;
}

void GuardsStatusesType::
TriggerPose (::std::auto_ptr< TriggerPose_type > x)
{
  this->TriggerPose_.set (x);
}


// SensorStatusType
// 

const SensorStatusType::SensorID_type& SensorStatusType::
SensorID () const
{
  return this->SensorID_.get ();
}

SensorStatusType::SensorID_type& SensorStatusType::
SensorID ()
{
  return this->SensorID_.get ();
}

void SensorStatusType::
SensorID (const SensorID_type& x)
{
  this->SensorID_.set (x);
}

void SensorStatusType::
SensorID (::std::auto_ptr< SensorID_type > x)
{
  this->SensorID_.set (x);
}

const SensorStatusType::ReadCount_type& SensorStatusType::
ReadCount () const
{
  return this->ReadCount_.get ();
}

SensorStatusType::ReadCount_type& SensorStatusType::
ReadCount ()
{
  return this->ReadCount_.get ();
}

void SensorStatusType::
ReadCount (const ReadCount_type& x)
{
  this->ReadCount_.set (x);
}

const SensorStatusType::LastReadTime_type& SensorStatusType::
LastReadTime () const
{
  return this->LastReadTime_.get ();
}

SensorStatusType::LastReadTime_type& SensorStatusType::
LastReadTime ()
{
  return this->LastReadTime_.get ();
}

void SensorStatusType::
LastReadTime (const LastReadTime_type& x)
{
  this->LastReadTime_.set (x);
}

const SensorStatusType::SensorParameterSetting_sequence& SensorStatusType::
SensorParameterSetting () const
{
  return this->SensorParameterSetting_;
}

SensorStatusType::SensorParameterSetting_sequence& SensorStatusType::
SensorParameterSetting ()
{
  return this->SensorParameterSetting_;
}

void SensorStatusType::
SensorParameterSetting (const SensorParameterSetting_sequence& s)
{
  this->SensorParameterSetting_ = s;
}


// OnOffSensorStatusType
// 

const OnOffSensorStatusType::On_type& OnOffSensorStatusType::
On () const
{
  return this->On_.get ();
}

OnOffSensorStatusType::On_type& OnOffSensorStatusType::
On ()
{
  return this->On_.get ();
}

void OnOffSensorStatusType::
On (const On_type& x)
{
  this->On_.set (x);
}


// ForceTorqueSensorStatusType
// 

const ForceTorqueSensorStatusType::Fx_type& ForceTorqueSensorStatusType::
Fx () const
{
  return this->Fx_.get ();
}

ForceTorqueSensorStatusType::Fx_type& ForceTorqueSensorStatusType::
Fx ()
{
  return this->Fx_.get ();
}

void ForceTorqueSensorStatusType::
Fx (const Fx_type& x)
{
  this->Fx_.set (x);
}

const ForceTorqueSensorStatusType::Fy_type& ForceTorqueSensorStatusType::
Fy () const
{
  return this->Fy_.get ();
}

ForceTorqueSensorStatusType::Fy_type& ForceTorqueSensorStatusType::
Fy ()
{
  return this->Fy_.get ();
}

void ForceTorqueSensorStatusType::
Fy (const Fy_type& x)
{
  this->Fy_.set (x);
}

const ForceTorqueSensorStatusType::Fz_type& ForceTorqueSensorStatusType::
Fz () const
{
  return this->Fz_.get ();
}

ForceTorqueSensorStatusType::Fz_type& ForceTorqueSensorStatusType::
Fz ()
{
  return this->Fz_.get ();
}

void ForceTorqueSensorStatusType::
Fz (const Fz_type& x)
{
  this->Fz_.set (x);
}

const ForceTorqueSensorStatusType::Tx_type& ForceTorqueSensorStatusType::
Tx () const
{
  return this->Tx_.get ();
}

ForceTorqueSensorStatusType::Tx_type& ForceTorqueSensorStatusType::
Tx ()
{
  return this->Tx_.get ();
}

void ForceTorqueSensorStatusType::
Tx (const Tx_type& x)
{
  this->Tx_.set (x);
}

const ForceTorqueSensorStatusType::Ty_type& ForceTorqueSensorStatusType::
Ty () const
{
  return this->Ty_.get ();
}

ForceTorqueSensorStatusType::Ty_type& ForceTorqueSensorStatusType::
Ty ()
{
  return this->Ty_.get ();
}

void ForceTorqueSensorStatusType::
Ty (const Ty_type& x)
{
  this->Ty_.set (x);
}

const ForceTorqueSensorStatusType::Tz_type& ForceTorqueSensorStatusType::
Tz () const
{
  return this->Tz_.get ();
}

ForceTorqueSensorStatusType::Tz_type& ForceTorqueSensorStatusType::
Tz ()
{
  return this->Tz_.get ();
}

void ForceTorqueSensorStatusType::
Tz (const Tz_type& x)
{
  this->Tz_.set (x);
}


// ScalarSensorStatusType
// 

const ScalarSensorStatusType::ScalarValue__type& ScalarSensorStatusType::
ScalarValue_ () const
{
  return this->ScalarValue__.get ();
}

ScalarSensorStatusType::ScalarValue__type& ScalarSensorStatusType::
ScalarValue_ ()
{
  return this->ScalarValue__.get ();
}

void ScalarSensorStatusType::
ScalarValue_ (const ScalarValue__type& x)
{
  this->ScalarValue__.set (x);
}


// CountSensorStatusType
// 

const CountSensorStatusType::CountValue__type& CountSensorStatusType::
CountValue_ () const
{
  return this->CountValue__.get ();
}

CountSensorStatusType::CountValue__type& CountSensorStatusType::
CountValue_ ()
{
  return this->CountValue__.get ();
}

void CountSensorStatusType::
CountValue_ (const CountValue__type& x)
{
  this->CountValue__.set (x);
}


// map
// 

const map::item_sequence& map::
item () const
{
  return this->item_;
}

map::item_sequence& map::
item ()
{
  return this->item_;
}

void map::
item (const item_sequence& s)
{
  this->item_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

// CommandStateEnumType
//

CommandStateEnumType::
CommandStateEnumType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_CommandStateEnumType_convert ();
}

CommandStateEnumType::
CommandStateEnumType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_CommandStateEnumType_convert ();
}

CommandStateEnumType::
CommandStateEnumType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_CommandStateEnumType_convert ();
}

CommandStateEnumType* CommandStateEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CommandStateEnumType (*this, f, c);
}

CommandStateEnumType::value CommandStateEnumType::
_xsd_CommandStateEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CommandStateEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_CommandStateEnumType_indexes_,
                    _xsd_CommandStateEnumType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_CommandStateEnumType_indexes_ + 4 || _xsd_CommandStateEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const CommandStateEnumType::
_xsd_CommandStateEnumType_literals_[4] =
{
  "CRCL_Done",
  "CRCL_Error",
  "CRCL_Working",
  "CRCL_Ready"
};

const CommandStateEnumType::value CommandStateEnumType::
_xsd_CommandStateEnumType_indexes_[4] =
{
  ::CommandStateEnumType::CRCL_Done,
  ::CommandStateEnumType::CRCL_Error,
  ::CommandStateEnumType::CRCL_Ready,
  ::CommandStateEnumType::CRCL_Working
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CommandStateEnumType >
_xsd_CommandStateEnumType_type_factory_init (
  "CommandStateEnumType",
  "");

// CommandStatusType
//

CommandStatusType::
CommandStatusType (const CommandID_type& CommandID,
                   const StatusID_type& StatusID,
                   const CommandState_type& CommandState)
: ::DataThingType (),
  CommandID_ (CommandID, this),
  StatusID_ (StatusID, this),
  CommandState_ (CommandState, this),
  StateDescription_ (this),
  ProgramFile_ (this),
  ProgramIndex_ (this),
  ProgramLength_ (this),
  OverridePercent_ (this)
{
}

CommandStatusType::
CommandStatusType (const CommandID_type& CommandID,
                   const StatusID_type& StatusID,
                   ::std::auto_ptr< CommandState_type > CommandState)
: ::DataThingType (),
  CommandID_ (CommandID, this),
  StatusID_ (StatusID, this),
  CommandState_ (CommandState, this),
  StateDescription_ (this),
  ProgramFile_ (this),
  ProgramIndex_ (this),
  ProgramLength_ (this),
  OverridePercent_ (this)
{
}

CommandStatusType::
CommandStatusType (const CommandStatusType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  CommandID_ (x.CommandID_, f, this),
  StatusID_ (x.StatusID_, f, this),
  CommandState_ (x.CommandState_, f, this),
  StateDescription_ (x.StateDescription_, f, this),
  ProgramFile_ (x.ProgramFile_, f, this),
  ProgramIndex_ (x.ProgramIndex_, f, this),
  ProgramLength_ (x.ProgramLength_, f, this),
  OverridePercent_ (x.OverridePercent_, f, this)
{
}

CommandStatusType::
CommandStatusType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  CommandID_ (this),
  StatusID_ (this),
  CommandState_ (this),
  StateDescription_ (this),
  ProgramFile_ (this),
  ProgramIndex_ (this),
  ProgramLength_ (this),
  OverridePercent_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CommandStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CommandID
    //
    if (n.name () == "CommandID" && n.namespace_ ().empty ())
    {
      if (!CommandID_.present ())
      {
        this->CommandID_.set (CommandID_traits::create (i, f, this));
        continue;
      }
    }

    // StatusID
    //
    if (n.name () == "StatusID" && n.namespace_ ().empty ())
    {
      if (!StatusID_.present ())
      {
        this->StatusID_.set (StatusID_traits::create (i, f, this));
        continue;
      }
    }

    // CommandState
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "CommandState",
          "",
          &::xsd::cxx::tree::factory_impl< CommandState_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!CommandState_.present ())
        {
          ::std::auto_ptr< CommandState_type > r (
            dynamic_cast< CommandState_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CommandState_.set (r);
          continue;
        }
      }
    }

    // StateDescription
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "StateDescription",
          "",
          &::xsd::cxx::tree::factory_impl< StateDescription_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->StateDescription_)
        {
          ::std::auto_ptr< StateDescription_type > r (
            dynamic_cast< StateDescription_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->StateDescription_.set (r);
          continue;
        }
      }
    }

    // ProgramFile
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ProgramFile",
          "",
          &::xsd::cxx::tree::factory_impl< ProgramFile_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->ProgramFile_)
        {
          ::std::auto_ptr< ProgramFile_type > r (
            dynamic_cast< ProgramFile_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ProgramFile_.set (r);
          continue;
        }
      }
    }

    // ProgramIndex
    //
    if (n.name () == "ProgramIndex" && n.namespace_ ().empty ())
    {
      if (!this->ProgramIndex_)
      {
        this->ProgramIndex_.set (ProgramIndex_traits::create (i, f, this));
        continue;
      }
    }

    // ProgramLength
    //
    if (n.name () == "ProgramLength" && n.namespace_ ().empty ())
    {
      if (!this->ProgramLength_)
      {
        this->ProgramLength_.set (ProgramLength_traits::create (i, f, this));
        continue;
      }
    }

    // OverridePercent
    //
    if (n.name () == "OverridePercent" && n.namespace_ ().empty ())
    {
      if (!this->OverridePercent_)
      {
        this->OverridePercent_.set (OverridePercent_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!CommandID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CommandID",
      "");
  }

  if (!StatusID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "StatusID",
      "");
  }

  if (!CommandState_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CommandState",
      "");
  }
}

CommandStatusType* CommandStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CommandStatusType (*this, f, c);
}

CommandStatusType& CommandStatusType::
operator= (const CommandStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->CommandID_ = x.CommandID_;
    this->StatusID_ = x.StatusID_;
    this->CommandState_ = x.CommandState_;
    this->StateDescription_ = x.StateDescription_;
    this->ProgramFile_ = x.ProgramFile_;
    this->ProgramIndex_ = x.ProgramIndex_;
    this->ProgramLength_ = x.ProgramLength_;
    this->OverridePercent_ = x.OverridePercent_;
  }

  return *this;
}

CommandStatusType::
~CommandStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CommandStatusType >
_xsd_CommandStatusType_type_factory_init (
  "CommandStatusType",
  "");

// CRCLStatusType
//

CRCLStatusType::
CRCLStatusType (const CommandStatus_type& CommandStatus)
: ::DataThingType (),
  CommandStatus_ (CommandStatus, this),
  JointStatuses_ (this),
  PoseStatus_ (this),
  GripperStatus_ (this),
  SettingsStatus_ (this),
  SensorStatuses_ (this),
  GuardsStatuses_ (this),
  ModelStatus_ (this)
{
}

CRCLStatusType::
CRCLStatusType (::std::auto_ptr< CommandStatus_type > CommandStatus)
: ::DataThingType (),
  CommandStatus_ (CommandStatus, this),
  JointStatuses_ (this),
  PoseStatus_ (this),
  GripperStatus_ (this),
  SettingsStatus_ (this),
  SensorStatuses_ (this),
  GuardsStatuses_ (this),
  ModelStatus_ (this)
{
}

CRCLStatusType::
CRCLStatusType (const CRCLStatusType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  CommandStatus_ (x.CommandStatus_, f, this),
  JointStatuses_ (x.JointStatuses_, f, this),
  PoseStatus_ (x.PoseStatus_, f, this),
  GripperStatus_ (x.GripperStatus_, f, this),
  SettingsStatus_ (x.SettingsStatus_, f, this),
  SensorStatuses_ (x.SensorStatuses_, f, this),
  GuardsStatuses_ (x.GuardsStatuses_, f, this),
  ModelStatus_ (x.ModelStatus_, f, this)
{
}

CRCLStatusType::
CRCLStatusType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  CommandStatus_ (this),
  JointStatuses_ (this),
  PoseStatus_ (this),
  GripperStatus_ (this),
  SettingsStatus_ (this),
  SensorStatuses_ (this),
  GuardsStatuses_ (this),
  ModelStatus_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CRCLStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CommandStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "CommandStatus",
          "",
          &::xsd::cxx::tree::factory_impl< CommandStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!CommandStatus_.present ())
        {
          ::std::auto_ptr< CommandStatus_type > r (
            dynamic_cast< CommandStatus_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CommandStatus_.set (r);
          continue;
        }
      }
    }

    // JointStatuses
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointStatuses",
          "",
          &::xsd::cxx::tree::factory_impl< JointStatuses_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->JointStatuses_)
        {
          ::std::auto_ptr< JointStatuses_type > r (
            dynamic_cast< JointStatuses_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->JointStatuses_.set (r);
          continue;
        }
      }
    }

    // PoseStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "PoseStatus",
          "",
          &::xsd::cxx::tree::factory_impl< PoseStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->PoseStatus_)
        {
          ::std::auto_ptr< PoseStatus_type > r (
            dynamic_cast< PoseStatus_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->PoseStatus_.set (r);
          continue;
        }
      }
    }

    // GripperStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GripperStatus",
          "",
          &::xsd::cxx::tree::factory_impl< GripperStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->GripperStatus_)
        {
          ::std::auto_ptr< GripperStatus_type > r (
            dynamic_cast< GripperStatus_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->GripperStatus_.set (r);
          continue;
        }
      }
    }

    // SettingsStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "SettingsStatus",
          "",
          &::xsd::cxx::tree::factory_impl< SettingsStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->SettingsStatus_)
        {
          ::std::auto_ptr< SettingsStatus_type > r (
            dynamic_cast< SettingsStatus_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->SettingsStatus_.set (r);
          continue;
        }
      }
    }

    // SensorStatuses
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "SensorStatuses",
          "",
          &::xsd::cxx::tree::factory_impl< SensorStatuses_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->SensorStatuses_)
        {
          ::std::auto_ptr< SensorStatuses_type > r (
            dynamic_cast< SensorStatuses_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->SensorStatuses_.set (r);
          continue;
        }
      }
    }

    // GuardsStatuses
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GuardsStatuses",
          "",
          &::xsd::cxx::tree::factory_impl< GuardsStatuses_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->GuardsStatuses_)
        {
          ::std::auto_ptr< GuardsStatuses_type > r (
            dynamic_cast< GuardsStatuses_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->GuardsStatuses_.set (r);
          continue;
        }
      }
    }

    // ModelStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ModelStatus",
          "",
          &::xsd::cxx::tree::factory_impl< ModelStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ModelStatus_type > r (
          dynamic_cast< ModelStatus_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->ModelStatus_.push_back (r);
        continue;
      }
    }

    break;
  }

  if (!CommandStatus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CommandStatus",
      "");
  }
}

CRCLStatusType* CRCLStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CRCLStatusType (*this, f, c);
}

CRCLStatusType& CRCLStatusType::
operator= (const CRCLStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->CommandStatus_ = x.CommandStatus_;
    this->JointStatuses_ = x.JointStatuses_;
    this->PoseStatus_ = x.PoseStatus_;
    this->GripperStatus_ = x.GripperStatus_;
    this->SettingsStatus_ = x.SettingsStatus_;
    this->SensorStatuses_ = x.SensorStatuses_;
    this->GuardsStatuses_ = x.GuardsStatuses_;
    this->ModelStatus_ = x.ModelStatus_;
  }

  return *this;
}

CRCLStatusType::
~CRCLStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CRCLStatusType >
_xsd_CRCLStatusType_type_factory_init (
  "CRCLStatusType",
  "");

// GripperStatusType
//

GripperStatusType::
GripperStatusType (const GripperName_type& GripperName)
: ::DataThingType (),
  GripperName_ (GripperName, this),
  GripperOption_ (this),
  HoldingObject_ (this)
{
}

GripperStatusType::
GripperStatusType (::std::auto_ptr< GripperName_type > GripperName)
: ::DataThingType (),
  GripperName_ (GripperName, this),
  GripperOption_ (this),
  HoldingObject_ (this)
{
}

GripperStatusType::
GripperStatusType (const GripperStatusType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  GripperName_ (x.GripperName_, f, this),
  GripperOption_ (x.GripperOption_, f, this),
  HoldingObject_ (x.HoldingObject_, f, this)
{
}

GripperStatusType::
GripperStatusType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  GripperName_ (this),
  GripperOption_ (this),
  HoldingObject_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void GripperStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // GripperName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GripperName",
          "",
          &::xsd::cxx::tree::factory_impl< GripperName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!GripperName_.present ())
        {
          ::std::auto_ptr< GripperName_type > r (
            dynamic_cast< GripperName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->GripperName_.set (r);
          continue;
        }
      }
    }

    // GripperOption
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GripperOption",
          "",
          &::xsd::cxx::tree::factory_impl< GripperOption_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< GripperOption_type > r (
          dynamic_cast< GripperOption_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->GripperOption_.push_back (r);
        continue;
      }
    }

    // HoldingObject
    //
    if (n.name () == "HoldingObject" && n.namespace_ ().empty ())
    {
      if (!this->HoldingObject_)
      {
        this->HoldingObject_.set (HoldingObject_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!GripperName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "GripperName",
      "");
  }
}

GripperStatusType* GripperStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GripperStatusType (*this, f, c);
}

GripperStatusType& GripperStatusType::
operator= (const GripperStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->GripperName_ = x.GripperName_;
    this->GripperOption_ = x.GripperOption_;
    this->HoldingObject_ = x.HoldingObject_;
  }

  return *this;
}

GripperStatusType::
~GripperStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GripperStatusType >
_xsd_GripperStatusType_type_factory_init (
  "GripperStatusType",
  "");

// JointStatusesType
//

JointStatusesType::
JointStatusesType ()
: ::DataThingType (),
  JointStatus_ (this)
{
}

JointStatusesType::
JointStatusesType (const JointStatusesType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  JointStatus_ (x.JointStatus_, f, this)
{
}

JointStatusesType::
JointStatusesType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  JointStatus_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void JointStatusesType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointStatus",
          "",
          &::xsd::cxx::tree::factory_impl< JointStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< JointStatus_type > r (
          dynamic_cast< JointStatus_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->JointStatus_.push_back (r);
        continue;
      }
    }

    break;
  }
}

JointStatusesType* JointStatusesType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointStatusesType (*this, f, c);
}

JointStatusesType& JointStatusesType::
operator= (const JointStatusesType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->JointStatus_ = x.JointStatus_;
  }

  return *this;
}

JointStatusesType::
~JointStatusesType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointStatusesType >
_xsd_JointStatusesType_type_factory_init (
  "JointStatusesType",
  "");

// JointStatusType
//

JointStatusType::
JointStatusType (const JointNumber_type& JointNumber)
: ::DataThingType (),
  JointNumber_ (JointNumber, this),
  JointPosition_ (this),
  JointTorqueOrForce_ (this),
  JointVelocity_ (this)
{
}

JointStatusType::
JointStatusType (const JointStatusType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  JointNumber_ (x.JointNumber_, f, this),
  JointPosition_ (x.JointPosition_, f, this),
  JointTorqueOrForce_ (x.JointTorqueOrForce_, f, this),
  JointVelocity_ (x.JointVelocity_, f, this)
{
}

JointStatusType::
JointStatusType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  JointNumber_ (this),
  JointPosition_ (this),
  JointTorqueOrForce_ (this),
  JointVelocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void JointStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointNumber
    //
    if (n.name () == "JointNumber" && n.namespace_ ().empty ())
    {
      if (!JointNumber_.present ())
      {
        this->JointNumber_.set (JointNumber_traits::create (i, f, this));
        continue;
      }
    }

    // JointPosition
    //
    if (n.name () == "JointPosition" && n.namespace_ ().empty ())
    {
      if (!this->JointPosition_)
      {
        this->JointPosition_.set (JointPosition_traits::create (i, f, this));
        continue;
      }
    }

    // JointTorqueOrForce
    //
    if (n.name () == "JointTorqueOrForce" && n.namespace_ ().empty ())
    {
      if (!this->JointTorqueOrForce_)
      {
        this->JointTorqueOrForce_.set (JointTorqueOrForce_traits::create (i, f, this));
        continue;
      }
    }

    // JointVelocity
    //
    if (n.name () == "JointVelocity" && n.namespace_ ().empty ())
    {
      if (!this->JointVelocity_)
      {
        this->JointVelocity_.set (JointVelocity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!JointNumber_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointNumber",
      "");
  }
}

JointStatusType* JointStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointStatusType (*this, f, c);
}

JointStatusType& JointStatusType::
operator= (const JointStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->JointNumber_ = x.JointNumber_;
    this->JointPosition_ = x.JointPosition_;
    this->JointTorqueOrForce_ = x.JointTorqueOrForce_;
    this->JointVelocity_ = x.JointVelocity_;
  }

  return *this;
}

JointStatusType::
~JointStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointStatusType >
_xsd_JointStatusType_type_factory_init (
  "JointStatusType",
  "");

// JointLimitType
//

JointLimitType::
JointLimitType (const JointNumber_type& JointNumber)
: ::DataThingType (),
  JointNumber_ (JointNumber, this),
  JointMinPosition_ (this),
  JointMaxPosition_ (this),
  JointMaxTorqueOrForce_ (this),
  JointMaxVelocity_ (this)
{
}

JointLimitType::
JointLimitType (const JointLimitType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  JointNumber_ (x.JointNumber_, f, this),
  JointMinPosition_ (x.JointMinPosition_, f, this),
  JointMaxPosition_ (x.JointMaxPosition_, f, this),
  JointMaxTorqueOrForce_ (x.JointMaxTorqueOrForce_, f, this),
  JointMaxVelocity_ (x.JointMaxVelocity_, f, this)
{
}

JointLimitType::
JointLimitType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  JointNumber_ (this),
  JointMinPosition_ (this),
  JointMaxPosition_ (this),
  JointMaxTorqueOrForce_ (this),
  JointMaxVelocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void JointLimitType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointNumber
    //
    if (n.name () == "JointNumber" && n.namespace_ ().empty ())
    {
      if (!JointNumber_.present ())
      {
        this->JointNumber_.set (JointNumber_traits::create (i, f, this));
        continue;
      }
    }

    // JointMinPosition
    //
    if (n.name () == "JointMinPosition" && n.namespace_ ().empty ())
    {
      if (!this->JointMinPosition_)
      {
        this->JointMinPosition_.set (JointMinPosition_traits::create (i, f, this));
        continue;
      }
    }

    // JointMaxPosition
    //
    if (n.name () == "JointMaxPosition" && n.namespace_ ().empty ())
    {
      if (!this->JointMaxPosition_)
      {
        this->JointMaxPosition_.set (JointMaxPosition_traits::create (i, f, this));
        continue;
      }
    }

    // JointMaxTorqueOrForce
    //
    if (n.name () == "JointMaxTorqueOrForce" && n.namespace_ ().empty ())
    {
      if (!this->JointMaxTorqueOrForce_)
      {
        this->JointMaxTorqueOrForce_.set (JointMaxTorqueOrForce_traits::create (i, f, this));
        continue;
      }
    }

    // JointMaxVelocity
    //
    if (n.name () == "JointMaxVelocity" && n.namespace_ ().empty ())
    {
      if (!this->JointMaxVelocity_)
      {
        this->JointMaxVelocity_.set (JointMaxVelocity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!JointNumber_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointNumber",
      "");
  }
}

JointLimitType* JointLimitType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointLimitType (*this, f, c);
}

JointLimitType& JointLimitType::
operator= (const JointLimitType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->JointNumber_ = x.JointNumber_;
    this->JointMinPosition_ = x.JointMinPosition_;
    this->JointMaxPosition_ = x.JointMaxPosition_;
    this->JointMaxTorqueOrForce_ = x.JointMaxTorqueOrForce_;
    this->JointMaxVelocity_ = x.JointMaxVelocity_;
  }

  return *this;
}

JointLimitType::
~JointLimitType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointLimitType >
_xsd_JointLimitType_type_factory_init (
  "JointLimitType",
  "");

// ParallelGripperStatusType
//

ParallelGripperStatusType::
ParallelGripperStatusType (const ::GripperStatusType& _xsd_GripperStatusType_base,
                           const Separation_type& Separation)
: ::GripperStatusType (_xsd_GripperStatusType_base),
  Separation_ (Separation, this)
{
}

ParallelGripperStatusType::
ParallelGripperStatusType (const GripperName_type& GripperName,
                           const Separation_type& Separation)
: ::GripperStatusType (GripperName),
  Separation_ (Separation, this)
{
}

ParallelGripperStatusType::
ParallelGripperStatusType (::std::auto_ptr< GripperName_type > GripperName,
                           const Separation_type& Separation)
: ::GripperStatusType (GripperName),
  Separation_ (Separation, this)
{
}

ParallelGripperStatusType::
ParallelGripperStatusType (const ParallelGripperStatusType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::GripperStatusType (x, f, c),
  Separation_ (x.Separation_, f, this)
{
}

ParallelGripperStatusType::
ParallelGripperStatusType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::GripperStatusType (e, f | ::xml_schema::flags::base, c),
  Separation_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ParallelGripperStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GripperStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Separation
    //
    if (n.name () == "Separation" && n.namespace_ ().empty ())
    {
      if (!Separation_.present ())
      {
        this->Separation_.set (Separation_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Separation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Separation",
      "");
  }
}

ParallelGripperStatusType* ParallelGripperStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParallelGripperStatusType (*this, f, c);
}

ParallelGripperStatusType& ParallelGripperStatusType::
operator= (const ParallelGripperStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::GripperStatusType& > (*this) = x;
    this->Separation_ = x.Separation_;
  }

  return *this;
}

ParallelGripperStatusType::
~ParallelGripperStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParallelGripperStatusType >
_xsd_ParallelGripperStatusType_type_factory_init (
  "ParallelGripperStatusType",
  "");

// PoseStatusType
//

PoseStatusType::
PoseStatusType (const Pose_type& Pose)
: ::DataThingType (),
  Pose_ (Pose, this),
  Twist_ (this),
  Wrench_ (this),
  Configuration_ (this)
{
}

PoseStatusType::
PoseStatusType (::std::auto_ptr< Pose_type > Pose)
: ::DataThingType (),
  Pose_ (Pose, this),
  Twist_ (this),
  Wrench_ (this),
  Configuration_ (this)
{
}

PoseStatusType::
PoseStatusType (const PoseStatusType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  Pose_ (x.Pose_, f, this),
  Twist_ (x.Twist_, f, this),
  Wrench_ (x.Wrench_, f, this),
  Configuration_ (x.Configuration_, f, this)
{
}

PoseStatusType::
PoseStatusType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  Pose_ (this),
  Twist_ (this),
  Wrench_ (this),
  Configuration_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PoseStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Pose
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Pose",
          "",
          &::xsd::cxx::tree::factory_impl< Pose_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Pose_.present ())
        {
          ::std::auto_ptr< Pose_type > r (
            dynamic_cast< Pose_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Pose_.set (r);
          continue;
        }
      }
    }

    // Twist
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Twist",
          "",
          &::xsd::cxx::tree::factory_impl< Twist_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Twist_)
        {
          ::std::auto_ptr< Twist_type > r (
            dynamic_cast< Twist_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Twist_.set (r);
          continue;
        }
      }
    }

    // Wrench
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Wrench",
          "",
          &::xsd::cxx::tree::factory_impl< Wrench_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Wrench_)
        {
          ::std::auto_ptr< Wrench_type > r (
            dynamic_cast< Wrench_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Wrench_.set (r);
          continue;
        }
      }
    }

    // Configuration
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Configuration",
          "",
          &::xsd::cxx::tree::factory_impl< Configuration_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Configuration_)
        {
          ::std::auto_ptr< Configuration_type > r (
            dynamic_cast< Configuration_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Configuration_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Pose_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pose",
      "");
  }
}

PoseStatusType* PoseStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PoseStatusType (*this, f, c);
}

PoseStatusType& PoseStatusType::
operator= (const PoseStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->Pose_ = x.Pose_;
    this->Twist_ = x.Twist_;
    this->Wrench_ = x.Wrench_;
    this->Configuration_ = x.Configuration_;
  }

  return *this;
}

PoseStatusType::
~PoseStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, PoseStatusType >
_xsd_PoseStatusType_type_factory_init (
  "PoseStatusType",
  "");

// SettingsStatusType
//

SettingsStatusType::
SettingsStatusType ()
: ::DataThingType (),
  AngleUnitName_ (this),
  EndEffectorParameterSetting_ (this),
  EndEffectorSetting_ (this),
  ForceUnitName_ (this),
  JointLimits_ (this),
  IntermediatePoseTolerance_ (this),
  LengthUnitName_ (this),
  MaxCartesianLimit_ (this),
  MinCartesianLimit_ (this),
  MotionCoordinated_ (this),
  EndPoseTolerance_ (this),
  RobotParameterSetting_ (this),
  RotAccelAbsolute_ (this),
  RotAccelRelative_ (this),
  RotSpeedAbsolute_ (this),
  RotSpeedRelative_ (this),
  TorqueUnitName_ (this),
  TransAccelAbsolute_ (this),
  TransAccelRelative_ (this),
  TransSpeedAbsolute_ (this),
  TransSpeedRelative_ (this),
  JointTolerances_ (this)
{
}

SettingsStatusType::
SettingsStatusType (const SettingsStatusType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  AngleUnitName_ (x.AngleUnitName_, f, this),
  EndEffectorParameterSetting_ (x.EndEffectorParameterSetting_, f, this),
  EndEffectorSetting_ (x.EndEffectorSetting_, f, this),
  ForceUnitName_ (x.ForceUnitName_, f, this),
  JointLimits_ (x.JointLimits_, f, this),
  IntermediatePoseTolerance_ (x.IntermediatePoseTolerance_, f, this),
  LengthUnitName_ (x.LengthUnitName_, f, this),
  MaxCartesianLimit_ (x.MaxCartesianLimit_, f, this),
  MinCartesianLimit_ (x.MinCartesianLimit_, f, this),
  MotionCoordinated_ (x.MotionCoordinated_, f, this),
  EndPoseTolerance_ (x.EndPoseTolerance_, f, this),
  RobotParameterSetting_ (x.RobotParameterSetting_, f, this),
  RotAccelAbsolute_ (x.RotAccelAbsolute_, f, this),
  RotAccelRelative_ (x.RotAccelRelative_, f, this),
  RotSpeedAbsolute_ (x.RotSpeedAbsolute_, f, this),
  RotSpeedRelative_ (x.RotSpeedRelative_, f, this),
  TorqueUnitName_ (x.TorqueUnitName_, f, this),
  TransAccelAbsolute_ (x.TransAccelAbsolute_, f, this),
  TransAccelRelative_ (x.TransAccelRelative_, f, this),
  TransSpeedAbsolute_ (x.TransSpeedAbsolute_, f, this),
  TransSpeedRelative_ (x.TransSpeedRelative_, f, this),
  JointTolerances_ (x.JointTolerances_, f, this)
{
}

SettingsStatusType::
SettingsStatusType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  AngleUnitName_ (this),
  EndEffectorParameterSetting_ (this),
  EndEffectorSetting_ (this),
  ForceUnitName_ (this),
  JointLimits_ (this),
  IntermediatePoseTolerance_ (this),
  LengthUnitName_ (this),
  MaxCartesianLimit_ (this),
  MinCartesianLimit_ (this),
  MotionCoordinated_ (this),
  EndPoseTolerance_ (this),
  RobotParameterSetting_ (this),
  RotAccelAbsolute_ (this),
  RotAccelRelative_ (this),
  RotSpeedAbsolute_ (this),
  RotSpeedRelative_ (this),
  TorqueUnitName_ (this),
  TransAccelAbsolute_ (this),
  TransAccelRelative_ (this),
  TransSpeedAbsolute_ (this),
  TransSpeedRelative_ (this),
  JointTolerances_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SettingsStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AngleUnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "AngleUnitName",
          "",
          &::xsd::cxx::tree::factory_impl< AngleUnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->AngleUnitName_)
        {
          ::std::auto_ptr< AngleUnitName_type > r (
            dynamic_cast< AngleUnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AngleUnitName_.set (r);
          continue;
        }
      }
    }

    // EndEffectorParameterSetting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "EndEffectorParameterSetting",
          "",
          &::xsd::cxx::tree::factory_impl< EndEffectorParameterSetting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< EndEffectorParameterSetting_type > r (
          dynamic_cast< EndEffectorParameterSetting_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->EndEffectorParameterSetting_.push_back (r);
        continue;
      }
    }

    // EndEffectorSetting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "EndEffectorSetting",
          "",
          &::xsd::cxx::tree::factory_impl< EndEffectorSetting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->EndEffectorSetting_)
        {
          ::std::auto_ptr< EndEffectorSetting_type > r (
            dynamic_cast< EndEffectorSetting_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->EndEffectorSetting_.set (r);
          continue;
        }
      }
    }

    // ForceUnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ForceUnitName",
          "",
          &::xsd::cxx::tree::factory_impl< ForceUnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->ForceUnitName_)
        {
          ::std::auto_ptr< ForceUnitName_type > r (
            dynamic_cast< ForceUnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ForceUnitName_.set (r);
          continue;
        }
      }
    }

    // JointLimits
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointLimits",
          "",
          &::xsd::cxx::tree::factory_impl< JointLimits_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< JointLimits_type > r (
          dynamic_cast< JointLimits_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->JointLimits_.push_back (r);
        continue;
      }
    }

    // IntermediatePoseTolerance
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IntermediatePoseTolerance",
          "",
          &::xsd::cxx::tree::factory_impl< IntermediatePoseTolerance_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->IntermediatePoseTolerance_)
        {
          ::std::auto_ptr< IntermediatePoseTolerance_type > r (
            dynamic_cast< IntermediatePoseTolerance_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->IntermediatePoseTolerance_.set (r);
          continue;
        }
      }
    }

    // LengthUnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "LengthUnitName",
          "",
          &::xsd::cxx::tree::factory_impl< LengthUnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->LengthUnitName_)
        {
          ::std::auto_ptr< LengthUnitName_type > r (
            dynamic_cast< LengthUnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->LengthUnitName_.set (r);
          continue;
        }
      }
    }

    // MaxCartesianLimit
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "MaxCartesianLimit",
          "",
          &::xsd::cxx::tree::factory_impl< MaxCartesianLimit_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->MaxCartesianLimit_)
        {
          ::std::auto_ptr< MaxCartesianLimit_type > r (
            dynamic_cast< MaxCartesianLimit_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->MaxCartesianLimit_.set (r);
          continue;
        }
      }
    }

    // MinCartesianLimit
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "MinCartesianLimit",
          "",
          &::xsd::cxx::tree::factory_impl< MinCartesianLimit_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->MinCartesianLimit_)
        {
          ::std::auto_ptr< MinCartesianLimit_type > r (
            dynamic_cast< MinCartesianLimit_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->MinCartesianLimit_.set (r);
          continue;
        }
      }
    }

    // MotionCoordinated
    //
    if (n.name () == "MotionCoordinated" && n.namespace_ ().empty ())
    {
      if (!this->MotionCoordinated_)
      {
        this->MotionCoordinated_.set (MotionCoordinated_traits::create (i, f, this));
        continue;
      }
    }

    // EndPoseTolerance
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "EndPoseTolerance",
          "",
          &::xsd::cxx::tree::factory_impl< EndPoseTolerance_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->EndPoseTolerance_)
        {
          ::std::auto_ptr< EndPoseTolerance_type > r (
            dynamic_cast< EndPoseTolerance_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->EndPoseTolerance_.set (r);
          continue;
        }
      }
    }

    // RobotParameterSetting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RobotParameterSetting",
          "",
          &::xsd::cxx::tree::factory_impl< RobotParameterSetting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< RobotParameterSetting_type > r (
          dynamic_cast< RobotParameterSetting_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->RobotParameterSetting_.push_back (r);
        continue;
      }
    }

    // RotAccelAbsolute
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotAccelAbsolute",
          "",
          &::xsd::cxx::tree::factory_impl< RotAccelAbsolute_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->RotAccelAbsolute_)
        {
          ::std::auto_ptr< RotAccelAbsolute_type > r (
            dynamic_cast< RotAccelAbsolute_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotAccelAbsolute_.set (r);
          continue;
        }
      }
    }

    // RotAccelRelative
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotAccelRelative",
          "",
          &::xsd::cxx::tree::factory_impl< RotAccelRelative_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->RotAccelRelative_)
        {
          ::std::auto_ptr< RotAccelRelative_type > r (
            dynamic_cast< RotAccelRelative_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotAccelRelative_.set (r);
          continue;
        }
      }
    }

    // RotSpeedAbsolute
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotSpeedAbsolute",
          "",
          &::xsd::cxx::tree::factory_impl< RotSpeedAbsolute_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->RotSpeedAbsolute_)
        {
          ::std::auto_ptr< RotSpeedAbsolute_type > r (
            dynamic_cast< RotSpeedAbsolute_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotSpeedAbsolute_.set (r);
          continue;
        }
      }
    }

    // RotSpeedRelative
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotSpeedRelative",
          "",
          &::xsd::cxx::tree::factory_impl< RotSpeedRelative_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->RotSpeedRelative_)
        {
          ::std::auto_ptr< RotSpeedRelative_type > r (
            dynamic_cast< RotSpeedRelative_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotSpeedRelative_.set (r);
          continue;
        }
      }
    }

    // TorqueUnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TorqueUnitName",
          "",
          &::xsd::cxx::tree::factory_impl< TorqueUnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TorqueUnitName_)
        {
          ::std::auto_ptr< TorqueUnitName_type > r (
            dynamic_cast< TorqueUnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TorqueUnitName_.set (r);
          continue;
        }
      }
    }

    // TransAccelAbsolute
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransAccelAbsolute",
          "",
          &::xsd::cxx::tree::factory_impl< TransAccelAbsolute_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TransAccelAbsolute_)
        {
          ::std::auto_ptr< TransAccelAbsolute_type > r (
            dynamic_cast< TransAccelAbsolute_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransAccelAbsolute_.set (r);
          continue;
        }
      }
    }

    // TransAccelRelative
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransAccelRelative",
          "",
          &::xsd::cxx::tree::factory_impl< TransAccelRelative_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TransAccelRelative_)
        {
          ::std::auto_ptr< TransAccelRelative_type > r (
            dynamic_cast< TransAccelRelative_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransAccelRelative_.set (r);
          continue;
        }
      }
    }

    // TransSpeedAbsolute
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransSpeedAbsolute",
          "",
          &::xsd::cxx::tree::factory_impl< TransSpeedAbsolute_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TransSpeedAbsolute_)
        {
          ::std::auto_ptr< TransSpeedAbsolute_type > r (
            dynamic_cast< TransSpeedAbsolute_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransSpeedAbsolute_.set (r);
          continue;
        }
      }
    }

    // TransSpeedRelative
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransSpeedRelative",
          "",
          &::xsd::cxx::tree::factory_impl< TransSpeedRelative_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TransSpeedRelative_)
        {
          ::std::auto_ptr< TransSpeedRelative_type > r (
            dynamic_cast< TransSpeedRelative_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransSpeedRelative_.set (r);
          continue;
        }
      }
    }

    // JointTolerances
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointTolerances",
          "",
          &::xsd::cxx::tree::factory_impl< JointTolerances_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->JointTolerances_)
        {
          ::std::auto_ptr< JointTolerances_type > r (
            dynamic_cast< JointTolerances_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->JointTolerances_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

SettingsStatusType* SettingsStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SettingsStatusType (*this, f, c);
}

SettingsStatusType& SettingsStatusType::
operator= (const SettingsStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->AngleUnitName_ = x.AngleUnitName_;
    this->EndEffectorParameterSetting_ = x.EndEffectorParameterSetting_;
    this->EndEffectorSetting_ = x.EndEffectorSetting_;
    this->ForceUnitName_ = x.ForceUnitName_;
    this->JointLimits_ = x.JointLimits_;
    this->IntermediatePoseTolerance_ = x.IntermediatePoseTolerance_;
    this->LengthUnitName_ = x.LengthUnitName_;
    this->MaxCartesianLimit_ = x.MaxCartesianLimit_;
    this->MinCartesianLimit_ = x.MinCartesianLimit_;
    this->MotionCoordinated_ = x.MotionCoordinated_;
    this->EndPoseTolerance_ = x.EndPoseTolerance_;
    this->RobotParameterSetting_ = x.RobotParameterSetting_;
    this->RotAccelAbsolute_ = x.RotAccelAbsolute_;
    this->RotAccelRelative_ = x.RotAccelRelative_;
    this->RotSpeedAbsolute_ = x.RotSpeedAbsolute_;
    this->RotSpeedRelative_ = x.RotSpeedRelative_;
    this->TorqueUnitName_ = x.TorqueUnitName_;
    this->TransAccelAbsolute_ = x.TransAccelAbsolute_;
    this->TransAccelRelative_ = x.TransAccelRelative_;
    this->TransSpeedAbsolute_ = x.TransSpeedAbsolute_;
    this->TransSpeedRelative_ = x.TransSpeedRelative_;
    this->JointTolerances_ = x.JointTolerances_;
  }

  return *this;
}

SettingsStatusType::
~SettingsStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SettingsStatusType >
_xsd_SettingsStatusType_type_factory_init (
  "SettingsStatusType",
  "");

// ThreeFingerGripperStatusType
//

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (const ::GripperStatusType& _xsd_GripperStatusType_base)
: ::GripperStatusType (_xsd_GripperStatusType_base),
  Finger1Position_ (this),
  Finger2Position_ (this),
  Finger3Position_ (this),
  Finger1Force_ (this),
  Finger2Force_ (this),
  Finger3Force_ (this)
{
}

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (const GripperName_type& GripperName)
: ::GripperStatusType (GripperName),
  Finger1Position_ (this),
  Finger2Position_ (this),
  Finger3Position_ (this),
  Finger1Force_ (this),
  Finger2Force_ (this),
  Finger3Force_ (this)
{
}

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (::std::auto_ptr< GripperName_type > GripperName)
: ::GripperStatusType (GripperName),
  Finger1Position_ (this),
  Finger2Position_ (this),
  Finger3Position_ (this),
  Finger1Force_ (this),
  Finger2Force_ (this),
  Finger3Force_ (this)
{
}

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (const ThreeFingerGripperStatusType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::GripperStatusType (x, f, c),
  Finger1Position_ (x.Finger1Position_, f, this),
  Finger2Position_ (x.Finger2Position_, f, this),
  Finger3Position_ (x.Finger3Position_, f, this),
  Finger1Force_ (x.Finger1Force_, f, this),
  Finger2Force_ (x.Finger2Force_, f, this),
  Finger3Force_ (x.Finger3Force_, f, this)
{
}

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::GripperStatusType (e, f | ::xml_schema::flags::base, c),
  Finger1Position_ (this),
  Finger2Position_ (this),
  Finger3Position_ (this),
  Finger1Force_ (this),
  Finger2Force_ (this),
  Finger3Force_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ThreeFingerGripperStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GripperStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Finger1Position
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Finger1Position",
          "",
          &::xsd::cxx::tree::factory_impl< Finger1Position_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Finger1Position_)
        {
          ::std::auto_ptr< Finger1Position_type > r (
            dynamic_cast< Finger1Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Finger1Position_.set (r);
          continue;
        }
      }
    }

    // Finger2Position
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Finger2Position",
          "",
          &::xsd::cxx::tree::factory_impl< Finger2Position_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Finger2Position_)
        {
          ::std::auto_ptr< Finger2Position_type > r (
            dynamic_cast< Finger2Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Finger2Position_.set (r);
          continue;
        }
      }
    }

    // Finger3Position
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Finger3Position",
          "",
          &::xsd::cxx::tree::factory_impl< Finger3Position_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Finger3Position_)
        {
          ::std::auto_ptr< Finger3Position_type > r (
            dynamic_cast< Finger3Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Finger3Position_.set (r);
          continue;
        }
      }
    }

    // Finger1Force
    //
    if (n.name () == "Finger1Force" && n.namespace_ ().empty ())
    {
      if (!this->Finger1Force_)
      {
        this->Finger1Force_.set (Finger1Force_traits::create (i, f, this));
        continue;
      }
    }

    // Finger2Force
    //
    if (n.name () == "Finger2Force" && n.namespace_ ().empty ())
    {
      if (!this->Finger2Force_)
      {
        this->Finger2Force_.set (Finger2Force_traits::create (i, f, this));
        continue;
      }
    }

    // Finger3Force
    //
    if (n.name () == "Finger3Force" && n.namespace_ ().empty ())
    {
      if (!this->Finger3Force_)
      {
        this->Finger3Force_.set (Finger3Force_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

ThreeFingerGripperStatusType* ThreeFingerGripperStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ThreeFingerGripperStatusType (*this, f, c);
}

ThreeFingerGripperStatusType& ThreeFingerGripperStatusType::
operator= (const ThreeFingerGripperStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::GripperStatusType& > (*this) = x;
    this->Finger1Position_ = x.Finger1Position_;
    this->Finger2Position_ = x.Finger2Position_;
    this->Finger3Position_ = x.Finger3Position_;
    this->Finger1Force_ = x.Finger1Force_;
    this->Finger2Force_ = x.Finger2Force_;
    this->Finger3Force_ = x.Finger3Force_;
  }

  return *this;
}

ThreeFingerGripperStatusType::
~ThreeFingerGripperStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThreeFingerGripperStatusType >
_xsd_ThreeFingerGripperStatusType_type_factory_init (
  "ThreeFingerGripperStatusType",
  "");

// VacuumGripperStatusType
//

VacuumGripperStatusType::
VacuumGripperStatusType (const ::GripperStatusType& _xsd_GripperStatusType_base,
                         const IsPowered_type& IsPowered)
: ::GripperStatusType (_xsd_GripperStatusType_base),
  IsPowered_ (IsPowered, this)
{
}

VacuumGripperStatusType::
VacuumGripperStatusType (const GripperName_type& GripperName,
                         const IsPowered_type& IsPowered)
: ::GripperStatusType (GripperName),
  IsPowered_ (IsPowered, this)
{
}

VacuumGripperStatusType::
VacuumGripperStatusType (::std::auto_ptr< GripperName_type > GripperName,
                         const IsPowered_type& IsPowered)
: ::GripperStatusType (GripperName),
  IsPowered_ (IsPowered, this)
{
}

VacuumGripperStatusType::
VacuumGripperStatusType (const VacuumGripperStatusType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::GripperStatusType (x, f, c),
  IsPowered_ (x.IsPowered_, f, this)
{
}

VacuumGripperStatusType::
VacuumGripperStatusType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::GripperStatusType (e, f | ::xml_schema::flags::base, c),
  IsPowered_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void VacuumGripperStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GripperStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // IsPowered
    //
    if (n.name () == "IsPowered" && n.namespace_ ().empty ())
    {
      if (!IsPowered_.present ())
      {
        this->IsPowered_.set (IsPowered_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!IsPowered_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "IsPowered",
      "");
  }
}

VacuumGripperStatusType* VacuumGripperStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class VacuumGripperStatusType (*this, f, c);
}

VacuumGripperStatusType& VacuumGripperStatusType::
operator= (const VacuumGripperStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::GripperStatusType& > (*this) = x;
    this->IsPowered_ = x.IsPowered_;
  }

  return *this;
}

VacuumGripperStatusType::
~VacuumGripperStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, VacuumGripperStatusType >
_xsd_VacuumGripperStatusType_type_factory_init (
  "VacuumGripperStatusType",
  "");

// MapType
//

MapType::
MapType (const map_type& map)
: ::xml_schema::type (),
  map_ (map, this)
{
}

MapType::
MapType (::std::auto_ptr< map_type > map)
: ::xml_schema::type (),
  map_ (map, this)
{
}

MapType::
MapType (const MapType& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  map_ (x.map_, f, this)
{
}

MapType::
MapType (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  map_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MapType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // map
    //
    if (n.name () == "map" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< map_type > r (
        map_traits::create (i, f, this));

      if (!map_.present ())
      {
        this->map_.set (r);
        continue;
      }
    }

    break;
  }

  if (!map_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "map",
      "");
  }
}

MapType* MapType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MapType (*this, f, c);
}

MapType& MapType::
operator= (const MapType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->map_ = x.map_;
  }

  return *this;
}

MapType::
~MapType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, MapType >
_xsd_MapType_type_factory_init (
  "MapType",
  "");

// MapItemType
//

MapItemType::
MapItemType (const key_type& key,
             const value_type& value,
             const name_type& name)
: ::xml_schema::type (),
  key_ (key, this),
  value_ (value, this),
  name_ (name, this)
{
}

MapItemType::
MapItemType (::std::auto_ptr< key_type > key,
             ::std::auto_ptr< value_type > value,
             const name_type& name)
: ::xml_schema::type (),
  key_ (key, this),
  value_ (value, this),
  name_ (name, this)
{
}

MapItemType::
MapItemType (const MapItemType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  key_ (x.key_, f, this),
  value_ (x.value_, f, this),
  name_ (x.name_, f, this)
{
}

MapItemType::
MapItemType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  key_ (this),
  value_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void MapItemType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // key
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "key",
          "",
          &::xsd::cxx::tree::factory_impl< key_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!key_.present ())
        {
          ::std::auto_ptr< key_type > r (
            dynamic_cast< key_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->key_.set (r);
          continue;
        }
      }
    }

    // value
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "value",
          "",
          &::xsd::cxx::tree::factory_impl< value_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!value_.present ())
        {
          ::std::auto_ptr< value_type > r (
            dynamic_cast< value_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->value_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!key_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "key",
      "");
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

MapItemType* MapItemType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MapItemType (*this, f, c);
}

MapItemType& MapItemType::
operator= (const MapItemType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->key_ = x.key_;
    this->value_ = x.value_;
    this->name_ = x.name_;
  }

  return *this;
}

MapItemType::
~MapItemType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, MapItemType >
_xsd_MapItemType_type_factory_init (
  "MapItemType",
  "");

// ModelsStatusType
//

ModelsStatusType::
ModelsStatusType (const Name_type& Name,
                  const Pose_type& Pose)
: ::xml_schema::type (),
  Name_ (Name, this),
  Pose_ (Pose, this),
  Twist_ (this),
  Wrench_ (this),
  Properties_ (this)
{
}

ModelsStatusType::
ModelsStatusType (const Name_type& Name,
                  ::std::auto_ptr< Pose_type > Pose)
: ::xml_schema::type (),
  Name_ (Name, this),
  Pose_ (Pose, this),
  Twist_ (this),
  Wrench_ (this),
  Properties_ (this)
{
}

ModelsStatusType::
ModelsStatusType (::std::auto_ptr< Name_type > Name,
                  ::std::auto_ptr< Pose_type > Pose)
: ::xml_schema::type (),
  Name_ (Name, this),
  Pose_ (Pose, this),
  Twist_ (this),
  Wrench_ (this),
  Properties_ (this)
{
}

ModelsStatusType::
ModelsStatusType (const ModelsStatusType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Pose_ (x.Pose_, f, this),
  Twist_ (x.Twist_, f, this),
  Wrench_ (x.Wrench_, f, this),
  Properties_ (x.Properties_, f, this)
{
}

ModelsStatusType::
ModelsStatusType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Pose_ (this),
  Twist_ (this),
  Wrench_ (this),
  Properties_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ModelsStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Name",
          "",
          &::xsd::cxx::tree::factory_impl< Name_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Name_.present ())
        {
          ::std::auto_ptr< Name_type > r (
            dynamic_cast< Name_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Name_.set (r);
          continue;
        }
      }
    }

    // Pose
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Pose",
          "",
          &::xsd::cxx::tree::factory_impl< Pose_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Pose_.present ())
        {
          ::std::auto_ptr< Pose_type > r (
            dynamic_cast< Pose_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Pose_.set (r);
          continue;
        }
      }
    }

    // Twist
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Twist",
          "",
          &::xsd::cxx::tree::factory_impl< Twist_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Twist_)
        {
          ::std::auto_ptr< Twist_type > r (
            dynamic_cast< Twist_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Twist_.set (r);
          continue;
        }
      }
    }

    // Wrench
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Wrench",
          "",
          &::xsd::cxx::tree::factory_impl< Wrench_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Wrench_)
        {
          ::std::auto_ptr< Wrench_type > r (
            dynamic_cast< Wrench_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Wrench_.set (r);
          continue;
        }
      }
    }

    // Properties
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Properties",
          "",
          &::xsd::cxx::tree::factory_impl< Properties_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Properties_)
        {
          ::std::auto_ptr< Properties_type > r (
            dynamic_cast< Properties_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Properties_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Name",
      "");
  }

  if (!Pose_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pose",
      "");
  }
}

ModelsStatusType* ModelsStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ModelsStatusType (*this, f, c);
}

ModelsStatusType& ModelsStatusType::
operator= (const ModelsStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Pose_ = x.Pose_;
    this->Twist_ = x.Twist_;
    this->Wrench_ = x.Wrench_;
    this->Properties_ = x.Properties_;
  }

  return *this;
}

ModelsStatusType::
~ModelsStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ModelsStatusType >
_xsd_ModelsStatusType_type_factory_init (
  "ModelsStatusType",
  "");

// SensorStatusesType
//

SensorStatusesType::
SensorStatusesType ()
: ::DataThingType (),
  OnOffSensorStatus_ (this),
  ScalarSensorStatus_ (this),
  CountSensorStatus_ (this),
  ForceTorqueSensorStatus_ (this)
{
}

SensorStatusesType::
SensorStatusesType (const SensorStatusesType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  OnOffSensorStatus_ (x.OnOffSensorStatus_, f, this),
  ScalarSensorStatus_ (x.ScalarSensorStatus_, f, this),
  CountSensorStatus_ (x.CountSensorStatus_, f, this),
  ForceTorqueSensorStatus_ (x.ForceTorqueSensorStatus_, f, this)
{
}

SensorStatusesType::
SensorStatusesType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  OnOffSensorStatus_ (this),
  ScalarSensorStatus_ (this),
  CountSensorStatus_ (this),
  ForceTorqueSensorStatus_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SensorStatusesType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // OnOffSensorStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "OnOffSensorStatus",
          "",
          &::xsd::cxx::tree::factory_impl< OnOffSensorStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< OnOffSensorStatus_type > r (
          dynamic_cast< OnOffSensorStatus_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->OnOffSensorStatus_.push_back (r);
        continue;
      }
    }

    // ScalarSensorStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ScalarSensorStatus",
          "",
          &::xsd::cxx::tree::factory_impl< ScalarSensorStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ScalarSensorStatus_type > r (
          dynamic_cast< ScalarSensorStatus_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->ScalarSensorStatus_.push_back (r);
        continue;
      }
    }

    // CountSensorStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "CountSensorStatus",
          "",
          &::xsd::cxx::tree::factory_impl< CountSensorStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< CountSensorStatus_type > r (
          dynamic_cast< CountSensorStatus_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->CountSensorStatus_.push_back (r);
        continue;
      }
    }

    // ForceTorqueSensorStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ForceTorqueSensorStatus",
          "",
          &::xsd::cxx::tree::factory_impl< ForceTorqueSensorStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ForceTorqueSensorStatus_type > r (
          dynamic_cast< ForceTorqueSensorStatus_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->ForceTorqueSensorStatus_.push_back (r);
        continue;
      }
    }

    break;
  }
}

SensorStatusesType* SensorStatusesType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SensorStatusesType (*this, f, c);
}

SensorStatusesType& SensorStatusesType::
operator= (const SensorStatusesType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->OnOffSensorStatus_ = x.OnOffSensorStatus_;
    this->ScalarSensorStatus_ = x.ScalarSensorStatus_;
    this->CountSensorStatus_ = x.CountSensorStatus_;
    this->ForceTorqueSensorStatus_ = x.ForceTorqueSensorStatus_;
  }

  return *this;
}

SensorStatusesType::
~SensorStatusesType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SensorStatusesType >
_xsd_SensorStatusesType_type_factory_init (
  "SensorStatusesType",
  "");

// GuardsStatusesType
//

GuardsStatusesType::
GuardsStatusesType (const TriggerCount_type& TriggerCount,
                    const TriggerStopTimeMicros_type& TriggerStopTimeMicros)
: ::DataThingType (),
  Guard_ (this),
  TriggerCount_ (TriggerCount, this),
  TriggerStopTimeMicros_ (TriggerStopTimeMicros, this),
  TriggerValue_ (this),
  TriggerPose_ (this)
{
}

GuardsStatusesType::
GuardsStatusesType (const GuardsStatusesType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  Guard_ (x.Guard_, f, this),
  TriggerCount_ (x.TriggerCount_, f, this),
  TriggerStopTimeMicros_ (x.TriggerStopTimeMicros_, f, this),
  TriggerValue_ (x.TriggerValue_, f, this),
  TriggerPose_ (x.TriggerPose_, f, this)
{
}

GuardsStatusesType::
GuardsStatusesType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  Guard_ (this),
  TriggerCount_ (this),
  TriggerStopTimeMicros_ (this),
  TriggerValue_ (this),
  TriggerPose_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void GuardsStatusesType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Guard
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Guard",
          "",
          &::xsd::cxx::tree::factory_impl< Guard_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Guard_type > r (
          dynamic_cast< Guard_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Guard_.push_back (r);
        continue;
      }
    }

    // TriggerCount
    //
    if (n.name () == "TriggerCount" && n.namespace_ ().empty ())
    {
      if (!TriggerCount_.present ())
      {
        this->TriggerCount_.set (TriggerCount_traits::create (i, f, this));
        continue;
      }
    }

    // TriggerStopTimeMicros
    //
    if (n.name () == "TriggerStopTimeMicros" && n.namespace_ ().empty ())
    {
      if (!TriggerStopTimeMicros_.present ())
      {
        this->TriggerStopTimeMicros_.set (TriggerStopTimeMicros_traits::create (i, f, this));
        continue;
      }
    }

    // TriggerValue
    //
    if (n.name () == "TriggerValue" && n.namespace_ ().empty ())
    {
      if (!this->TriggerValue_)
      {
        this->TriggerValue_.set (TriggerValue_traits::create (i, f, this));
        continue;
      }
    }

    // TriggerPose
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TriggerPose",
          "",
          &::xsd::cxx::tree::factory_impl< TriggerPose_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TriggerPose_)
        {
          ::std::auto_ptr< TriggerPose_type > r (
            dynamic_cast< TriggerPose_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TriggerPose_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!TriggerCount_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TriggerCount",
      "");
  }

  if (!TriggerStopTimeMicros_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TriggerStopTimeMicros",
      "");
  }
}

GuardsStatusesType* GuardsStatusesType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GuardsStatusesType (*this, f, c);
}

GuardsStatusesType& GuardsStatusesType::
operator= (const GuardsStatusesType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->Guard_ = x.Guard_;
    this->TriggerCount_ = x.TriggerCount_;
    this->TriggerStopTimeMicros_ = x.TriggerStopTimeMicros_;
    this->TriggerValue_ = x.TriggerValue_;
    this->TriggerPose_ = x.TriggerPose_;
  }

  return *this;
}

GuardsStatusesType::
~GuardsStatusesType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GuardsStatusesType >
_xsd_GuardsStatusesType_type_factory_init (
  "GuardsStatusesType",
  "");

// SensorStatusType
//

SensorStatusType::
SensorStatusType (const SensorID_type& SensorID,
                  const ReadCount_type& ReadCount,
                  const LastReadTime_type& LastReadTime)
: ::DataThingType (),
  SensorID_ (SensorID, this),
  ReadCount_ (ReadCount, this),
  LastReadTime_ (LastReadTime, this),
  SensorParameterSetting_ (this)
{
}

SensorStatusType::
SensorStatusType (::std::auto_ptr< SensorID_type > SensorID,
                  const ReadCount_type& ReadCount,
                  const LastReadTime_type& LastReadTime)
: ::DataThingType (),
  SensorID_ (SensorID, this),
  ReadCount_ (ReadCount, this),
  LastReadTime_ (LastReadTime, this),
  SensorParameterSetting_ (this)
{
}

SensorStatusType::
SensorStatusType (const SensorStatusType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  SensorID_ (x.SensorID_, f, this),
  ReadCount_ (x.ReadCount_, f, this),
  LastReadTime_ (x.LastReadTime_, f, this),
  SensorParameterSetting_ (x.SensorParameterSetting_, f, this)
{
}

SensorStatusType::
SensorStatusType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  SensorID_ (this),
  ReadCount_ (this),
  LastReadTime_ (this),
  SensorParameterSetting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SensorStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SensorID
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "SensorID",
          "",
          &::xsd::cxx::tree::factory_impl< SensorID_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!SensorID_.present ())
        {
          ::std::auto_ptr< SensorID_type > r (
            dynamic_cast< SensorID_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->SensorID_.set (r);
          continue;
        }
      }
    }

    // ReadCount
    //
    if (n.name () == "ReadCount" && n.namespace_ ().empty ())
    {
      if (!ReadCount_.present ())
      {
        this->ReadCount_.set (ReadCount_traits::create (i, f, this));
        continue;
      }
    }

    // LastReadTime
    //
    if (n.name () == "LastReadTime" && n.namespace_ ().empty ())
    {
      if (!LastReadTime_.present ())
      {
        this->LastReadTime_.set (LastReadTime_traits::create (i, f, this));
        continue;
      }
    }

    // SensorParameterSetting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "SensorParameterSetting",
          "",
          &::xsd::cxx::tree::factory_impl< SensorParameterSetting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< SensorParameterSetting_type > r (
          dynamic_cast< SensorParameterSetting_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->SensorParameterSetting_.push_back (r);
        continue;
      }
    }

    break;
  }

  if (!SensorID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SensorID",
      "");
  }

  if (!ReadCount_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReadCount",
      "");
  }

  if (!LastReadTime_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LastReadTime",
      "");
  }
}

SensorStatusType* SensorStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SensorStatusType (*this, f, c);
}

SensorStatusType& SensorStatusType::
operator= (const SensorStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->SensorID_ = x.SensorID_;
    this->ReadCount_ = x.ReadCount_;
    this->LastReadTime_ = x.LastReadTime_;
    this->SensorParameterSetting_ = x.SensorParameterSetting_;
  }

  return *this;
}

SensorStatusType::
~SensorStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SensorStatusType >
_xsd_SensorStatusType_type_factory_init (
  "SensorStatusType",
  "");

// OnOffSensorStatusType
//

OnOffSensorStatusType::
OnOffSensorStatusType (const ::SensorStatusType& _xsd_SensorStatusType_base,
                       const On_type& On)
: ::SensorStatusType (_xsd_SensorStatusType_base),
  On_ (On, this)
{
}

OnOffSensorStatusType::
OnOffSensorStatusType (const SensorID_type& SensorID,
                       const ReadCount_type& ReadCount,
                       const LastReadTime_type& LastReadTime,
                       const On_type& On)
: ::SensorStatusType (SensorID,
                      ReadCount,
                      LastReadTime),
  On_ (On, this)
{
}

OnOffSensorStatusType::
OnOffSensorStatusType (::std::auto_ptr< SensorID_type > SensorID,
                       const ReadCount_type& ReadCount,
                       const LastReadTime_type& LastReadTime,
                       const On_type& On)
: ::SensorStatusType (SensorID,
                      ReadCount,
                      LastReadTime),
  On_ (On, this)
{
}

OnOffSensorStatusType::
OnOffSensorStatusType (const OnOffSensorStatusType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::SensorStatusType (x, f, c),
  On_ (x.On_, f, this)
{
}

OnOffSensorStatusType::
OnOffSensorStatusType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::SensorStatusType (e, f | ::xml_schema::flags::base, c),
  On_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void OnOffSensorStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::SensorStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // On
    //
    if (n.name () == "On" && n.namespace_ ().empty ())
    {
      if (!On_.present ())
      {
        this->On_.set (On_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!On_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "On",
      "");
  }
}

OnOffSensorStatusType* OnOffSensorStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OnOffSensorStatusType (*this, f, c);
}

OnOffSensorStatusType& OnOffSensorStatusType::
operator= (const OnOffSensorStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::SensorStatusType& > (*this) = x;
    this->On_ = x.On_;
  }

  return *this;
}

OnOffSensorStatusType::
~OnOffSensorStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, OnOffSensorStatusType >
_xsd_OnOffSensorStatusType_type_factory_init (
  "OnOffSensorStatusType",
  "");

// ForceTorqueSensorStatusType
//

ForceTorqueSensorStatusType::
ForceTorqueSensorStatusType (const ::SensorStatusType& _xsd_SensorStatusType_base,
                             const Fx_type& Fx,
                             const Fy_type& Fy,
                             const Fz_type& Fz,
                             const Tx_type& Tx,
                             const Ty_type& Ty,
                             const Tz_type& Tz)
: ::SensorStatusType (_xsd_SensorStatusType_base),
  Fx_ (Fx, this),
  Fy_ (Fy, this),
  Fz_ (Fz, this),
  Tx_ (Tx, this),
  Ty_ (Ty, this),
  Tz_ (Tz, this)
{
}

ForceTorqueSensorStatusType::
ForceTorqueSensorStatusType (const SensorID_type& SensorID,
                             const ReadCount_type& ReadCount,
                             const LastReadTime_type& LastReadTime,
                             const Fx_type& Fx,
                             const Fy_type& Fy,
                             const Fz_type& Fz,
                             const Tx_type& Tx,
                             const Ty_type& Ty,
                             const Tz_type& Tz)
: ::SensorStatusType (SensorID,
                      ReadCount,
                      LastReadTime),
  Fx_ (Fx, this),
  Fy_ (Fy, this),
  Fz_ (Fz, this),
  Tx_ (Tx, this),
  Ty_ (Ty, this),
  Tz_ (Tz, this)
{
}

ForceTorqueSensorStatusType::
ForceTorqueSensorStatusType (::std::auto_ptr< SensorID_type > SensorID,
                             const ReadCount_type& ReadCount,
                             const LastReadTime_type& LastReadTime,
                             const Fx_type& Fx,
                             const Fy_type& Fy,
                             const Fz_type& Fz,
                             const Tx_type& Tx,
                             const Ty_type& Ty,
                             const Tz_type& Tz)
: ::SensorStatusType (SensorID,
                      ReadCount,
                      LastReadTime),
  Fx_ (Fx, this),
  Fy_ (Fy, this),
  Fz_ (Fz, this),
  Tx_ (Tx, this),
  Ty_ (Ty, this),
  Tz_ (Tz, this)
{
}

ForceTorqueSensorStatusType::
ForceTorqueSensorStatusType (const ForceTorqueSensorStatusType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::SensorStatusType (x, f, c),
  Fx_ (x.Fx_, f, this),
  Fy_ (x.Fy_, f, this),
  Fz_ (x.Fz_, f, this),
  Tx_ (x.Tx_, f, this),
  Ty_ (x.Ty_, f, this),
  Tz_ (x.Tz_, f, this)
{
}

ForceTorqueSensorStatusType::
ForceTorqueSensorStatusType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::SensorStatusType (e, f | ::xml_schema::flags::base, c),
  Fx_ (this),
  Fy_ (this),
  Fz_ (this),
  Tx_ (this),
  Ty_ (this),
  Tz_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ForceTorqueSensorStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::SensorStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Fx
    //
    if (n.name () == "Fx" && n.namespace_ ().empty ())
    {
      if (!Fx_.present ())
      {
        this->Fx_.set (Fx_traits::create (i, f, this));
        continue;
      }
    }

    // Fy
    //
    if (n.name () == "Fy" && n.namespace_ ().empty ())
    {
      if (!Fy_.present ())
      {
        this->Fy_.set (Fy_traits::create (i, f, this));
        continue;
      }
    }

    // Fz
    //
    if (n.name () == "Fz" && n.namespace_ ().empty ())
    {
      if (!Fz_.present ())
      {
        this->Fz_.set (Fz_traits::create (i, f, this));
        continue;
      }
    }

    // Tx
    //
    if (n.name () == "Tx" && n.namespace_ ().empty ())
    {
      if (!Tx_.present ())
      {
        this->Tx_.set (Tx_traits::create (i, f, this));
        continue;
      }
    }

    // Ty
    //
    if (n.name () == "Ty" && n.namespace_ ().empty ())
    {
      if (!Ty_.present ())
      {
        this->Ty_.set (Ty_traits::create (i, f, this));
        continue;
      }
    }

    // Tz
    //
    if (n.name () == "Tz" && n.namespace_ ().empty ())
    {
      if (!Tz_.present ())
      {
        this->Tz_.set (Tz_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Fx_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Fx",
      "");
  }

  if (!Fy_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Fy",
      "");
  }

  if (!Fz_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Fz",
      "");
  }

  if (!Tx_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Tx",
      "");
  }

  if (!Ty_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Ty",
      "");
  }

  if (!Tz_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Tz",
      "");
  }
}

ForceTorqueSensorStatusType* ForceTorqueSensorStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ForceTorqueSensorStatusType (*this, f, c);
}

ForceTorqueSensorStatusType& ForceTorqueSensorStatusType::
operator= (const ForceTorqueSensorStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::SensorStatusType& > (*this) = x;
    this->Fx_ = x.Fx_;
    this->Fy_ = x.Fy_;
    this->Fz_ = x.Fz_;
    this->Tx_ = x.Tx_;
    this->Ty_ = x.Ty_;
    this->Tz_ = x.Tz_;
  }

  return *this;
}

ForceTorqueSensorStatusType::
~ForceTorqueSensorStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ForceTorqueSensorStatusType >
_xsd_ForceTorqueSensorStatusType_type_factory_init (
  "ForceTorqueSensorStatusType",
  "");

// ScalarSensorStatusType
//

ScalarSensorStatusType::
ScalarSensorStatusType (const ::SensorStatusType& _xsd_SensorStatusType_base,
                        const ScalarValue__type& ScalarValue_)
: ::SensorStatusType (_xsd_SensorStatusType_base),
  ScalarValue__ (ScalarValue_, this)
{
}

ScalarSensorStatusType::
ScalarSensorStatusType (const SensorID_type& SensorID,
                        const ReadCount_type& ReadCount,
                        const LastReadTime_type& LastReadTime,
                        const ScalarValue__type& ScalarValue_)
: ::SensorStatusType (SensorID,
                      ReadCount,
                      LastReadTime),
  ScalarValue__ (ScalarValue_, this)
{
}

ScalarSensorStatusType::
ScalarSensorStatusType (::std::auto_ptr< SensorID_type > SensorID,
                        const ReadCount_type& ReadCount,
                        const LastReadTime_type& LastReadTime,
                        const ScalarValue__type& ScalarValue_)
: ::SensorStatusType (SensorID,
                      ReadCount,
                      LastReadTime),
  ScalarValue__ (ScalarValue_, this)
{
}

ScalarSensorStatusType::
ScalarSensorStatusType (const ScalarSensorStatusType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::SensorStatusType (x, f, c),
  ScalarValue__ (x.ScalarValue__, f, this)
{
}

ScalarSensorStatusType::
ScalarSensorStatusType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::SensorStatusType (e, f | ::xml_schema::flags::base, c),
  ScalarValue__ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ScalarSensorStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::SensorStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ScalarValue.
    //
    if (n.name () == "ScalarValue." && n.namespace_ ().empty ())
    {
      if (!ScalarValue__.present ())
      {
        this->ScalarValue__.set (ScalarValue__traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!ScalarValue__.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ScalarValue.",
      "");
  }
}

ScalarSensorStatusType* ScalarSensorStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ScalarSensorStatusType (*this, f, c);
}

ScalarSensorStatusType& ScalarSensorStatusType::
operator= (const ScalarSensorStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::SensorStatusType& > (*this) = x;
    this->ScalarValue__ = x.ScalarValue__;
  }

  return *this;
}

ScalarSensorStatusType::
~ScalarSensorStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ScalarSensorStatusType >
_xsd_ScalarSensorStatusType_type_factory_init (
  "ScalarSensorStatusType",
  "");

// CountSensorStatusType
//

CountSensorStatusType::
CountSensorStatusType (const ::SensorStatusType& _xsd_SensorStatusType_base,
                       const CountValue__type& CountValue_)
: ::SensorStatusType (_xsd_SensorStatusType_base),
  CountValue__ (CountValue_, this)
{
}

CountSensorStatusType::
CountSensorStatusType (const SensorID_type& SensorID,
                       const ReadCount_type& ReadCount,
                       const LastReadTime_type& LastReadTime,
                       const CountValue__type& CountValue_)
: ::SensorStatusType (SensorID,
                      ReadCount,
                      LastReadTime),
  CountValue__ (CountValue_, this)
{
}

CountSensorStatusType::
CountSensorStatusType (::std::auto_ptr< SensorID_type > SensorID,
                       const ReadCount_type& ReadCount,
                       const LastReadTime_type& LastReadTime,
                       const CountValue__type& CountValue_)
: ::SensorStatusType (SensorID,
                      ReadCount,
                      LastReadTime),
  CountValue__ (CountValue_, this)
{
}

CountSensorStatusType::
CountSensorStatusType (const CountSensorStatusType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::SensorStatusType (x, f, c),
  CountValue__ (x.CountValue__, f, this)
{
}

CountSensorStatusType::
CountSensorStatusType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::SensorStatusType (e, f | ::xml_schema::flags::base, c),
  CountValue__ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CountSensorStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::SensorStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CountValue.
    //
    if (n.name () == "CountValue." && n.namespace_ ().empty ())
    {
      if (!CountValue__.present ())
      {
        this->CountValue__.set (CountValue__traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!CountValue__.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CountValue.",
      "");
  }
}

CountSensorStatusType* CountSensorStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CountSensorStatusType (*this, f, c);
}

CountSensorStatusType& CountSensorStatusType::
operator= (const CountSensorStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::SensorStatusType& > (*this) = x;
    this->CountValue__ = x.CountValue__;
  }

  return *this;
}

CountSensorStatusType::
~CountSensorStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CountSensorStatusType >
_xsd_CountSensorStatusType_type_factory_init (
  "CountSensorStatusType",
  "");

// map
//

map::
map ()
: ::xml_schema::type (),
  item_ (this)
{
}

map::
map (const map& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  item_ (x.item_, f, this)
{
}

map::
map (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  item_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void map::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // item
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "item",
          "",
          &::xsd::cxx::tree::factory_impl< item_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< item_type > r (
          dynamic_cast< item_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->item_.push_back (r);
        continue;
      }
    }

    break;
  }
}

map* map::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class map (*this, f, c);
}

map& map::
operator= (const map& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->item_ = x.item_;
  }

  return *this;
}

map::
~map ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CRCLStatus (isrc, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CRCLStatus (isrc, h, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CRCLStatus (isrc, h, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CRCLStatus (isrc, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CRCLStatus (isrc, h, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CRCLStatus (isrc, h, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::CRCLStatusType > (
      ::CRCLStatus (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
      "CRCLStatus",
      "",
      &::xsd::cxx::tree::factory_impl< ::CRCLStatusType >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::CRCLStatusType > r (
      dynamic_cast< ::CRCLStatusType* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CRCLStatus",
    "");
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
      "CRCLStatus",
      "",
      &::xsd::cxx::tree::factory_impl< ::CRCLStatusType >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::CRCLStatusType > r (
      dynamic_cast< ::CRCLStatusType* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CRCLStatus",
    "");
}

::std::auto_ptr< ::map >
map_ (const ::std::string& u,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::map > (
    ::map_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::map >
map_ (const ::std::string& u,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::map > (
    ::map_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::map >
map_ (const ::std::string& u,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::map > (
    ::map_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::map >
map_ (::std::istream& is,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::map_ (isrc, f, p);
}

::std::auto_ptr< ::map >
map_ (::std::istream& is,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::map_ (isrc, h, f, p);
}

::std::auto_ptr< ::map >
map_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::map_ (isrc, h, f, p);
}

::std::auto_ptr< ::map >
map_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::map_ (isrc, f, p);
}

::std::auto_ptr< ::map >
map_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::map_ (isrc, h, f, p);
}

::std::auto_ptr< ::map >
map_ (::std::istream& is,
      const ::std::string& sid,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::map_ (isrc, h, f, p);
}

::std::auto_ptr< ::map >
map_ (::xercesc::InputSource& i,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::map > (
    ::map_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::map >
map_ (::xercesc::InputSource& i,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::map > (
    ::map_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::map >
map_ (::xercesc::InputSource& i,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::map > (
    ::map_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::map >
map_ (const ::xercesc::DOMDocument& doc,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::map > (
      ::map_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "map" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::map > r (
      ::xsd::cxx::tree::traits< ::map, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "map",
    "");
}

::std::auto_ptr< ::map >
map_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
      ::xml_schema::flags f,
      const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "map" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::map > r (
      ::xsd::cxx::tree::traits< ::map, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "map",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
CRCLStatus (::std::ostream& o,
            const ::CRCLStatusType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
CRCLStatus (::std::ostream& o,
            const ::CRCLStatusType& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CRCLStatus (::std::ostream& o,
            const ::CRCLStatusType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CRCLStatus (::xercesc::XMLFormatTarget& t,
            const ::CRCLStatusType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
CRCLStatus (::xercesc::XMLFormatTarget& t,
            const ::CRCLStatusType& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CRCLStatus (::xercesc::XMLFormatTarget& t,
            const ::CRCLStatusType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CRCLStatus (::xercesc::DOMDocument& d,
            const ::CRCLStatusType& s,
            ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::CRCLStatusType) == typeid (s))
  {
    if (n.name () == "CRCLStatus" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CRCLStatus",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
      "CRCLStatus",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
CRCLStatus (const ::CRCLStatusType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::CRCLStatusType) == typeid (s))
  {
    d = ::xsd::cxx::xml::dom::serialize< char > (
      "CRCLStatus",
      "",
      m, f);
  }
  else
  {
    d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
      "CRCLStatus",
      "",
      m, s, f);
  }

  ::CRCLStatus (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const CommandStateEnumType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const CommandStateEnumType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const CommandStateEnumType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CommandStateEnumType >
_xsd_CommandStateEnumType_type_serializer_init (
  "CommandStateEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const CommandStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // CommandID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CommandID",
        e));

    s << i.CommandID ();
  }

  // StatusID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "StatusID",
        e));

    s << i.StatusID ();
  }

  // CommandState
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const CommandStatusType::CommandState_type& x (i.CommandState ());
    if (typeid (CommandStatusType::CommandState_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CommandState",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "CommandState",
        "",
        false, true, e, x);
  }

  // StateDescription
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.StateDescription ())
    {
      const CommandStatusType::StateDescription_type& x (*i.StateDescription ());
      if (typeid (CommandStatusType::StateDescription_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StateDescription",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "StateDescription",
          "",
          false, true, e, x);
    }
  }

  // ProgramFile
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.ProgramFile ())
    {
      const CommandStatusType::ProgramFile_type& x (*i.ProgramFile ());
      if (typeid (CommandStatusType::ProgramFile_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProgramFile",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ProgramFile",
          "",
          false, true, e, x);
    }
  }

  // ProgramIndex
  //
  if (i.ProgramIndex ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ProgramIndex",
        e));

    s << *i.ProgramIndex ();
  }

  // ProgramLength
  //
  if (i.ProgramLength ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ProgramLength",
        e));

    s << *i.ProgramLength ();
  }

  // OverridePercent
  //
  if (i.OverridePercent ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "OverridePercent",
        e));

    s << *i.OverridePercent ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CommandStatusType >
_xsd_CommandStatusType_type_serializer_init (
  "CommandStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const CRCLStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // CommandStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const CRCLStatusType::CommandStatus_type& x (i.CommandStatus ());
    if (typeid (CRCLStatusType::CommandStatus_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CommandStatus",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "CommandStatus",
        "",
        false, true, e, x);
  }

  // JointStatuses
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.JointStatuses ())
    {
      const CRCLStatusType::JointStatuses_type& x (*i.JointStatuses ());
      if (typeid (CRCLStatusType::JointStatuses_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "JointStatuses",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "JointStatuses",
          "",
          false, true, e, x);
    }
  }

  // PoseStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.PoseStatus ())
    {
      const CRCLStatusType::PoseStatus_type& x (*i.PoseStatus ());
      if (typeid (CRCLStatusType::PoseStatus_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PoseStatus",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "PoseStatus",
          "",
          false, true, e, x);
    }
  }

  // GripperStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.GripperStatus ())
    {
      const CRCLStatusType::GripperStatus_type& x (*i.GripperStatus ());
      if (typeid (CRCLStatusType::GripperStatus_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GripperStatus",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "GripperStatus",
          "",
          false, true, e, x);
    }
  }

  // SettingsStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.SettingsStatus ())
    {
      const CRCLStatusType::SettingsStatus_type& x (*i.SettingsStatus ());
      if (typeid (CRCLStatusType::SettingsStatus_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SettingsStatus",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SettingsStatus",
          "",
          false, true, e, x);
    }
  }

  // SensorStatuses
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.SensorStatuses ())
    {
      const CRCLStatusType::SensorStatuses_type& x (*i.SensorStatuses ());
      if (typeid (CRCLStatusType::SensorStatuses_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SensorStatuses",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SensorStatuses",
          "",
          false, true, e, x);
    }
  }

  // GuardsStatuses
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.GuardsStatuses ())
    {
      const CRCLStatusType::GuardsStatuses_type& x (*i.GuardsStatuses ());
      if (typeid (CRCLStatusType::GuardsStatuses_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GuardsStatuses",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "GuardsStatuses",
          "",
          false, true, e, x);
    }
  }

  // ModelStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (CRCLStatusType::ModelStatus_const_iterator
         b (i.ModelStatus ().begin ()), n (i.ModelStatus ().end ());
         b != n; ++b)
    {
      if (typeid (CRCLStatusType::ModelStatus_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ModelStatus",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "ModelStatus",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CRCLStatusType >
_xsd_CRCLStatusType_type_serializer_init (
  "CRCLStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const GripperStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // GripperName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const GripperStatusType::GripperName_type& x (i.GripperName ());
    if (typeid (GripperStatusType::GripperName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "GripperName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "GripperName",
        "",
        false, true, e, x);
  }

  // GripperOption
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (GripperStatusType::GripperOption_const_iterator
         b (i.GripperOption ().begin ()), n (i.GripperOption ().end ());
         b != n; ++b)
    {
      if (typeid (GripperStatusType::GripperOption_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GripperOption",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "GripperOption",
          "",
          false, true, e, *b);
    }
  }

  // HoldingObject
  //
  if (i.HoldingObject ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "HoldingObject",
        e));

    s << *i.HoldingObject ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GripperStatusType >
_xsd_GripperStatusType_type_serializer_init (
  "GripperStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointStatusesType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // JointStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (JointStatusesType::JointStatus_const_iterator
         b (i.JointStatus ().begin ()), n (i.JointStatus ().end ());
         b != n; ++b)
    {
      if (typeid (JointStatusesType::JointStatus_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "JointStatus",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "JointStatus",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointStatusesType >
_xsd_JointStatusesType_type_serializer_init (
  "JointStatusesType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // JointNumber
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointNumber",
        e));

    s << i.JointNumber ();
  }

  // JointPosition
  //
  if (i.JointPosition ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointPosition",
        e));

    s << ::xml_schema::as_double(*i.JointPosition ());
  }

  // JointTorqueOrForce
  //
  if (i.JointTorqueOrForce ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointTorqueOrForce",
        e));

    s << ::xml_schema::as_double(*i.JointTorqueOrForce ());
  }

  // JointVelocity
  //
  if (i.JointVelocity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointVelocity",
        e));

    s << ::xml_schema::as_double(*i.JointVelocity ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointStatusType >
_xsd_JointStatusType_type_serializer_init (
  "JointStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointLimitType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // JointNumber
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointNumber",
        e));

    s << i.JointNumber ();
  }

  // JointMinPosition
  //
  if (i.JointMinPosition ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointMinPosition",
        e));

    s << ::xml_schema::as_double(*i.JointMinPosition ());
  }

  // JointMaxPosition
  //
  if (i.JointMaxPosition ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointMaxPosition",
        e));

    s << ::xml_schema::as_double(*i.JointMaxPosition ());
  }

  // JointMaxTorqueOrForce
  //
  if (i.JointMaxTorqueOrForce ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointMaxTorqueOrForce",
        e));

    s << ::xml_schema::as_double(*i.JointMaxTorqueOrForce ());
  }

  // JointMaxVelocity
  //
  if (i.JointMaxVelocity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointMaxVelocity",
        e));

    s << ::xml_schema::as_double(*i.JointMaxVelocity ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointLimitType >
_xsd_JointLimitType_type_serializer_init (
  "JointLimitType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParallelGripperStatusType& i)
{
  e << static_cast< const ::GripperStatusType& > (i);

  // Separation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Separation",
        e));

    s << ::xml_schema::as_double(i.Separation ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParallelGripperStatusType >
_xsd_ParallelGripperStatusType_type_serializer_init (
  "ParallelGripperStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const PoseStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // Pose
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const PoseStatusType::Pose_type& x (i.Pose ());
    if (typeid (PoseStatusType::Pose_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Pose",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Pose",
        "",
        false, true, e, x);
  }

  // Twist
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Twist ())
    {
      const PoseStatusType::Twist_type& x (*i.Twist ());
      if (typeid (PoseStatusType::Twist_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Twist",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Twist",
          "",
          false, true, e, x);
    }
  }

  // Wrench
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Wrench ())
    {
      const PoseStatusType::Wrench_type& x (*i.Wrench ());
      if (typeid (PoseStatusType::Wrench_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Wrench",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Wrench",
          "",
          false, true, e, x);
    }
  }

  // Configuration
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Configuration ())
    {
      const PoseStatusType::Configuration_type& x (*i.Configuration ());
      if (typeid (PoseStatusType::Configuration_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Configuration",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Configuration",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PoseStatusType >
_xsd_PoseStatusType_type_serializer_init (
  "PoseStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SettingsStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // AngleUnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.AngleUnitName ())
    {
      const SettingsStatusType::AngleUnitName_type& x (*i.AngleUnitName ());
      if (typeid (SettingsStatusType::AngleUnitName_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AngleUnitName",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AngleUnitName",
          "",
          false, true, e, x);
    }
  }

  // EndEffectorParameterSetting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SettingsStatusType::EndEffectorParameterSetting_const_iterator
         b (i.EndEffectorParameterSetting ().begin ()), n (i.EndEffectorParameterSetting ().end ());
         b != n; ++b)
    {
      if (typeid (SettingsStatusType::EndEffectorParameterSetting_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndEffectorParameterSetting",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "EndEffectorParameterSetting",
          "",
          false, true, e, *b);
    }
  }

  // EndEffectorSetting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.EndEffectorSetting ())
    {
      const SettingsStatusType::EndEffectorSetting_type& x (*i.EndEffectorSetting ());
      if (typeid (SettingsStatusType::EndEffectorSetting_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndEffectorSetting",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "EndEffectorSetting",
          "",
          false, true, e, x);
    }
  }

  // ForceUnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.ForceUnitName ())
    {
      const SettingsStatusType::ForceUnitName_type& x (*i.ForceUnitName ());
      if (typeid (SettingsStatusType::ForceUnitName_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ForceUnitName",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ForceUnitName",
          "",
          false, true, e, x);
    }
  }

  // JointLimits
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SettingsStatusType::JointLimits_const_iterator
         b (i.JointLimits ().begin ()), n (i.JointLimits ().end ());
         b != n; ++b)
    {
      if (typeid (SettingsStatusType::JointLimits_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "JointLimits",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "JointLimits",
          "",
          false, true, e, *b);
    }
  }

  // IntermediatePoseTolerance
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.IntermediatePoseTolerance ())
    {
      const SettingsStatusType::IntermediatePoseTolerance_type& x (*i.IntermediatePoseTolerance ());
      if (typeid (SettingsStatusType::IntermediatePoseTolerance_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IntermediatePoseTolerance",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "IntermediatePoseTolerance",
          "",
          false, true, e, x);
    }
  }

  // LengthUnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.LengthUnitName ())
    {
      const SettingsStatusType::LengthUnitName_type& x (*i.LengthUnitName ());
      if (typeid (SettingsStatusType::LengthUnitName_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthUnitName",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "LengthUnitName",
          "",
          false, true, e, x);
    }
  }

  // MaxCartesianLimit
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.MaxCartesianLimit ())
    {
      const SettingsStatusType::MaxCartesianLimit_type& x (*i.MaxCartesianLimit ());
      if (typeid (SettingsStatusType::MaxCartesianLimit_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxCartesianLimit",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MaxCartesianLimit",
          "",
          false, true, e, x);
    }
  }

  // MinCartesianLimit
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.MinCartesianLimit ())
    {
      const SettingsStatusType::MinCartesianLimit_type& x (*i.MinCartesianLimit ());
      if (typeid (SettingsStatusType::MinCartesianLimit_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinCartesianLimit",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MinCartesianLimit",
          "",
          false, true, e, x);
    }
  }

  // MotionCoordinated
  //
  if (i.MotionCoordinated ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MotionCoordinated",
        e));

    s << *i.MotionCoordinated ();
  }

  // EndPoseTolerance
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.EndPoseTolerance ())
    {
      const SettingsStatusType::EndPoseTolerance_type& x (*i.EndPoseTolerance ());
      if (typeid (SettingsStatusType::EndPoseTolerance_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndPoseTolerance",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "EndPoseTolerance",
          "",
          false, true, e, x);
    }
  }

  // RobotParameterSetting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SettingsStatusType::RobotParameterSetting_const_iterator
         b (i.RobotParameterSetting ().begin ()), n (i.RobotParameterSetting ().end ());
         b != n; ++b)
    {
      if (typeid (SettingsStatusType::RobotParameterSetting_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RobotParameterSetting",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "RobotParameterSetting",
          "",
          false, true, e, *b);
    }
  }

  // RotAccelAbsolute
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.RotAccelAbsolute ())
    {
      const SettingsStatusType::RotAccelAbsolute_type& x (*i.RotAccelAbsolute ());
      if (typeid (SettingsStatusType::RotAccelAbsolute_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotAccelAbsolute",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RotAccelAbsolute",
          "",
          false, true, e, x);
    }
  }

  // RotAccelRelative
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.RotAccelRelative ())
    {
      const SettingsStatusType::RotAccelRelative_type& x (*i.RotAccelRelative ());
      if (typeid (SettingsStatusType::RotAccelRelative_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotAccelRelative",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RotAccelRelative",
          "",
          false, true, e, x);
    }
  }

  // RotSpeedAbsolute
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.RotSpeedAbsolute ())
    {
      const SettingsStatusType::RotSpeedAbsolute_type& x (*i.RotSpeedAbsolute ());
      if (typeid (SettingsStatusType::RotSpeedAbsolute_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotSpeedAbsolute",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RotSpeedAbsolute",
          "",
          false, true, e, x);
    }
  }

  // RotSpeedRelative
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.RotSpeedRelative ())
    {
      const SettingsStatusType::RotSpeedRelative_type& x (*i.RotSpeedRelative ());
      if (typeid (SettingsStatusType::RotSpeedRelative_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotSpeedRelative",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RotSpeedRelative",
          "",
          false, true, e, x);
    }
  }

  // TorqueUnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TorqueUnitName ())
    {
      const SettingsStatusType::TorqueUnitName_type& x (*i.TorqueUnitName ());
      if (typeid (SettingsStatusType::TorqueUnitName_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TorqueUnitName",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TorqueUnitName",
          "",
          false, true, e, x);
    }
  }

  // TransAccelAbsolute
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TransAccelAbsolute ())
    {
      const SettingsStatusType::TransAccelAbsolute_type& x (*i.TransAccelAbsolute ());
      if (typeid (SettingsStatusType::TransAccelAbsolute_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransAccelAbsolute",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TransAccelAbsolute",
          "",
          false, true, e, x);
    }
  }

  // TransAccelRelative
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TransAccelRelative ())
    {
      const SettingsStatusType::TransAccelRelative_type& x (*i.TransAccelRelative ());
      if (typeid (SettingsStatusType::TransAccelRelative_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransAccelRelative",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TransAccelRelative",
          "",
          false, true, e, x);
    }
  }

  // TransSpeedAbsolute
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TransSpeedAbsolute ())
    {
      const SettingsStatusType::TransSpeedAbsolute_type& x (*i.TransSpeedAbsolute ());
      if (typeid (SettingsStatusType::TransSpeedAbsolute_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransSpeedAbsolute",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TransSpeedAbsolute",
          "",
          false, true, e, x);
    }
  }

  // TransSpeedRelative
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TransSpeedRelative ())
    {
      const SettingsStatusType::TransSpeedRelative_type& x (*i.TransSpeedRelative ());
      if (typeid (SettingsStatusType::TransSpeedRelative_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransSpeedRelative",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TransSpeedRelative",
          "",
          false, true, e, x);
    }
  }

  // JointTolerances
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.JointTolerances ())
    {
      const SettingsStatusType::JointTolerances_type& x (*i.JointTolerances ());
      if (typeid (SettingsStatusType::JointTolerances_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "JointTolerances",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "JointTolerances",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SettingsStatusType >
_xsd_SettingsStatusType_type_serializer_init (
  "SettingsStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ThreeFingerGripperStatusType& i)
{
  e << static_cast< const ::GripperStatusType& > (i);

  // Finger1Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Finger1Position ())
    {
      const ThreeFingerGripperStatusType::Finger1Position_type& x (*i.Finger1Position ());
      if (typeid (ThreeFingerGripperStatusType::Finger1Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Finger1Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Finger1Position",
          "",
          false, true, e, x);
    }
  }

  // Finger2Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Finger2Position ())
    {
      const ThreeFingerGripperStatusType::Finger2Position_type& x (*i.Finger2Position ());
      if (typeid (ThreeFingerGripperStatusType::Finger2Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Finger2Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Finger2Position",
          "",
          false, true, e, x);
    }
  }

  // Finger3Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Finger3Position ())
    {
      const ThreeFingerGripperStatusType::Finger3Position_type& x (*i.Finger3Position ());
      if (typeid (ThreeFingerGripperStatusType::Finger3Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Finger3Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Finger3Position",
          "",
          false, true, e, x);
    }
  }

  // Finger1Force
  //
  if (i.Finger1Force ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Finger1Force",
        e));

    s << ::xml_schema::as_double(*i.Finger1Force ());
  }

  // Finger2Force
  //
  if (i.Finger2Force ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Finger2Force",
        e));

    s << ::xml_schema::as_double(*i.Finger2Force ());
  }

  // Finger3Force
  //
  if (i.Finger3Force ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Finger3Force",
        e));

    s << ::xml_schema::as_double(*i.Finger3Force ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThreeFingerGripperStatusType >
_xsd_ThreeFingerGripperStatusType_type_serializer_init (
  "ThreeFingerGripperStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const VacuumGripperStatusType& i)
{
  e << static_cast< const ::GripperStatusType& > (i);

  // IsPowered
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IsPowered",
        e));

    s << i.IsPowered ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VacuumGripperStatusType >
_xsd_VacuumGripperStatusType_type_serializer_init (
  "VacuumGripperStatusType",
  "");


void
map_ (::std::ostream& o,
      const ::map& s,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::map_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
map_ (::std::ostream& o,
      const ::map& s,
      ::xml_schema::error_handler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::map_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
map_ (::std::ostream& o,
      const ::map& s,
      ::xercesc::DOMErrorHandler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::map_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
map_ (::xercesc::XMLFormatTarget& t,
      const ::map& s,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::map_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
map_ (::xercesc::XMLFormatTarget& t,
      const ::map& s,
      ::xml_schema::error_handler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::map_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
map_ (::xercesc::XMLFormatTarget& t,
      const ::map& s,
      ::xercesc::DOMErrorHandler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::map_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
map_ (::xercesc::DOMDocument& d,
      const ::map& s,
      ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "map" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "map",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
map_ (const ::map& s,
      const ::xml_schema::namespace_infomap& m,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "map",
      "",
      m, f));

  ::map_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const MapType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // map
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "map",
        e));

    s << i.map ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MapType >
_xsd_MapType_type_serializer_init (
  "MapType",
  "");


void
operator<< (::xercesc::DOMElement& e, const MapItemType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // key
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const MapItemType::key_type& x (i.key ());
    if (typeid (MapItemType::key_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "key",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "key",
        "",
        false, true, e, x);
  }

  // value
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const MapItemType::value_type& x (i.value ());
    if (typeid (MapItemType::value_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "value",
        "",
        false, true, e, x);
  }

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MapItemType >
_xsd_MapItemType_type_serializer_init (
  "MapItemType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ModelsStatusType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const ModelsStatusType::Name_type& x (i.Name ());
    if (typeid (ModelsStatusType::Name_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Name",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Name",
        "",
        false, true, e, x);
  }

  // Pose
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const ModelsStatusType::Pose_type& x (i.Pose ());
    if (typeid (ModelsStatusType::Pose_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Pose",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Pose",
        "",
        false, true, e, x);
  }

  // Twist
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Twist ())
    {
      const ModelsStatusType::Twist_type& x (*i.Twist ());
      if (typeid (ModelsStatusType::Twist_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Twist",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Twist",
          "",
          false, true, e, x);
    }
  }

  // Wrench
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Wrench ())
    {
      const ModelsStatusType::Wrench_type& x (*i.Wrench ());
      if (typeid (ModelsStatusType::Wrench_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Wrench",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Wrench",
          "",
          false, true, e, x);
    }
  }

  // Properties
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Properties ())
    {
      const ModelsStatusType::Properties_type& x (*i.Properties ());
      if (typeid (ModelsStatusType::Properties_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Properties",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Properties",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ModelsStatusType >
_xsd_ModelsStatusType_type_serializer_init (
  "ModelsStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SensorStatusesType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // OnOffSensorStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SensorStatusesType::OnOffSensorStatus_const_iterator
         b (i.OnOffSensorStatus ().begin ()), n (i.OnOffSensorStatus ().end ());
         b != n; ++b)
    {
      if (typeid (SensorStatusesType::OnOffSensorStatus_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OnOffSensorStatus",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "OnOffSensorStatus",
          "",
          false, true, e, *b);
    }
  }

  // ScalarSensorStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SensorStatusesType::ScalarSensorStatus_const_iterator
         b (i.ScalarSensorStatus ().begin ()), n (i.ScalarSensorStatus ().end ());
         b != n; ++b)
    {
      if (typeid (SensorStatusesType::ScalarSensorStatus_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ScalarSensorStatus",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "ScalarSensorStatus",
          "",
          false, true, e, *b);
    }
  }

  // CountSensorStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SensorStatusesType::CountSensorStatus_const_iterator
         b (i.CountSensorStatus ().begin ()), n (i.CountSensorStatus ().end ());
         b != n; ++b)
    {
      if (typeid (SensorStatusesType::CountSensorStatus_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CountSensorStatus",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "CountSensorStatus",
          "",
          false, true, e, *b);
    }
  }

  // ForceTorqueSensorStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SensorStatusesType::ForceTorqueSensorStatus_const_iterator
         b (i.ForceTorqueSensorStatus ().begin ()), n (i.ForceTorqueSensorStatus ().end ());
         b != n; ++b)
    {
      if (typeid (SensorStatusesType::ForceTorqueSensorStatus_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ForceTorqueSensorStatus",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "ForceTorqueSensorStatus",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SensorStatusesType >
_xsd_SensorStatusesType_type_serializer_init (
  "SensorStatusesType",
  "");


void
operator<< (::xercesc::DOMElement& e, const GuardsStatusesType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // Guard
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (GuardsStatusesType::Guard_const_iterator
         b (i.Guard ().begin ()), n (i.Guard ().end ());
         b != n; ++b)
    {
      if (typeid (GuardsStatusesType::Guard_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Guard",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Guard",
          "",
          false, true, e, *b);
    }
  }

  // TriggerCount
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TriggerCount",
        e));

    s << i.TriggerCount ();
  }

  // TriggerStopTimeMicros
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TriggerStopTimeMicros",
        e));

    s << i.TriggerStopTimeMicros ();
  }

  // TriggerValue
  //
  if (i.TriggerValue ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TriggerValue",
        e));

    s << ::xml_schema::as_double(*i.TriggerValue ());
  }

  // TriggerPose
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TriggerPose ())
    {
      const GuardsStatusesType::TriggerPose_type& x (*i.TriggerPose ());
      if (typeid (GuardsStatusesType::TriggerPose_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TriggerPose",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TriggerPose",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GuardsStatusesType >
_xsd_GuardsStatusesType_type_serializer_init (
  "GuardsStatusesType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SensorStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // SensorID
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SensorStatusType::SensorID_type& x (i.SensorID ());
    if (typeid (SensorStatusType::SensorID_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SensorID",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "SensorID",
        "",
        false, true, e, x);
  }

  // ReadCount
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReadCount",
        e));

    s << i.ReadCount ();
  }

  // LastReadTime
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LastReadTime",
        e));

    s << i.LastReadTime ();
  }

  // SensorParameterSetting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SensorStatusType::SensorParameterSetting_const_iterator
         b (i.SensorParameterSetting ().begin ()), n (i.SensorParameterSetting ().end ());
         b != n; ++b)
    {
      if (typeid (SensorStatusType::SensorParameterSetting_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SensorParameterSetting",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "SensorParameterSetting",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SensorStatusType >
_xsd_SensorStatusType_type_serializer_init (
  "SensorStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const OnOffSensorStatusType& i)
{
  e << static_cast< const ::SensorStatusType& > (i);

  // On
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "On",
        e));

    s << i.On ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OnOffSensorStatusType >
_xsd_OnOffSensorStatusType_type_serializer_init (
  "OnOffSensorStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ForceTorqueSensorStatusType& i)
{
  e << static_cast< const ::SensorStatusType& > (i);

  // Fx
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Fx",
        e));

    s << ::xml_schema::as_double(i.Fx ());
  }

  // Fy
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Fy",
        e));

    s << ::xml_schema::as_double(i.Fy ());
  }

  // Fz
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Fz",
        e));

    s << ::xml_schema::as_double(i.Fz ());
  }

  // Tx
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Tx",
        e));

    s << ::xml_schema::as_double(i.Tx ());
  }

  // Ty
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Ty",
        e));

    s << ::xml_schema::as_double(i.Ty ());
  }

  // Tz
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Tz",
        e));

    s << ::xml_schema::as_double(i.Tz ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ForceTorqueSensorStatusType >
_xsd_ForceTorqueSensorStatusType_type_serializer_init (
  "ForceTorqueSensorStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ScalarSensorStatusType& i)
{
  e << static_cast< const ::SensorStatusType& > (i);

  // ScalarValue.
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ScalarValue.",
        e));

    s << ::xml_schema::as_double(i.ScalarValue_ ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ScalarSensorStatusType >
_xsd_ScalarSensorStatusType_type_serializer_init (
  "ScalarSensorStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const CountSensorStatusType& i)
{
  e << static_cast< const ::SensorStatusType& > (i);

  // CountValue.
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CountValue.",
        e));

    s << i.CountValue_ ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CountSensorStatusType >
_xsd_CountSensorStatusType_type_serializer_init (
  "CountSensorStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const map& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // item
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (map::item_const_iterator
         b (i.item ().begin ()), n (i.item ().end ());
         b != n; ++b)
    {
      if (typeid (map::item_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "item",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "item",
          "",
          false, true, e, *b);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

